<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2023-03-04-数组类算法</title>
    <url>/posts/a1d1.html</url>
    <content><![CDATA[<h1 id="数组类算法"><a href="#数组类算法" class="headerlink" title="数组类算法"></a>数组类算法</h1><h2 id="一-双指针"><a href="#一-双指针" class="headerlink" title="一.双指针"></a>一.双指针</h2><p>快慢指针简介：</p>
<p>对撞指针简介：对撞指针实际上是一种放缩思想。</p>
 <span id="more"></span>

<p><strong>开区间与闭区间</strong>：</p>
<ul>
<li><p>性质：</p>
<ul>
<li>如果为双闭区间[left….right]， 那么元素个数为right - left + 1</li>
<li>如果为一闭一开区间[left…right)，那么元素个数为right - left</li>
<li>[)和(]的区别在于前者包含了left但不包含right，后者相反。</li>
</ul>
</li>
<li><p>意义：可以帮助设计代码。</p>
</li>
<li><p>示例（LeetCode颜色分类）：在方法i中，我们使用三个指针划分数组，zero，one，i，其中i也是遍历指针。[0，zero)保存0；[zero，one)保存1；(two，n]保存2；开闭区间告诉我们代码nums[0]的值为0，nums[zero]的值为1，nums[one]和nums[two]为待鉴定的元素。</p>
</li>
</ul>
<p><strong>循环不变量</strong>：实际在循环中值会一直变化，但是由于佳加入了维护的代码，使之在逻辑上保持定义不变的量</p>
<ul>
<li><p>性质：</p>
<ul>
<li>初始化：循环的第一次迭代之前，它为真。</li>
<li>保持：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。</li>
<li>终止：在循环终止时，不变式为我们提供一个有用的性质，该性质有助于证明算法是正确的。</li>
</ul>
</li>
<li><p>意义：可以清楚算法的细节，例如帮助设计代码的初始化的时候变量的取值，及其循环过程中各个步奏的先后顺序。</p>
</li>
<li><p>举例:</p>
<ul>
<li>选择排序：区间nums[0…i）里保存了数组里最小的i个元素，且i表示第i个最小元素</li>
<li>插入排序：区间nums[0…i）里保存了输入数组里的前i个元素(字面上)，并且他们是暂时有序的。</li>
<li>综合运用，LeetCode颜色分类：类似三路快速排序，见附录。</li>
</ul>
</li>
<li><p>循环不变量和双指针的关系：</p>
<ul>
<li><p>移动0：<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypratmp2776.png" alt="tmp2776" style="zoom: 50%;" /></p>
<p>设两个指针i和j，不变量定义为区间[0…i)内一定是不为0的元素，[i…j)内是为0的元素，[j…hi]是待定的元素。（快慢指针）</p>
<p>也可以设为，不变量定义为区间[0…i)内一定是不为0的元素，[i…j]是待定的元素，(j…hi]是为0元素。（碰撞指针）</p>
</li>
<li><p>移除元素：<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypraimage-20220621110230292.png" alt="image-20220621110230292" style="zoom: 50%;" /></p>
<p>设两个指针i和j，不变量定义为区间[0…i)内一定是不为2的元素，[i…j)内是为2的元素，[j…hi]是待定的元素。（快慢指针）</p>
<p>碰撞指针同理。</p>
</li>
<li><p>删除排序数组中的重复项：<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypratmpA86F.png" alt="tmpA86F" style="zoom: 50%;" /></p>
<p>设两个指针i和j，不变量定义为区间[0…i)内一定是不重复的元素，[i…j)内是与前面重复的元素，[j…hi]是待定的元素。（快慢指针）</p>
</li>
</ul>
</li>
<li><p>双指针问题还需要注意保持前面的指针比后面的指针大</p>
<p>i &gt;&#x3D; one &gt;&#x3D; zero &gt;&#x3D; 0</p>
</li>
</ul>
<p><a href="https://leetcode.cn/problems/sort-colors/">75. 颜色分类</a> 双指针（第二种写法比较清晰）<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20240118152958445.png" alt="image-20240118152958445" style="zoom:50%;" /><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20240110104639130.png" alt="image-20240110104639130" style="zoom:50%;" /></p>
<p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a> 双指针</p>
<p><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a> 双指针</p>
<p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/">80. 删除有序数组中的重复项 II</a> 双指针</p>
<p><a href="https://leetcode.cn/problems/max-consecutive-ones/">485. 最大连续 1 的个数</a> 双指针</p>
<p><a href="https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/">581. 最短无序连续子数组 </a> 双指针</p>
<p><a href="https://leetcode.cn/problems/find-k-closest-elements/">658. 找到 K 个最接近的元素</a> 双指针 二分查找</p>
<h2 id="二-nsum问题"><a href="#二-nsum问题" class="headerlink" title="二.nsum问题"></a>二.<strong>nsum问题</strong></h2><p><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></p>
<p><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a> 双指针，排序</p>
<p><a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a> 双指针，排序  nums[j] &#x3D;&#x3D; nums[j+1]是为了避免重复的组合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; four = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;j &lt; length;j++)&#123; <span class="comment">//i+1</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">tar</span> <span class="operator">=</span>(<span class="type">long</span>) target - nums[i] - nums[j];<span class="comment">//long减法</span></span><br><span class="line">                List&lt;List&lt;Integer&gt;&gt; twos = twoSum(nums,j,tar);</span><br><span class="line">                <span class="keyword">for</span>(List&lt;Integer&gt; two:twos)&#123;</span><br><span class="line">                    two.add(nums[i]);</span><br><span class="line">                    two.add(nums[j]);</span><br><span class="line">                    four.add(two);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(j &lt; length - <span class="number">1</span> &amp;&amp; nums[j] == nums[j+<span class="number">1</span>]) j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; length - <span class="number">1</span> &amp;&amp; nums[i] == nums[i+<span class="number">1</span>]) i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> four;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">long</span> target)</span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; two = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> start + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hi</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> nums[lo] + nums[hi];</span><br><span class="line">            <span class="keyword">if</span>(target &gt; sum)&#123;</span><br><span class="line">                <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[lo] == nums[lo + <span class="number">1</span>]) lo++;</span><br><span class="line">                lo++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; sum)&#123;</span><br><span class="line">                <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[hi] == nums[hi - <span class="number">1</span>]) hi--;</span><br><span class="line">                hi--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">                list.add(nums[lo]);</span><br><span class="line">                list.add(nums[hi]);</span><br><span class="line">                two.add(list);</span><br><span class="line">                <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[hi] == nums[hi - <span class="number">1</span>]) hi--;</span><br><span class="line">                hi--;</span><br><span class="line">                <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[lo] == nums[lo + <span class="number">1</span>]) lo++;</span><br><span class="line">                lo++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> two;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II</a> 哈希表</p>
<h2 id="三-前缀和数组"><a href="#三-前缀和数组" class="headerlink" title="三.前缀和数组"></a>三.前缀和数组</h2><p>例子：[1,2,3,4,5] 的前缀和为[0,1,3,6,10,15]</p>
<p>定义：设nums[n]数组的前缀和数组为sum[n+1],那么sum[i]表示为nums[i]前面的数组的和（不包括nums[i]本身），公式表示为sum[i] &#x3D; sum[i-1] + num[i-1]</p>
<p>定理：<br>1.sum[0]一定为0，因为第0个元素(1)是第一个元素，第一个元素之前是没有元素的，所以和为0；<br>2.在nums中第i个元素到第j个元素的和(包括i，j)公式为：nums.between[i,j] &#x3D; sum[j+1] - sum[i]<br>理解：sum[j+1]为包括j的前缀和，sum[i]为不包括i的前缀和，两者相减的差当然包括i和j元素了。</p>
<p>例子：</p>
<p>$\begin{vmatrix}<br>1 &amp; 2 &amp; 3 \<br>4 &amp; 5 &amp; 6 \<br>7 &amp; 8 &amp; 9 \<br>\end{vmatrix}$前缀和&#x3D;&gt;$\begin{vmatrix}<br>0 &amp; 0 &amp; 0 &amp; 0 \<br>0 &amp; 1 &amp; 3 &amp; 6 \<br>0 &amp; 5 &amp; 12 &amp; 21 \<br>0 &amp; 12 &amp; 27 &amp; 45 \<br>\end{vmatrix}$</p>
<p>定义：同理，sum[i] [j]不包括nums[i] [j]。<br>sum[i] [j] &#x3D; sum[i] [j-1] + sum[i-1] [j] - sum[i-1] [j-1]  + nums[i - 1] [j - 1]</p>
<p>定理：同理，sum[c+1] [d+1]包括nums[c] [d]，sum[a] [b]不包括nums[a] [b],公式其余部分排列组合。<br>nums.between[(c,d),(a,b)] &#x3D; sum[c+1] [d+1] - sum[c + 1] [b] - sum[a] [d+1]+ sum[a] [b]</p>
<p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a> 前缀和 二分查找</p>
<p><a href="https://leetcode.cn/problems/product-of-array-except-self/">238. 除自身以外数组的乘积 </a> 前缀和</p>
<p><a href="https://leetcode.cn/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变</a> 前缀和</p>
<p><a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/">304. 二维区域和检索 - 矩阵不可变</a> 前缀和</p>
<p><a href="https://leetcode.cn/problems/random-pick-with-weight/">528. 按权重随机选择 </a> 前缀和  二分查找</p>
<p><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组 </a> 前缀和 哈希表（这道题与209.很像，但是元素可以是负数，所以前缀和不一定是有序的，所以不能用二分查找）</p>
<h2 id="四-差分数组"><a href="#四-差分数组" class="headerlink" title="四.差分数组"></a>四.差分数组</h2><p>例子：[1,2,3,4,5]的差分数组为[1,1,1,1,1]</p>
<p>定义： diff[i] 表示为 nums[i - 1] 到nums[i]的增量（可能是负的）<br>base：diff[0] &#x3D; nums[0]<br>公式： i &gt; 0; diff[i] &#x3D; nums[i] - nums[i-1]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          </p>
<p>定理：<br>1.nums.between[i,j] + x &#x3D;&gt; diff[i] + x 且 diff[j+1] - x<br>理解：为什么nums[i]到nums[j]都加了x，diff数组只需要改变两个元素？因为diff数组只跟前面的一个元素有关，为什么nums[i]到nums[j]都加了x，那么i，j之间的元素的差值还是不变，但是边界处diff[i]和diff[j+1]就会发生改变。</p>
<p><a href="https://leetcode.cn/problems/car-pooling/">1094. 拼车</a></p>
<p><a href="https://leetcode.cn/problems/corporate-flight-bookings/">1109. 航班预订统计</a></p>
<h2 id="五-归并排序"><a href="#五-归并排序" class="headerlink" title="五.归并排序"></a>五.归并排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] aux;</span><br><span class="line">sort(<span class="type">int</span>[] nums,<span class="type">int</span> lo,<span class="type">int</span> hi)&#123;</span><br><span class="line">    <span class="keyword">if</span>(lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo)/<span class="number">2</span>;</span><br><span class="line">    sort(nums,lo,mid);</span><br><span class="line">    sort(nums,mid+<span class="number">1</span>,hi);</span><br><span class="line">    merge(nums,lo,mid,hi);</span><br><span class="line">&#125;</span><br><span class="line">merge(<span class="type">int</span>[] nums,<span class="type">int</span> lo,<span class="type">int</span> mid,<span class="type">int</span> hi)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> lo;k &lt;= hi;k++)&#123;</span><br><span class="line">        aux[k] = nums[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> lo;k &lt;= hi;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;mid)&#123;</span><br><span class="line">            nums[k] = aux[j++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j&gt;hi)&#123;</span><br><span class="line">            nums[k] = aux[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(aux[i]&lt;aux[j])&#123;</span><br><span class="line">            nums[k] = aux[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            nums[k] = aux[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a> 归并排序</p>
<p>逆序对与归并的关系  ※※※※</p>
<p>例子： [ 4,8,9 ] [ 5,6,7 ]求逆序对</p>
<p>关键思路：像这种有序数组一定要用双指针，才能避免重复计算。</p>
<p>求逆序对：<br>1.初始指针i&#x3D;4,j&#x3D;5<br>2.4不是逆序对，传给8；8是逆序对(8 &gt; 5)，此时有两种选择，一种是给8之后的逆序对都+1；<strong>另一种是遍历直到j &gt; 8时，那么8的逆序对就是j之前的数字，8的次数+x</strong>；很明显第二种可以避免重复计算。<br>3.直到i越界时结束。</p>
<p>归并：由于 [ 4,8,9 ] [ 5,6,7 ]这对数组的逆序对已经被求完了，在传给上一层时为了避免重复计算，因此这对数组应该排成正确顺序[4,5,6,7,8,9]</p>
<p><a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数</a> 归并排序 </p>
<p><a href="https://leetcode.cn/problems/reverse-pairs/">493. 翻转对</a> 归并排序</p>
<h2 id="六-快速排序"><a href="#六-快速排序" class="headerlink" title="六.快速排序"></a>六.快速排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> lo,<span class="type">int</span> hi)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo &gt;= hi) <span class="keyword">return</span>; </span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(nums,lo,hi);</span><br><span class="line">        sort(nums,lo,p-<span class="number">1</span>);</span><br><span class="line">        sort(nums,p+<span class="number">1</span>,hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> lo,<span class="type">int</span> hi)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> lo;</span><br><span class="line">	<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> lo;</span><br><span class="line">	<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> hi+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">    	<span class="keyword">while</span>(nums[++left] &lt; nums[k])&#123;<span class="comment">//从大到小则改变符号即可</span></span><br><span class="line">        	<span class="keyword">if</span>(left == hi) <span class="keyword">break</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">while</span>(nums[--right] &gt; nums[k])&#123;</span><br><span class="line">        	<span class="keyword">if</span>(right == lo) <span class="keyword">break</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">      		swap(nums,k,right);</span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	swap(nums,left,right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意细节：</p>
<p>1.随机化</p>
<p>2.遍历细节（建议直接背）</p>
<p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素 </a>快排+二分</p>
<p><a href="https://leetcode.cn/problems/sort-an-array/">912. 排序数组</a> 快排，归排</p>
<h2 id="七-矩阵"><a href="#七-矩阵" class="headerlink" title="七.矩阵"></a>七.矩阵</h2><p>应用场景：</p>
<ol>
<li>二维数组的数据存到一维数组中，而且可以复原<ul>
<li>设二维数组的大小为$m<em>n$（num2[m] [n]），定义一个长度为$m</em>n$(num1[m*n])的一维数组</li>
<li>他们的对应关系为$num2[x][y] &#x3D; num1[x*m+y],$$num1[z] &#x3D; num2[z&#x2F;m][z%m]$</li>
</ul>
</li>
<li>储存二维数组的索引，设索引为(x,y)<ul>
<li>整数形式：x*m+y</li>
<li>字符串形式：x,y</li>
</ul>
</li>
</ol>
<p><a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a> 矩阵</p>
<p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a> 矩阵</p>
<p><a href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a> 矩阵</p>
<p><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a> 矩阵</p>
<p><a href="https://leetcode.cn/problems/diagonal-traverse/">498. 对角线遍历</a> 矩阵</p>
<h2 id="八-哈希表"><a href="#八-哈希表" class="headerlink" title="八.哈希表"></a>八.哈希表</h2><p><a href="https://leetcode.cn/problems/valid-sudoku/">36. 有效的数独</a> 哈希表</p>
<p><a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a> 哈希表 编码</p>
<p><a href="https://leetcode.cn/problems/majority-element/">169. 多数元素</a> 哈希表 排序</p>
<p>投票算法证明：</p>
<ol>
<li>如果候选人不是maj 则 maj,会和其他非候选人一起反对 会反对候选人,所以候选人一定会下台(maj&#x3D;&#x3D;0时发生换届选举)</li>
<li>如果候选人是maj , 则maj 会支持自己，其他候选人会反对，同样因为maj 票数超过一半，所以maj 一定会成功当选</li>
</ol>
<p><a href="https://leetcode.cn/problems/contains-duplicate-ii/">219. 存在重复元素 II</a> 哈希表 </p>
<p><a href="https://leetcode.cn/problems/intersection-of-two-arrays-ii/">350. 两个数组的交集 II</a> 哈希表</p>
<p><a href="https://leetcode.cn/problems/insert-delete-getrandom-o1/">380. O(1) 时间插入、删除和获取随机元素</a> 哈希表 数组扩容</p>
<p>数组可以实现O(1)获取随机元素,在不要求顺序的情况下还可以实现O(1)插入元素，直接插到尾部。<br>如果知道要删除的元素(查找)，且不需要保证原本顺序的情况下，也可以实现O(1)删除元素。&#x2F;&#x2F;找到删除元素后，与最后一个元素交换位置&#x2F;&#x2F;删除最后一个元素<br>哈希表可以实现O(1)查找元素，但不能获取随机元素。</p>
<p><a href="https://leetcode.cn/problems/random-pick-with-blacklist/">710. 黑名单中的随机数 </a> 哈希表</p>
<p>1.设黑名单的元素个数为m，选择的整数范围为[0，n-1]，因此白名单的个数为n-1-m；我们可以假设0-n-1-m为白名单，后面m个数为黑名单<br>2.这里我们并不会正在去改变数组的结构。而是使用散列表将出现在白名单位置的黑名单跟出现在黑名单位置的白名单进行匹配，实现替换。<br>3.随机取到黑名单时，则通过散列表改为对于的白名单</p>
<h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><p>一.重复元素的开头或结尾元素</p>
<p>在排序数组中，往往会出现重复元素，这些重复元素会经过排序后，聚集在一起，eg：011112有时根据题目要求，我们只需要选择重复元素的一个作为代表即可，此时可以分为两种情况：</p>
<ol>
<li><p>选择重复元素的开头：</p>
<p>从左向右（0后面的1）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(nums[left+<span class="number">1</span>] == nums[left]) left++;</span><br><span class="line">left++;</span><br></pre></td></tr></table></figure>

<p>从右向左（2前面的1）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(nums[right-<span class="number">1</span>] == nums[right]) right--;</span><br><span class="line">right--;</span><br></pre></td></tr></table></figure>
</li>
<li><p>选择重复元素的结尾：</p>
<p>从左向右（2前面的1）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">left++;</span><br><span class="line"><span class="keyword">while</span>(nums[left+<span class="number">1</span>] == nums[left]) left++;</span><br></pre></td></tr></table></figure>

<p>从右向左（0后面的1）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">right--;</span><br><span class="line"><span class="keyword">while</span>(nums[right-<span class="number">1</span>] == nums[right]) right--;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>应用实例可以参考threeSum解决重复元素的问题</p>
<p>二.排序概念</p>
<p><strong>稳定的排序</strong>：</p>
<p>当需要排序的元素相等时，可以保持原来的顺序不变，即排在前面的任然排在前面</p>
<p><a href="https://worktile.com/blog/pingcode-80/amp/">https://worktile.com/blog/pingcode-80/amp/</a></p>
<p>冒泡排序，插入排序，归并排序</p>
<p><strong>比较排序</strong>：基于比较的排序算法是指对于元素的排序必须是建立在元素之间是可以比较的。</p>
<p>选择排序，（交换）冒泡排序，插入排序，归并排序，快速排序</p>
<p><strong>非比较排序</strong>：</p>
<p>三.二维数组储存</p>
<p>关于如何用一个一维整数数组存储所需的二维数组的索引值。<br>加入有一个5行10列的二维数组a，如何储存a[ 2 ][ 3 ]的索引。<br>储存：<br>2*10 + 3 &#x3D; 23<br>使用：<br>23 &#x2F; 10 &#x3D; 2<br>23% 10 &#x3D; 3</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-03-10-Spring框架</title>
    <url>/posts/11c0.html</url>
    <content><![CDATA[<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="Spring-基础"><a href="#Spring-基础" class="headerlink" title="Spring 基础"></a>Spring 基础</h3><h4 id="什么是-Spring"><a href="#什么是-Spring" class="headerlink" title="什么是 Spring?"></a>什么是 Spring?</h4><p>spring是一个开源的轻量级 Java 开发框架，它是很多模块的集合， Spring 支持IOC和AOP可以很方便的整合其它组件，组合成为复杂的应用。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230323162336204.png" alt="image-20230323162336204" style="zoom:80%;" />

 <span id="more"></span>

<p>DATA ACCESS 数据库相关	WEB 跟开发WEB应用相关	 Core Container提供IOC依赖注入功能 	AOP 提供了面向切面的编程实现。</p>
<h5 id="Core-Container"><a href="#Core-Container" class="headerlink" title="Core Container"></a>Core Container</h5><p>Spring 框架的核心模块，也可以说是基础模块，主要提供 IoC 依赖注入功能的支持。Spring 其他所有的功能基本都需要依赖于该模块，我们从上面那张 Spring 各个模块的依赖关系图就可以看出来。</p>
<ul>
<li><p><strong>spring-core</strong> ：Spring 框架基本的核心工具类。</p>
</li>
<li><p><strong>spring-beans</strong> ：提供对 bean 的创建、配置和管理等功能的支持。</p>
</li>
<li><p><strong>spring-expression</strong> ：提供对表达式语言（Spring Expression Language） SpEL 的支持</p>
</li>
</ul>
<h5 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h5><ul>
<li><strong>spring-aspects</strong> ：该模块为与 AspectJ 的集成提供支持。</li>
<li><strong>spring-aop</strong> ：提供了面向切面的编程实现。</li>
</ul>
<h5 id="Data-Access"><a href="#Data-Access" class="headerlink" title="Data Access"></a>Data Access</h5><ul>
<li><strong>spring-jdbc</strong> ：提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。</li>
<li><strong>spring-tx</strong> ：提供对事务的支持。</li>
<li><strong>spring-orm</strong> ： 提供对 Hibernate、JPA 、iBatis 等 ORM 框架的支持。</li>
</ul>
<h5 id="Spring-Web"><a href="#Spring-Web" class="headerlink" title="Spring Web"></a>Spring Web</h5><ul>
<li><strong>spring-web</strong> ：对 Web 功能的实现提供一些最基础的支持。</li>
<li><strong>spring-webmvc</strong> ： 提供对 Spring MVC 的实现。</li>
</ul>
<h5 id="Spring-Test"><a href="#Spring-Test" class="headerlink" title="Spring Test"></a>Spring Test</h5><h4 id="spring-cloud基础组件"><a href="#spring-cloud基础组件" class="headerlink" title="spring cloud基础组件"></a>spring cloud基础组件</h4><p>注册中心：微服务系统中服务注册与发现</p>
<p>负载均衡：主要提供客户侧的软件负载均衡算法。</p>
<p>服务网关：后端服务不直接开放给调用端，而是通过一个API网关根据请求的url，路由到相应的服务，类似nginx反向代理的功能</p>
<p>分布式配置：进行配置管理</p>
<p>断路器：防止一个应用程序多次试图执行一个失败的操作</p>
<h4 id="Spring-Spring-MVC-Spring-Boot-，spring-cloud之间什么关系"><a href="#Spring-Spring-MVC-Spring-Boot-，spring-cloud之间什么关系" class="headerlink" title="Spring,Spring MVC,Spring Boot ，spring cloud之间什么关系?"></a>Spring,Spring MVC,Spring Boot ，spring cloud之间什么关系?</h4><p>spring是一个开源的轻量级 Java 开发框架，它是很多模块的集合， Spring 支持IOC和AOP可以很方便的整合其它组件，组合成为复杂的应用。</p>
<p>Spring MVC 是 Spring 框架 提供的 一款 MVC 框架，可以帮助我们进行更简洁的 Web 层的开发。</p>
<p>传统的基于servlet开发需要实现，而且还要在servlet的xml文件中手动配置uri和服务的映射信。</p>
<p>spring mvc使用DispatcherServlet前端控制器来统一处理请求和响应，程序员只需要关心业务的逻辑。Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。</p>
<p>SpringBoot本质也是Spring</p>
<p>Spring Boot 简化了配置。相比使用spring+springmvc框架进行开发的时候，如果需要引入mybatis框架，那么需要在xml中定义需要的bean对象，这个过程很明显是很麻烦的，springboot中通过引入了starter包实现了自动配置，因此可以可以直接引入mybatis的starter包。</p>
<p>Spring Boot使用了嵌入式Web容器，可以将应用程序打包成一个可执行的JAR文件并直接运行，避免了繁琐的部署过程。使用SSM开发，需要打包成war包然后放到Tomcat容器中才能部署。</p>
<h4 id="Spring-Boot-，spring-cloud的区别"><a href="#Spring-Boot-，spring-cloud的区别" class="headerlink" title="Spring Boot ，spring cloud的区别"></a>Spring Boot ，spring cloud的区别</h4><p>1.概念上，spring boot是building anything ，spring cloud是coordinate anything</p>
<p>2.作用上，Spring Boot 简化了传统MVC的XML配置,实现了自动配置的功能。spring cloud一整套基于Spring Boot的微服务解决方案，它包括注册中心，负载均衡，服务网关，分布式配置，断路器五大组件，通过这些组件实现对springboot开发的各个微服务的整合和治理。</p>
<p>3.关系上，springboot可以独立使用开发项目，而spring cloud不能离开spring boot开发。</p>
<h4 id="SpringBoot的启动流程"><a href="#SpringBoot的启动流程" class="headerlink" title="SpringBoot的启动流程"></a>SpringBoot的启动流程</h4><p>1.在main方法中调用SpringApplication的run方法。</p>
<p>2.IOC容器的执行流程：IOC容器的初始化阶段，bean的初始化。</p>
<h4 id="starter自动配置"><a href="#starter自动配置" class="headerlink" title="starter自动配置?"></a>starter自动配置?</h4><p>spring启动时通过@EnableAutoConfiguration注解在starter包的META-NF&#x2F;spring.factories文件中找到所有对应的配置类，然后将这些配置类中的bean加载到spring容器中。配置类指那些使用@Configuration修饰的类，配置类中通常会在方法上使用@Bean返回配置好的bean对象。</p>
<h4 id="什么是-Spring-Bean？"><a href="#什么是-Spring-Bean？" class="headerlink" title="什么是 Spring Bean？"></a>什么是 Spring Bean？</h4><p>Bean 代指的就是那些被 IoC 容器所管理的对象。</p>
<h4 id="哪些Bean的会被实例化"><a href="#哪些Bean的会被实例化" class="headerlink" title="哪些Bean的会被实例化"></a>哪些Bean的会被实例化</h4><p>@ComponentScan组件扫描，扫描run方法所在类下带有@Component注解的类并为其创建bean。</p>
<p>@Configuration下的@Bean方法（注：@Configuration继承@Component）</p>
<h4 id="Spring-框架中用到了哪些设计模式？"><a href="#Spring-框架中用到了哪些设计模式？" class="headerlink" title="Spring 框架中用到了哪些设计模式？"></a>Spring 框架中用到了哪些设计模式？</h4><p>工厂模式：Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</p>
<p>单例模式：Spring 中的 Bean 默认都是单例的。</p>
<p>模板模式：Spring 中 <code>jdbcTemplate</code>、<code>RedisTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</p>
<p>Spring MVC 中的适配器模式：</p>
<p>HandlerAdapter是适配器期望接口，它的子类才是具体的适配器，专门适配某一类Handler，Handler是适配者。这样的好处是，DispatchServlet获得Handler对象之后直接丢给HandlerAdapter去处理，不需要自己操作handler对象，因为不同handler对象有不同的handle方法。DispatchServlet只需要根据handler对象获取具体的HandlerAdapter对象，然后调用HandlerAdapter.handle(handler)方法就可以了</p>
<p><a href="https://blog.csdn.net/guorui_java/article/details/106584559">https://blog.csdn.net/guorui_java/article/details/106584559</a></p>
<p>代理模式：Spring AOP 功能的实现。</p>
<h3 id="Spring-IoC（重要）"><a href="#Spring-IoC（重要）" class="headerlink" title="Spring IoC（重要）"></a>Spring IoC（重要）</h3><h4 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC"></a>什么是IOC</h4><p>spring IOC包含3个层面的内容</p>
<h5 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h5><p>spring提供了两种容器类型BeanFactory 和 ApplicationContext。， IoC 容器实际上就是个 Map（key（bean的名称），value（对象））,Map 中存放的是各种对象，在spring中称为bean。</p>
<p><strong>BeanFactory和ApplicationContext的区别</strong></p>
<p>Bean创建的主要逻辑和功能都被封装在BeanFactory中，<code>ApplicationContext不仅继承了BeanFactory，而且ApplicationContext内部还维护着BeanFactory的引用</code>，ApplicationContext在BeanFactory基础上对功能进行了扩展</p>
<p>Bean的初始化时机不同，<code>原始BeanFactory是在首次调用getBean时才进行Bean的创建，而ApplicationContext则是配置文件加载</code>，容器一创建就将Bean都实例化并初始化好。</p>
<h5 id="控制反转-IOC-依赖注入-DI"><a href="#控制反转-IOC-依赖注入-DI" class="headerlink" title="控制反转(IOC)&#x2F;依赖注入(DI)"></a>控制反转(IOC)&#x2F;依赖注入(DI)</h5><p>控制反转是一种设计思想或者说是某种模式。这个设计思想就是将原本在程序中手动创建对象的控制权，交由 Spring IOC容器来管理，使得对象之间的耦合度或者说依赖程度降低；</p>
<p>依赖注入是IOC的一种实现方式。一个对象如果需要依赖另一个对象，不需要自己创建，而是由spring容器注入，如果这两个对象都是spring管理的对象，那么这一过程将由spring容器自动完成。</p>
<h4 id="IOC的执行流程"><a href="#IOC的执行流程" class="headerlink" title="IOC的执行流程"></a>IOC的执行流程</h4><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/abde7edc90734009864eee7e12aa986dtplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="img" style="zoom:80%;" />

<h5 id="springIOC的工作流程"><a href="#springIOC的工作流程" class="headerlink" title="springIOC的工作流程"></a>springIOC的工作流程</h5><p>1.IOC容器的初始化阶段</p>
<p>在这个阶段主要是根据程序里面定义的XML或者注解等Bean的声明方式，通过解析和加载后生成BeanDefinition，然后把BeanDefinition保存到IOC容器里面，BeanDefinition中包含bean的定义和基本属性，从而完成IOC容器的初始化。</p>
<p>2.完成bean的实例化-依赖注入-初始化（Bean的生命周期）</p>
<p>通过反射调用类的无参数构造函数来完成对单例bean进行实例化，然后完成bean属性的依赖注入，然后再调用自定义的初始化方法比如@PostConstruct和初始化的前后处理器来进行一些定制化的设置。</p>
<p>3.Bean的使用（Bean的生命周期）</p>
<p>通过@Autowire注解或者BeanFactory.getBean()从容器中获取实例，针对非单例bean的实例化，是在每一次获取bean对象的时候调用bean的初始化方法来完成实例化，而且IOC容器不会管理这些bean。</p>
<p>4.Bean的销毁（Bean的生命周期）</p>
<p>被spring容器管理的bean在销毁时会执行destroy方法。</p>
<h4 id="Spring-Bean的生命周期0"><a href="#Spring-Bean的生命周期0" class="headerlink" title="Spring Bean的生命周期0"></a>Spring Bean的生命周期0</h4><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/72677c123f5e41b3b8498654acac8fe0tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="img"  />

<h5 id="Spring中Bean的实例化和初始化有什么区别"><a href="#Spring中Bean的实例化和初始化有什么区别" class="headerlink" title="Spring中Bean的实例化和初始化有什么区别"></a>Spring中Bean的实例化和初始化有什么区别</h5><p><strong>「实例化」</strong>：实例化是创建类的实例的过程。在Spring中，当一个Bean被定义在配置文件中（或者通过其他方式如注解或Java配置），Spring IoC容器就会实例化这个Bean。实例化通常通过调用类的无参数构造函数来完成。这个步骤产生了一个Bean的实例，但是这个实例的属性尚未被设置。</p>
<p><strong>「初始化」</strong>：初始化是在Bean实例化后、使用前的一个阶段，主要是对Bean进行一些定制化的设置，比如设置属性的值、执行某些方法等。在Spring中，你可以通过实现<code>InitializingBean</code>接口，或者使用<code>@PostConstruct</code>注解，或者在XML配置中定义<code>&lt;bean init-method=&quot;&quot;&gt;</code>，来定义Bean的初始化逻辑。</p>
<ul>
<li><p>BeanPostProcessor也称为Bean后置处理器，它是Spring中定义的接口，在Spring容器的创建过程中（具体为Bean初始化前后）会回调BeanPostProcessor中定义的两个方法。BeanPostProcessor的源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">    Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其中postProcessBeforeInitialization方法会在每一个bean对象的初始化方法调用之前回调；postProcessAfterInitialization方法会在每个bean对象的初始化方法调用之后被回调。</p>
</li>
</ul>
<h5 id="单例-Bean-的线程安全问题了解吗？"><a href="#单例-Bean-的线程安全问题了解吗？" class="headerlink" title="单例 Bean 的线程安全问题了解吗？"></a>单例 Bean 的线程安全问题了解吗？</h5><p>单例 Bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。</p>
<p>解决方法</p>
<ol>
<li>在 Bean 中尽量避免定义可变的成员变量，无状态bean。</li>
<li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li>
</ol>
<h5 id="spring容器中的bean是否允许被回收"><a href="#spring容器中的bean是否允许被回收" class="headerlink" title="spring容器中的bean是否允许被回收"></a>spring容器中的bean是否允许被回收</h5><ul>
<li>singleton 类型的Bean不会被GC，当然，前提是Spring容器处于运行中，如果Spring容器被关闭，那么相关Bean也会被回收；</li>
<li>prototype 类型的Bean会被GC，这种类型的Bean与程序中new关键字生成的对象类似，每次使用都new一个，使用完就回被回收；</li>
</ul>
<h3 id="Spring-AoP（重要）"><a href="#Spring-AoP（重要）" class="headerlink" title="Spring AoP（重要）"></a>Spring AoP（重要）</h3><h4 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h4><p>AOP指面向切面编程。</p>
<p><strong>切</strong> ：指的是横切逻辑，横切逻辑区别于业务逻辑，是对业务逻辑的增强部分代码；而OOP通过继承增加功能的方式，就是纵切逻辑。</p>
<p><strong>面</strong> ：横切逻辑代码往往要添加到很多个方法上，每个方法如同一个点，多个点构成一个面。</p>
<p>通过面向切面编程</p>
<h4 id="AOP-解决了什么问题"><a href="#AOP-解决了什么问题" class="headerlink" title="AOP 解决了什么问题"></a>AOP 解决了什么问题</h4><ul>
<li>弥补OOP的代码重复问题</li>
<li>横切逻辑代码和业务代码解耦合，解决横切逻辑代码重复问题。</li>
<li>典型的应用就是给方法加上日志打印功能。</li>
</ul>
<h4 id="spring如何实现aop"><a href="#spring如何实现aop" class="headerlink" title="spring如何实现aop"></a>spring如何实现aop</h4><p>spring通过动态代理模式实现AOP。如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象；对于没有实现接口的对象，Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理</p>
<p>具体见java代理模式</p>
<h4 id="AOP-切面编程的术语："><a href="#AOP-切面编程的术语：" class="headerlink" title="AOP 切面编程的术语："></a>AOP 切面编程的术语：</h4><p>切入点(Pointcut)：被增强的连接点方法</p>
<p>通知(Advice)：增强的逻辑代码</p>
<p>切面(Aspect)：切入点(Pointcut)+通知(Advice)</p>
<p>代理(Proxy)：向目标对象应用通知之后创建的代理对象</p>
<h4 id="Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别？"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h4><ul>
<li><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，纯java实现，而 AspectJ 基于字节码操作(Bytecode Manipulation)。AspectJ 与Spring AOP不同，它不需要任何设计模式。通过引入了AspectJ编译器（ajc）编译器，将代码的各个方面编织起来</li>
<li>Spring AOP是动态代理， AspectJ是静态代理</li>
<li>AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单</li>
<li>当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多</li>
</ul>
<h4 id="AspectJ-定义的通知类型有哪些？"><a href="#AspectJ-定义的通知类型有哪些？" class="headerlink" title="AspectJ 定义的通知类型有哪些？"></a>AspectJ 定义的通知类型有哪些？</h4><ul>
<li><p>Before（前置通知）：目标对象的方法调用之前触发</p>
</li>
<li><p>After （后置通知）：目标对象的方法调用之后触发</p>
</li>
<li><p>AfterReturning（返回通知）：目标对象的方法调用完成，在返回结果值之后触发</p>
</li>
<li><p>AfterThrowing（异常通知） ：目标对象的方法运行中抛出 &#x2F; 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值</p>
</li>
<li><p><strong>@Around</strong>：环绕通知，围绕着目标方法执行。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法。理论上，可以使用环绕通知实现其他的通知。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;目标方法前&quot;</span>);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         pjp.proceed();<span class="comment">//目标方法执行</span></span><br><span class="line">         System.out.println(<span class="string">&quot;目标方法后&quot;</span>);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">         throwable.printStackTrace();</span><br><span class="line">         System.out.println(<span class="string">&quot;目标方法出现异常&quot;</span>);</span><br><span class="line">     &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;finally中进行增强&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="代理对象"><a href="#代理对象" class="headerlink" title="代理对象"></a>代理对象</h4><p>如果bean上加了AOP注解，那么用户通过@Autowired、@Resource等注解定义bean后，spring执行过程获取的是对应真实实例的代理对象。</p>
<p>使用getBean方法获取的也是代理对象</p>
<h4 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h4><p>事实上，spring创建一个普通的bean并不会使用到三级缓存，循环依赖的处理方式相当于一个扩展点，在创建bean时会收集信息，如果发现有循环依赖就会触发这个扩展点。</p>
<p><strong>什么是循环依赖</strong></p>
<p>A对象依赖B对象，B对象有依赖A对象。</p>
<p>满足A.b.a.b……a &#x3D; A,；A.b.a.b…..b &#x3D; B </p>
<p><strong>什么是三级缓存</strong></p>
<ul>
<li>singletonObjects：第一级缓存，里面存放的都是初始化好的成品Bean。</li>
<li>earlySingletonObjects : 第二级缓存，里面存放的都是半成品的Bean，这两个缓存存的都是Bean对象引用。</li>
<li>singletonFactories ：第三级缓存， 不同于前两个存的是 Bean对象引用，此缓存存的bean 工厂对象，也就存的是 专门创建Bean的一个工厂对象。此缓存用于解决循环依赖</li>
</ul>
<p><strong>如何解决</strong></p>
<p>二级缓存（简化）</p>
<ul>
<li>A引用创建后，提前暴露到半成品缓存中</li>
<li>依赖B，创建B ，B填充属性时发现依赖A， 先从成品缓存查找，没有,再从半成品缓存查找 取到A的早期引用。</li>
<li>B顺利走完创建过程, 将B的早期引用从半成品缓存移动到成品缓存</li>
<li>B创建完成，A获取到B的引用，继续创建。</li>
<li>A创建完成，将A的早期引用从半成品缓存移动到成品缓存</li>
</ul>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230510105735600.png" alt="image-20230510105735600" style="zoom:80%;" />

<p><strong>三级缓存(真正)</strong></p>
<ul>
<li>创建bean过程中发现循环依赖</li>
<li>创建A对象，把A的工厂对象放入三级缓存</li>
<li>给A对象填充属性</li>
<li>发现A的属性是B对象的引用，而此时Spring容器中并没有ClassB对象</li>
<li>所以就会先去创建B，这个时候也会把创建B的工厂对象放入三级缓存</li>
<li>给B的属性填充值，此时就会从三级缓存中把A的工厂对象拿出来并执行，实例化A的对象引用并加入到二级缓存中。把B的三级缓存也删除，加入到二级缓存中</li>
<li>完成B的初始化，并把B对象加入到一级缓存，二级缓存删除</li>
<li>A此时就可以正常的填充属性值了，因为B已经初始化完成</li>
<li>A初始化完成并把A添加到一级缓存中，删除二级缓存</li>
</ul>
<h5 id="为什么使用三级缓存"><a href="#为什么使用三级缓存" class="headerlink" title="为什么使用三级缓存"></a>为什么使用三级缓存</h5><p>当依赖的对象是代理对象时。由于在设置属性的时候就需要把半成品的对象设置进去，此时还没有到初始化阶段，半成品的对象就不能像流程一那样走到动态代理逻辑，这样就会导致成品工厂里的是代理对象，而内部返回的是原始对象。</p>
<p>调用对象工厂的getObject方法 ，执行扩展逻辑，可能返回的代理引用，也可能返回原始引用。</p>
<h5 id="循环依赖失效的场景"><a href="#循环依赖失效的场景" class="headerlink" title="循环依赖失效的场景"></a>循环依赖失效的场景</h5><ol>
<li>prototype 类型的循环依赖。prototype在容器中，调用几次，就被实例化几次，每次得到的都是不同的对象</li>
<li>constructor 注入的循环依赖。构造器注入会在实例化是填充属性，此时三级缓存中还没有对于的工厂对象</li>
</ol>
<p>这些解决不了的场景都可以通过 @Lazy 来解决掉。</p>
<p><a href="https://mp.weixin.qq.com/s/0OD75CzV5uTW69Y9zOEhtA">https://mp.weixin.qq.com/s/0OD75CzV5uTW69Y9zOEhtA</a></p>
<h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><h3 id="什么是SpringMVC"><a href="#什么是SpringMVC" class="headerlink" title="什么是SpringMVC"></a>什么是SpringMVC</h3><p>首先MVC 是一种设计模式，包括模型(Model)、视图(View)、控制器(Controller)，通过将业务逻辑、数据、显示代码分离可以提高项目的开发效率。</p>
<p>Spring MVC 是 Spring 框架 提供的 一款 MVC 框架，可以帮助我们进行更简洁的 Web 层的开发。传统的基于servlet开发需要实现，而且还要在servlet的xml文件中手动配置uri和服务的映射信息，而spring mvc使用DispatcherServlet前端控制器来统一处理请求和响应，程序员只需要关心业务的逻辑。</p>
<p>Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。</p>
<h3 id="SpringMVC常用组件"><a href="#SpringMVC常用组件" class="headerlink" title="SpringMVC常用组件"></a>SpringMVC常用组件</h3><ul>
<li>DispatcherServlet：<strong>前端控制器</strong>，不需要工程师开发，由框架提供</li>
</ul>
<p>作用：<strong>统一处理请求和响应</strong>，整个流程控制的中心，由它调用其它组件处理用户的请求</p>
<ul>
<li>HandlerMapping：<strong>处理器映射器</strong>，不需要工程师开发，由框架提供（requestMapping）</li>
</ul>
<p>作用：根据请求的url、method等信息查找Handler，即控制器方法</p>
<ul>
<li>Handler：<strong>处理器</strong>，需要工程师开发（Controller）</li>
</ul>
<p>作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理</p>
<ul>
<li>HandlerAdapter：<strong>处理器适配器</strong>，不需要工程师开发，由框架提供</li>
</ul>
<p>作用：用于找到处理器方法，并调用处理器方法。通过HandlerAdapter对处理器（控制器方法）进行执行</p>
<ul>
<li>ViewResolver：<strong>视图解析器</strong>，不需要工程师开发，由框架提供</li>
</ul>
<p>作用：进行视图解析，得到相应的视图，例如：ThymeleafView（无前缀）、InternalResourceView（forward）、RedirectView（redirect）</p>
<ul>
<li>View：<strong>视图</strong></li>
</ul>
<p>作用：将模型数据通过页面展示给用户</p>
<h3 id="SpringMVC执行流程"><a href="#SpringMVC执行流程" class="headerlink" title="SpringMVC执行流程"></a>SpringMVC执行流程</h3><p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230323164538682.png" alt="image-20230323164538682"></p>
<p>注：中央处理器的作用就是作为中间部分，方便调用各个部分，所以每个部分处理完后都会返回数据给前端控制器</p>
<p>1.用户发起请求被DispatchServlet所处理</p>
<p>2.DispatchServlet根据请求信息调用HandlerMapping。HandlerMapping根据根据 uri 去匹配查找能处理的 Handler。<strong>（HandlerMapping主要是处理请求和Handler方法的映射关系的，Handler就是Controller控制器）</strong></p>
<p>3.HandlerMapping返回一个能够处理请求的执行链给DispatchServlet，这个链中除了包含Handler对象也包含拦截器。</p>
<p>45.<code>DispatcherServlet</code> 调用 <code>HandlerAdapter</code>适配器执行 <code>Handler</code> 。把数据处理转换成合适的类型然后作为方法参数传入 <strong>（HandlerAdater主要进行Handler方法参数和返回值的处理。）</strong></p>
<p>6.Handler方法执行完后的返回值会被HandlerAdapter转换成ModelAndView类型。</p>
<p>7.返回ModelAndView给DispatchServlet.</p>
<p>8.如果对于的ModelAndView对象不为null，则DispatchServlet把ModelAndView交给 ViewResolver 也就是视图解析器解析。</p>
<p>9.ViewResolver 也就是视图解析器把ModelAndView中的viewName转换成对应的View对象返回给DispatchServlet。<strong>（ViewResolver 主要负责把String类型的viewName转换成对应的View对象）</strong></p>
<p>10.DispatchServlet使用View对象进行页面的展示。</p>
<h3 id="过滤器和拦截器的区别"><a href="#过滤器和拦截器的区别" class="headerlink" title="过滤器和拦截器的区别"></a>过滤器和拦截器的区别</h3><p>1.配置文件不同</p>
<p>过滤器是Servlet规范中定义的，在web.xml配置文件中配置；而拦截器是在spring中定义的，在spring配置文件中配置</p>
<p>2.运行顺序不同</p>
<p>过滤器是在请求进入容器后，但是在请求进入servlet之前执行的；而拦截器是在请求进入servlet之后，但是在执行controller之前执行的。也就是说过滤器会比拦截器先执行</p>
<p>3.使用的资源不同</p>
<p>过滤器只能对request和response进行操作，而拦截器可以对request和response，handler，modelAndView，Exception进行操作，即：拦截器可以获取IOC容器中的各个bean</p>
<p>而过滤器就不行，例如，在拦截器里注入一个service，可以调用业务逻辑。</p>
<p>4.实现不同</p>
<p>拦截器是基于spring aop的，而过滤器是基于函数回调的。</p>
<p>Filter常用于设置字符编码，压缩响应信息等</p>
<p>intercept常用于性能监控</p>
<h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><p><a href="https://www.yuque.com/snailclimb/mf2z3k/vqe4gz#UEo3m">https://www.yuque.com/snailclimb/mf2z3k/vqe4gz#UEo3m</a></p>
<h2 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h2><h3 id="Spring-管理事务的方式有几种？"><a href="#Spring-管理事务的方式有几种？" class="headerlink" title="Spring 管理事务的方式有几种？"></a>Spring 管理事务的方式有几种？</h3><ul>
<li><strong>编程式事务</strong> ： 在代码中硬编码(不推荐使用) : 通过JDBC中的 <code>TransactionTemplate</code>或者 <code>TransactionManager</code> 手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。</li>
<li><strong>声明式事务</strong> ： 在 XML 配置文件中配置或者直接基于注解（推荐使用） : 实际是通过 AOP 实现（基于<code>@Transactional</code> 的全注解方式使用最多）</li>
</ul>
<h3 id="事务的属性"><a href="#事务的属性" class="headerlink" title="事务的属性"></a>事务的属性</h3><ul>
<li>隔离级别</li>
<li>传播行为</li>
<li>回滚规则</li>
<li>是否只读</li>
<li>事务超时</li>
</ul>
<h4 id="Spring-事务中的隔离级别有哪几种"><a href="#Spring-事务中的隔离级别有哪几种" class="headerlink" title="Spring 事务中的隔离级别有哪几种?"></a>Spring 事务中的隔离级别有哪几种?</h4><p><strong><code>ISOLATION_DEFAULT</code><strong>，</strong><code>ISOLATION_READ_UNCOMMITTED</code><strong>，</strong><code>ISOLATION_READ_COMMITTED</code></strong></p>
<p>，**<code>ISOLATION_REPEATABLE_READ</code><strong>，</strong><code>ISOLATION_SERIALIZABLE</code>**</p>
<h4 id="Spring-事务传播行为"><a href="#Spring-事务传播行为" class="headerlink" title="Spring 事务传播行为"></a>Spring 事务传播行为</h4><h5 id="什么是事务的传播行为"><a href="#什么是事务的传播行为" class="headerlink" title="什么是事务的传播行为"></a>什么是事务的传播行为</h5><p>事务的传播行为是针对不同类的方法相互嵌套而制定的运行规则。比如，一个service层的方法调用另一个service层的方法，但是两个方法都开启了事务，所以需要指定这两个嵌套事务的运行规则。</p>
<h5 id="同对象的内部方法互相调用"><a href="#同对象的内部方法互相调用" class="headerlink" title="同对象的内部方法互相调用"></a>同对象的内部方法互相调用</h5><p>当互相调用的方法是属于同一个类时如果是同一个类的方法调用，则回不回滚主要取决于主方法是否有required事务注解，不涉及传播行为。这里的主方法指外部调用的方法，有事务注解说明主方法被代理增强了，同理，如果主方法没有事务增强，主方法调用的其他方法有事务增强，外部调用主方法也不能触发其他方法的事务。</p>
<p>所以事务传播行为生效必须是不同类的方法之间的调用</p>
<h5 id="事务传播行为有几种"><a href="#事务传播行为有几种" class="headerlink" title="事务传播行为有几种"></a>事务传播行为有几种</h5><p>我只记得有7种，具体只记得有required，requires_new，NESTED 因为在7种方法中对于单一的方法，只有这三种才能开启事务。</p>
<p><strong>required</strong>：</p>
<p>在外围方法未开启事务的情况下<code>Propagation.REQUIRED</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。<br>在外围方法开启事务的情况下<code>Propagation.REQUIRED</code>修饰的内部方法会加入到外围方法的事务中，所有<code>Propagation.REQUIRED</code>修饰的内部方法和外围方法均属于同一事务，只要一个方法回滚，整个事务均回滚。</p>
<p><strong>requires_new</strong>：</p>
<p>在外围方法未开启事务的情况下<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</p>
<p>在外围方法开启事务的情况下<code>Propagation.REQUIRES_NEW</code>修饰的内部方法依然会单独开启独立事务，且与外部方法事务也独立，内部方法之间、内部方法和外部方法事务均相互独立，互不干扰。</p>
<p><strong>NESTED</strong>：</p>
<p>在外围方法未开启事务的情况下<code>Propagation.NESTED</code>和<code>Propagation.REQUIRED</code>作用相同，修饰的内部方法都会新开启自己的事务，且开启的事务相互独立，互不干扰。</p>
<p>在外围方法开启事务的情况下<code>Propagation.NESTED</code>修饰的内部方法属于外部事务的子事务，外围主事务回滚，子事务一定回滚，而内部子事务可以单独回滚而不影响外围主事务和其他子事务</p>
<h4 id="事务超时属性"><a href="#事务超时属性" class="headerlink" title="事务超时属性"></a>事务超时属性</h4><p>所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。</p>
<h4 id="事务回滚规则"><a href="#事务回滚规则" class="headerlink" title="事务回滚规则"></a>事务回滚规则</h4><p>默认情况下，事务只有遇到运行期异常（<code>RuntimeException</code> 的子类）时才会回滚，<code>Error</code> 也会导致事务回滚，但是，在遇到编译时异常时不会回滚。也可以自定义异常类型回滚</p>
<h3 id="Transactional-事务注解原理"><a href="#Transactional-事务注解原理" class="headerlink" title="@Transactional 事务注解原理"></a><code>@Transactional</code> 事务注解原理</h3><p><code>@Transactional</code> 的工作机制是基于 AOP 实现的，目标对象实现了接口就是用JDK代理，没有实现接口就使用CGLIB 动态代理。</p>
<p>如果一个类或者一个类中的 public 方法上被标注<code>@Transactional</code> 注解的话，Spring 容器就会在启动的时候为其创建一个代理类，在调用被<code>@Transactional</code> 注解的 public 方法的时候，实际调用的是，<code>TransactionInterceptor</code> 类中的 <code>invoke()</code>方法。这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。</p>
<h3 id="事务失效的场景"><a href="#事务失效的场景" class="headerlink" title="事务失效的场景"></a>事务失效的场景</h3><p>1.数据库引擎不支持事务；2.方法不是 public 的；</p>
<p>3.自身调用问题：自身无事务的方法调用有事务的方法，有事务的方法会失效</p>
<p>4.数据源没有配置事务管理器</p>
<p>5.异常被处理了：当业务方法抛出异常，spring感知到异常的时候，才会做事务回滚的操作</p>
<h2 id="Spring-Spring-boot-常用注解"><a href="#Spring-Spring-boot-常用注解" class="headerlink" title="Spring&amp;Spring boot 常用注解"></a>Spring&amp;Spring boot 常用注解</h2><p><a href="https://javaguide.cn/system-design/framework/spring/spring-common-annotations.html">https://javaguide.cn/system-design/framework/spring/spring-common-annotations.html</a></p>
<p>Web服务开发常用的注解有哪些？</p>
<p>Spring Bean相关：</p>
<ul>
<li>@Autowired:自动导入对象到类中，被注入进的类同样要被Spring容器管理。</li>
<li>@RestController:@RestController注解是@Controller和@ResponseBody的合集，表示这是个控制器bean,并且是将函数的返回值直接填入HTTP响应体。</li>
<li>@Component:通用的注解，可标注任意类为Spring组件。如果一个Bean不知道属于哪个层，可以使用@Component注解标注。</li>
<li>@Repository:对应持久层即Dao层，主要用于数据库相关操作。</li>
<li>@Service:对应服务层，主要涉及一些复杂的逻辑，需要用到Dao层。</li>
<li>@Controller:对应Spring MVC控制层，主要用于接受用户请求并调用Service层返回数据给前端页面。</li>
</ul>
<p>Restful风格相关的：</p>
<ul>
<li><p>处理常见的HTTP请求类型：@GetMapping:GET请求、@PostMapping:POST请求。@PutMapping:PUT请求。@DeleteMapping:DELETE请求。</p>
</li>
<li><p>前后端传值：@PathVariable用于获取路径参数，@RequestParam用于获取查询参数。</p>
</li>
<li><p>@RequestBody:用于读取Request请求(可能是POST,PUT,DELETE,GET请求)的body部分并且Content-Type为application&#x2F;json格式的数据，接收到数据之后会自动将数据绑定到Java对象上去。系统会使用HttpMessageConverter或者自定义的HttpMessageConverter将请求的body中的json字符串转换为java对象。</p>
</li>
</ul>
<p>其他</p>
<ul>
<li><p>@ControllerAdvice：统一异常处理</p>
</li>
<li><p>@PostConstruct：</p>
</li>
</ul>
<p>在spring中注入bean的方式：</p>
<p>@Autowired，@Resource，ApplicationContext.getBean（）</p>
<p>ApplicationContext.getBean（）适用于在先初始的bean中注入后初始的bean，可以通过在先初始的bean中提供一个初始化方法调用ApplicationContext.getBean（）注入bean(调用方法时，spring容器已经创建完成)</p>
<p>@Autowired和@Resource的区别</p>
<p>1.@Autowired默认按byType自动装配，而@Resource默认byName自动装配。<br>2.@Autowired只包含一个参数：required，默认是true，true表示必须注入依赖，如果找不到符合要求的依赖，就会抛出异常。@Resource包含七个参数，其中最重要的两个参数是：name 和 type。<br>3.@Autowired如果要使用byName，需要使用@Qualifier一起配合，用@Qualifier的name属性指定。而@Resource如果指定了name，则用byName自动装配，如果指定了type，则用byType自动装配。（注：@Autowire如果没有配置@Qualifier也会在类型找不到时按名称找）<br>4.@Autowired是spring定义的注解，而@Resource是java定义的注解。这说明@Autowired依赖于spring框架，而@Resource可以支持其他框架。</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230903153012812.png" alt="image-20230903153012812" style="zoom:45%;" /><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230903153021993.png" alt="image-20230903153021993" style="zoom:45%;" /></p>
<h2 id="spring扩展点"><a href="#spring扩展点" class="headerlink" title="spring扩展点"></a>spring扩展点</h2><p><a href="https://zhuanlan.zhihu.com/p/587683725">https://zhuanlan.zhihu.com/p/587683725</a></p>
<p><strong>1.自定义拦截器</strong></p>
<p><strong>2.获取Spring容器对象</strong></p>
<p><strong>3.全局异常处理</strong></p>
<p><strong>4.类型转换器</strong></p>
<p><strong>5.导入配置</strong></p>
<p><strong>6.项目启动时</strong></p>
<p><strong>7.修改BeanDefinition</strong></p>
<p><strong>8.初始化Bean前后</strong></p>
<p><strong>9.初始化方法</strong></p>
<p><strong>10.关闭容器前</strong></p>
<h2 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h2><p>SpringSecurity原理</p>
<p>SpringSecurity的本质就是一个过滤器链，内部包含了提供各种功能的过滤器</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/282b3b76f4f24bd4901391b2be94eec6.png" alt="img"></p>
<p>UsernamePasswordAuthenticationFilter:负责处理我们在登陆页面填写了用户名密码后的登陆请求。基本案例的认证工作主要有它负责</p>
<p>ExceptionTranslationFilter：处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException</p>
<p>FilterSecurityInterceptor：负责权限校验的过滤器</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20211214151515385-16800070196876.png" alt="image-20211214151515385"></p>
<p>Authentication接口: 它的实现类，表示当前访问系统的用户，封装了用户相关信息</p>
<p>AuthenticationManager接口：定义了认证Authentication的方法</p>
<p>UserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息（密码权限）的方法</p>
<p>UserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中</p>
<p>UsernamePasswordAuthenticationFilter实现类：实现了我们最常用的基于用户名和密码的认证逻辑，封装Authentication对象</p>
<p>DaoAuthenticationProvider实现类：负责封装权限信息到Authentication中。调用UserDetailsService接口获取UserDetails对象，这里叫DAO的原因就是因为UserDetails是持久层中的信息是真正的用户密码，然后比较UserDetail和Authentication的密码是否匹配，如果是则把权限信息封装到Authentication中。</p>
<p>1.登录授权的原理</p>
<p>SpringSecurity的本质就是一个过滤器链，内部包含了提供各种功能的过滤器。首先用户输入用户密码后会经过</p>
<p>UsernamePasswordAuthenticationFilter，这个过滤器的作用是对比输入的用户名密码和后端储存的用户名密码是否匹配，如果匹配则把用户对应的权限封装在Authentication对象中，用于后续该用户操作某个接口的权限判断。</p>
<p>它的具体流程是UsernamePasswordAuthenticationFilter会把用户输入的用户名密码封装到Authentication对象中，然后调用AuthenticationManager接口对Authentication对象进行认证，AuthenticationManager接口调用DaoAuthenticationProvider实现类调用UserDetailsService接口，在UserDetailsService接口定义获取资源的用户名密码和权限的方法（例如从数据库中获取，还是从内存中获取）并封装成UserDetail对象返回，这时DaoAuthenticationProvider就拥有了Authentication对象和UserDetail对象，对比这两个对象储存的密码是否匹配，如果不匹配过滤器不会获得Authenication对象，抛出认证异常；如果匹配成功，则把权限信息封装到Authenication对象中并返回给过滤器，过滤器将Authenication对象保存在一个contextHolder中。</p>
<p>不过在实际开发中，一般不会直接使用UsernamePasswordAuthenticationFilter进行登录认证，一个原因是需要扩展登录功能，另一个原因是默认过滤器只有uri为&#x2F;login的才会生效</p>
<p>2.校验权限的原理</p>
<p>授权基本流程</p>
<p>在SpringSecurity中，会使用默认的FilterSecurityInterceptor来进行权限校验。</p>
<p>而且SpringSecurity还提供了PreAuthorize注解，用来控制一个接口是否能够被调用的</p>
<p>在PreAuthorize中可以传入一个自定义方法，方法的参数是接口的权限值，方法的返回值是一个Boolean值，可以用来判断是否具有权限。</p>
<p>然后在自定义方法中需要定义比对用户拥有的权限和资源所需的权限的逻辑</p>
<p>用户拥有的权限可以从SecurityContextHolder中的Authentication获取。</p>
<p>资源所需的权限会作为自定义方法的参数传入。</p>
<p>然后对比这两个权限，如果成功则返回true，对比失败则返回false，会抛出授权异常。</p>
<p>2.RBAC模型</p>
<p>RBAC 即基于角色的权限访问控制（Role-Based Access Control）。简单地说：一个用户可以拥有若干角色，每一个角色又可以被分配若干权限，这样就构造成“用户-角色-权限” 的授权模型。在这种模型中，用户与角色、角色与权限之间构成了多对多的关系。所以在数据库中需要5张表来储存用户权限信息。</p>
<p>在 RBAC 中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。就能简化权限的管理。</p>
<p>而且RBAC模型比较切合实际业务需求，一个用户拥有某些权限并不是因为它是谁，而是他担任了什么角色，这个角色具有哪些权限。也方便管理，例如用户的角色发生改变，或者用户新增了某些角色。</p>
<h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><h3 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{} 和 ${} 的区别是什么？"></a>#{} 和 ${} 的区别是什么？</h3><ul>
<li><p>MyBatis获取参数值的两种方式：${}和#{}  </p>
</li>
<li><p>${}的本质就是字符串拼接，#{}的本质就是占位符赋值  </p>
</li>
<li><p>${}使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号；但是#{}使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单引号</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByUsername&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">	select * from t_user where username = #&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByUsername&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span>  </span><br><span class="line">	select * from t_user where username = &#x27;$&#123;username&#125;&#x27;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="xml-映射文件中，除了常见的-select、insert、update、delete-标签之外，还有哪些标签？"><a href="#xml-映射文件中，除了常见的-select、insert、update、delete-标签之外，还有哪些标签？" class="headerlink" title="xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签？"></a>xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签？</h3><ul>
<li><p>标识实现方法的id标签，指定返回值类型的resultMap</p>
</li>
<li><p>实现自定义映射的resultMap标签，用于多表连接的association标签</p>
</li>
<li><p>实现动态sql的&lt; if &gt;,&lt; where &gt;,&lt; foreach &gt;标签</p>
</li>
</ul>
<h3 id="Dao-接口里的方法，参数不同时，方法能重载吗？"><a href="#Dao-接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="Dao 接口里的方法，参数不同时，方法能重载吗？"></a>Dao 接口里的方法，参数不同时，方法能重载吗？</h3><p>在使用MyBatis最为持久层框架时，DAO接口其实就是Mapper接口。Mapper接口中的方法由Mapper.xml文件实现。</p>
<p>Mybatis 的 Dao 接口可以有多个重载方法，但是多个重载方法对应的映射必须只有一个，否则启动会报错。利用动态sql，实现方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person <span class="title function_">queryById</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">Person <span class="title function_">queryById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line">Person <span class="title function_">queryById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id, <span class="meta">@Param(&quot;name&quot;)</span> String name)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;PersonMap&quot;</span>&gt;</span></span><br><span class="line">    select</span><br><span class="line">      id, name, age, address</span><br><span class="line">    from person</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id != null&quot;</span>&gt;</span></span><br><span class="line">            id = #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            name = #&#123;name&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    limit 1</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="MyBatis-动态-sql-是做什么的？都有哪些动态-sql？"><a href="#MyBatis-动态-sql-是做什么的？都有哪些动态-sql？" class="headerlink" title="MyBatis 动态 sql 是做什么的？都有哪些动态 sql？"></a>MyBatis 动态 sql 是做什么的？都有哪些动态 sql？</h3><p>MyBatis 动态 sql 可以让我们在 xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能。</p>
<p>&lt; where &gt;相当于sql语句中的where，与if搭配使用，用if选择过滤的条件</p>
<p>&lt; foreach &gt;当传入的参数是集合时，可以对集合中的元素遍历，一般用于批量添加和删除</p>
<h3 id="自定义映射resultMap"><a href="#自定义映射resultMap" class="headerlink" title="自定义映射resultMap"></a>自定义映射resultMap</h3><p>resultMap：若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射，作为一种临时实体类。</p>
<h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><h3 id="BIO-NIO-AIO的区别"><a href="#BIO-NIO-AIO的区别" class="headerlink" title="BIO,NIO,AIO的区别"></a>BIO,NIO,AIO的区别</h3><h4 id="1-什么是IO"><a href="#1-什么是IO" class="headerlink" title="1.什么是IO"></a>1.什么是IO</h4><p>IO指计算机系统与外部设备之间通信的过程，在平常开发中接触最多的就是磁盘IO（读写文件）和网络IO（网络请求和响应）。</p>
<p>因为在一个进程中用户空间和内核空间是不同的，应用程序对操作系统的内核发起IO调用（系统调用），操作系统负责的内核执行具体的IO操作，然后内核将数据从内核空间拷贝到用户空间。</p>
<h4 id="2-JAVA中常见的3种IO模型"><a href="#2-JAVA中常见的3种IO模型" class="headerlink" title="2.JAVA中常见的3种IO模型"></a>2.JAVA中常见的3种IO模型</h4><p>BIO：同步阻塞IO模型中，在进行I&#x2F;O操作时，会一直阻塞（线程挂起），直到内核把数据拷贝到用户空间后才能进行下一步操作。基于Stream流的IO基本都属于BIO。</p>
<p>NIO：同步非阻塞I&#x2F;O，在进行I&#x2F;O操作时，不会阻塞（线程运行），主线程一直在执行操作，对于select操作来说，线程要么在轮询判断哪个客户端就绪，要么就在执行IO操作（内核把数据拷贝到用户空间）。</p>
<p>Java的NIO一般是通过多路复用技术实现的。多路复用指的是一种实现同时监控多个文件描述符（包括socket，文件和标准输入输出等）的技术，直白一点就是一次系统调用，我就能得到多个客户端是否有读写事件，多路（多个客户端）复用（复用一次系统调用）。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20231106203143316.png" alt="image-20231106203143316" style="zoom: 80%;" />

<p>linux中实现的多路复用技术包括select，poll，epoll。</p>
<p>select，poll：使用轮询的方式来查询文件描述符上是否有事件发生，select最大支持1024个文件描述符，而poll则使用链表来存储文件描述符，没有数量限制。</p>
<p>缺点：select和poll每次都需要拷贝所有的文件描述符，内核需要遍历文件描述符才能发现哪些客户端发生了读写事件。</p>
<p>epoll：</p>
<p>epoll中使用红黑树和链来储存文件描述符，红黑树用来储存所有被监听的文件描述符，链表用来储存所有事件就绪的文件描述符。使用红黑树是为了方便进行增删查改。</p>
<p>当内核监听到有就绪事件时就会将就绪事件从红黑树迁移一份到就绪事件链表中，用户直接就可以执行就绪事件链表中的IO操作。</p>
<p>AIO:AIO也就是NIO2。它是异步非阻塞的IO模型。异步IO是基于事件和回调机制实现的，在进行I&#x2F;O操作时，不需要等待操作完成，就可继续进行其他操作，当操作完成后会自动回调通知</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230825203754885.png" alt="image-20230825203754885" style="zoom: 33%;" /><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230825203818500.png" alt="image-20230825203818500" style="zoom:33%;" /><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230825203846479.png" alt="image-20230825203846479" style="zoom: 50%;" /><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230825204945709.png" alt="image-20230825204945709" style="zoom:50%;" /></p>
<p>多路复用：select，poll，epoll</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIOServer</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9998</span>, <span class="number">20</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;server begin&quot;</span>);</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// 阻塞1</span></span><br><span class="line">			<span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> server.accept();</span><br><span class="line">			System.out.println(<span class="string">&quot;accept client&quot;</span> + client.getPort());</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">				InputStream in;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					in = client.getInputStream();</span><br><span class="line">					<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in));</span><br><span class="line">					<span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// 阻塞2</span></span><br><span class="line">						<span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">						<span class="keyword">if</span> (<span class="literal">null</span> != data) &#123;</span><br><span class="line">							System.out.println(data);</span><br><span class="line">						&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">							client.close();</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(<span class="string">&quot;client break&quot;</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">		LinkedList&lt;SocketChannel&gt; clients = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); <span class="comment">// 服务端开启监听</span></span><br><span class="line">		<span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">		serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9998</span>)); <span class="comment">// 设置操作系统 级别非阻塞 NONBLOCKING!!!</span></span><br><span class="line">		serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// 接受客户端的连接</span></span><br><span class="line">			Thread.sleep(<span class="number">500</span>);</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * accept 调用了内核， 在设置configureBlocking(false) 及非阻塞的情况下 若有客户端连进来，直接返回客户端，</span></span><br><span class="line"><span class="comment">			 * 若无客户端连接，则返回null 设置成NONBLOCKING后，代码不阻塞，线程不挂起，继续往下执行</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">			<span class="keyword">if</span> (client == <span class="literal">null</span>) &#123; <span class="comment">//</span></span><br><span class="line">				System.out.println(<span class="string">&quot;null.....&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">/**</span></span><br><span class="line"><span class="comment">				 * 重点，设置client读写数据时非阻塞</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				client.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">				<span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> client.socket().getPort();</span><br><span class="line">				System.out.println(<span class="string">&quot;client..port: &quot;</span> + port);</span><br><span class="line">				clients.add(client);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">4096</span>); <span class="comment">// 遍历所有客户端，不需要多线程</span></span><br><span class="line">			<span class="keyword">for</span> (SocketChannel c : clients) &#123; <span class="comment">// 不阻塞</span></span><br><span class="line">				<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> c.read(buffer);</span><br><span class="line">				<span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					buffer.flip();</span><br><span class="line">					<span class="type">byte</span>[] aaa = <span class="keyword">new</span> <span class="title class_">byte</span>[buffer.limit()];</span><br><span class="line">					buffer.get(aaa);</span><br><span class="line">					<span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(aaa);</span><br><span class="line">					System.out.println(c.socket().getPort() + <span class="string">&quot; : &quot;</span> + b);</span><br><span class="line">					buffer.clear();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主流网络模型"><a href="#主流网络模型" class="headerlink" title="主流网络模型"></a>主流网络模型</h3><p>对应BIO</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20231106204404474.png" alt="image-20231106204404474" style="zoom:80%;" />

<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20231106205853135.png" alt="image-20231106205853135" style="zoom:80%;" />

<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20231106205907874.png" alt="image-20231106205907874" style="zoom:80%;" />

<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20231106205915656.png" alt="image-20231106205915656" style="zoom:80%;" />

<p>netty和redis不考虑线程池的引入，因此可以理解为只有single-reactor单线程模型和multi-reactor多线程模型。</p>
<p>为了解决上诉问题，<strong>Java1.4中引入了Nl0,一种同步非阻塞的I&#x2F;O模型。</strong></p>
<p>NIO的网络通信中的特点在于，<strong>客户端不再使用流这种传统的IO方式进行，传统的流的这种形式都会基于InputStream或者OutPutStream来进行输入和输出。但是在NIO当中，是使用的是管道的这种形式。</strong></p>
<p><strong>作为Selector来讲，能帮我们解决的问题是这样的，监控个客户端的channel这是一种主动式的监控，如果是客户端发短信进行通信的时候，是否能进行正常的通讯（1.正常的鉴别原因，没有阻塞。）监控过程当中有正常的读写，且无阻塞，就会给他分配线程。当其中某一个客户端channel阻塞了之后，会被Selector监控到，就会把分配给他的后台线程解放出来，给到其他的Channel，这跟传统的网络通通信有一个本质的区别，后台的线程当中可能同时给多个Channel使用。这就是NIO版的网络通信，解决客户端阻塞导致后台资源闲置的方式。</strong>基于NIO网络通信技术，在客户端和后台服务体系中引入Channel和Selector之后，后台线程的阻塞问题得到了解决。</p>
<p><strong>补充：</strong></p>
<p><strong>关于同步和异步</strong></p>
<p><strong>同步和异步其实指的是，请求发起方对消息结果的获取是主动发起的，还是等被动通知的。</strong>如果是请求方主动发起的，一直在等待应答结果（同步阻塞），或者可以先去处理其他的事情，但要不断轮询查看发起的请求是否有应答结果（同步非阻塞 ）因为不管如何都要发起方主动获取消息结果，所以形式上还是同步操作。如果是由服务方通知的，也就是请求方发出请求后，要么在一直等待通知（异步阻塞），要么就先去干自己的事了（异步非阻塞），当事情处理完成之后，服务方会主动通知请求方，它的请求已经完成，这就是异步。异步通知的方式一般是通过状态改变，消息通知，或者回调函数来完成，大多数时候采用的都是回调函数。</p>
<p><strong>关于阻塞和非阻塞</strong></p>
<p>就是我们调用了一个函数之后，在等待这个函数返回结果之前，当前的线程是处于挂起状态，还是运行状态.如果是挂起状态，就意味着当前线程什么都不能干，就等着获取结果，这就叫<strong>同步阻塞</strong>，如果仍然是运行状态，就意味当前线程是可以的继续处理其他任务，但要时不时的去看下是否有结果了，这就是同步非阻塞。</p>
<p>Future 类通过 get() 方法阻塞等待获取异步执行的运行结果，性能比较差。</p>
<p>JDK1.8 中，Java 提供了 CompletableFuture 类，它是基于异步函数式编程。相对阻塞式等待返回结果，CompletableFuture 可以通过回调的方式来处理计算结果，实现了异步非阻塞，性能更优。</p>
<h5 id="netty是同步的还是异步的？"><a href="#netty是同步的还是异步的？" class="headerlink" title="netty是同步的还是异步的？"></a>netty是同步的还是异步的？</h5><p><code>Netty</code> 是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络 <code>IO</code> 程序。</p>
<p>Netty是虽然是基于java.nio.*的（同步非阻塞），但是在Reactor模式下用多线程实现了”异步”的效果。</p>
<p><strong>同步是针对NIO的select线程的</strong>。当有准备好的IO事件时，马上就处理，处理过程是同步的。</p>
<p><strong>异步是针对Netty使用者的</strong>。当调用bind、write或connect时，不是马上拿到结果，而是返回Future，等到NIO完成操作后再通过回调通知。</p>
<p>channel的处理器中会有一个read（）方法把读取到的键值对放入到一个类似map的容器中，然后使</p>
<p>由于read和write，</p>
<p>为了能够在异步操作下顺利拿到值，需要在客户端自己实现同步获取消息的机制</p>
<p>一.通过<code>future</code>来实现，用<code>future</code>的方法<code>get</code>阻塞拿值，但是使用future会导致Event Loop阻塞导致效率下降。</p>
<p>二.通过CompletableFuture 来实现，CompletableFuture可以通过异步编程的方式，把阻塞等待返回Response的过程交给异步线程处理，解放Event Loop线程继续执行流程代码，在业务流程中真正需要用到Response再同步等待异步线程执行结果。</p>
<h3 id="Netty核心组件"><a href="#Netty核心组件" class="headerlink" title="Netty核心组件"></a>Netty核心组件</h3><p><a href="https://www.yuque.com/snailclimb/mf2z3k/wlr1b0#zlra8">https://www.yuque.com/snailclimb/mf2z3k/wlr1b0#zlra8</a></p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230825204043005.png" alt="image-20230825204043005" style="zoom: 50%;" />

<h4 id="Bytebuf（字节容器）"><a href="#Bytebuf（字节容器）" class="headerlink" title="Bytebuf（字节容器）"></a>Bytebuf（字节容器）</h4><p>网络通信最终都是通过字节流进行传输的。ByteBuf就是Netty提供的一个字节容器，其内部是一个字节数组。当我们通过Netty传输数据的时候，就是通过ByteBuf进行的。</p>
<h4 id="Bootstrap和ServerBootstrap（启动引导类）"><a href="#Bootstrap和ServerBootstrap（启动引导类）" class="headerlink" title="Bootstrap和ServerBootstrap（启动引导类）"></a>Bootstrap和ServerBootstrap（启动引导类）</h4><p>1.客户端创建客户端启动引导类Bootstrap，通过Bootstrap对象指定一个线程模型EventLoopGroup，然后调用connect指定ip和端口建立连接。<br>2.服务端创建服务端启动引导类Bootstrap，通过Bootstrap对象指定两个线程模型EventLoopGroup，一个用于接收连接，一个用于具体的IO处理，然后调用bind指定端口。<br><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230903171637722.png" alt="image-20230903171637722" style="zoom: 67%;" /><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230903171657800.png" alt="image-20230903171657800" style="zoom:67%;" /></p>
<h4 id="Channel（网络操作抽象类）"><a href="#Channel（网络操作抽象类）" class="headerlink" title="Channel（网络操作抽象类）"></a>Channel（网络操作抽象类）</h4><p>Channel接口是Netty对网络操作抽象类。通过Channel我们可以进行I&#x2F;O操作，channel中传输数据的单位是Bytebu。一旦客户端成功连接服务端，就会新建一个Channel绑定这对连接。<br>比较常用的Channel接口实现类是：NioServerSocketChannel（服务端）JavaNioSocketChannel（客户端）这两个Channel可以和BIO编程模型中的ServerSocket以及Socket两个慨念对应上。</p>
<h4 id="EventLoopGroup和EvenLoop（事件循环）"><a href="#EventLoopGroup和EvenLoop（事件循环）" class="headerlink" title="EventLoopGroup和EvenLoop（事件循环）"></a>EventLoopGroup和EvenLoop（事件循环）</h4><p>MainReactorGroup和SubReactorGroup。</p>
<p>EventLoop的主要作用实际就是责监听网络事件并调用事件处理器进行相关I&#x2F;O操作（读写）的处理。</p>
<ul>
<li>EventLoopGroup 负责分配 EventLoop 到新创建的 Channel</li>
<li>异步实现只用了很少 EventLoop，这几个 EventLoop 被所有 Channel 共享</li>
<li>一但 Channel 被指派了一个 EventLoop，在它的整个生命周期过程中，都会用这个 EventLoop</li>
</ul>
<p>EventLoop处理的I&#x2F;O事件都将在它专有的Thread上被处理，即Thread和EventLoop属于1:1的关系，从而保证线程安全。</p>
<ul>
<li>EventLoop 始终由一个线程驱动</li>
<li>一个 EventLoop 可以被指派来服务多个 Channel</li>
<li>一个 Channel 只拥有一个 EventLoop</li>
</ul>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230903171037189.png" alt="image-20230903171037189" style="zoom:80%;" />

<h4 id="ChannelHandler（消息处理器）和ChannelPipeline-ChannelHandler对象链表）"><a href="#ChannelHandler（消息处理器）和ChannelPipeline-ChannelHandler对象链表）" class="headerlink" title="ChannelHandler（消息处理器）和ChannelPipeline(ChannelHandler对象链表）"></a>ChannelHandler（消息处理器）和ChannelPipeline(ChannelHandler对象链表）</h4><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230903171731107.png" alt="image-20230903171731107" style="zoom: 67%;" />

<p>ChannelHandler是消息的具体处理器，主要负责处理客户端&#x2F;服务端接收和发送的数据。<br>当Channel被创建时，它会被自动地分配到它专属的ChannelPipeline。一个Channel包含一个ChannelPipeline.ChannelPipeline为ChannelHandler的链，一个pipeline上可以有多个ChannelHandler.<br>我们可以在ChannelPipeline上通过addLast（）方法添加一个或者多个ChannelHandler(一个数据或者事件可能会被多个Handler处理。当一个ChannelHandler处理完之后就将数据交给下一个ChannelHandler</p>
<h4 id="NioEventLoopGroup默认的构造函数会起多少线程"><a href="#NioEventLoopGroup默认的构造函数会起多少线程" class="headerlink" title="NioEventLoopGroup默认的构造函数会起多少线程?"></a>NioEventLoopGroup默认的构造函数会起多少线程?</h4><p>NioEventLoopGroup默认的构造函数实际会起的线程数为CPU核心数*2.<br>每个NioEventLoopGroup对象内部都会分配一组NioEventLoop,其大小是nThreads,这样就构成了一个线程池，一个NIOEventLoop和一个线程相对应，这和我们上面说的EventloopGroup和EventLoop关系这部分内容相对应。</p>
<h4 id="Reactor线程模型（NioEventLoopGroup）"><a href="#Reactor线程模型（NioEventLoopGroup）" class="headerlink" title="Reactor线程模型（NioEventLoopGroup）"></a>Reactor线程模型（NioEventLoopGroup）</h4><p>预防针：IO模型和IO线程模型是不同的，IO模型是是指BIO，NIO和AIO</p>
<p>Reactor是利用NIO对IO线程进行不同的分工,通过IO多路复用技术就可以不断的监听IO事件，不断的分发dispatch,就像一个反应堆一样，看起来像不断的产生IO事件，因比我们称这种模式为Reactor模型。</p>
<ul>
<li>将监听到就绪的IO事件分发dispatch到各个具体的处理Handler中进行相应的IO事件处理。</li>
</ul>
<p><strong>Reactor线程模型分为单线程模型、多线程模型以及主从多线程模型。</strong></p>
<p>在Netty主要靠NioEventLoopGroup线程池来实现具体的线程模型的。<br>实现服务端的时候，一般会初始化两个线程组：bossGroup（MainReactorGroup），workerGroup（SubReactorGroup）。</p>
<p><strong>在主从多线程模型中：</strong></p>
<p>MainReactorGroup中通常只有一个Reactor,专门负责做最重要的事情，也就是监听连接accept事件。当有连接事件产生时，创建初始化相应的NioSocketChannel(代表一个Socket连接)。然后以负载均衡的方式在SubReactorGroup中选取一个Reactor,注册上去，监听Read事件。</p>
<p>MainReactorGroup中只有一个Reactor的原因是，通常我们服务端程序只会绑定监听一个端口，如果要绑定监听多个端口，就会配置多个Reactor。</p>
<p>SubReactorGroup中有多个Reactor。默认的Reactor的个数为CPU核数*2。SubReactorGroup中的Reactor主要负责监听读写事件，每一个Reactor负责监听一组socket连接（channel）。</p>
<p><strong>单线程模型</strong></p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230903231103099.png" alt="image-20230903231103099" style="zoom: 67%;" />



<p><strong>主从多线程模型</strong></p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230903231252649.png" alt="image-20230903231252649" style="zoom:50%;" /><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230903231257598.png" alt="image-20230903231257598" style="zoom:50%;" /></p>
<p><strong>多线程模型</strong></p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230903231438292.png" alt="image-20230903231438292" style="zoom: 50%;" /><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230903231448289.png" alt="image-20230903231448289" style="zoom:50%;" /></p>
<h4 id="Netty服务端和客户端的启动过程"><a href="#Netty服务端和客户端的启动过程" class="headerlink" title="Netty服务端和客户端的启动过程"></a>Netty服务端和客户端的启动过程</h4><p><a href="https://www.yuque.com/snailclimb/mf2z3k/wlr1b0#2014fda3">https://www.yuque.com/snailclimb/mf2z3k/wlr1b0#2014fda3</a></p>
<p>实际上，服务端与客户端的启动过程相似，服务端需要开两个NioEventLoopGroup，而客户端只有一个；服务端是绑定端口，而客户端是建立连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建两个NioEventLoopGroup对象，bossGroup用于接收连接，workerGroup用于具体的处理</span></span><br><span class="line">EventLoopGroup bossGroup <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">    ServerBootstrap b <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">    <span class="comment">//3.给引导类配置两大线程组，确定了线程模型</span></span><br><span class="line">    b.group(bossGroup,workerGroup)</span><br><span class="line">        <span class="comment">//（非必备）打印日志</span></span><br><span class="line">        .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))</span><br><span class="line">        <span class="comment">//4.通过channel()方法给引导类指定了IO模型为NIO</span></span><br><span class="line">        .channel(NioServerSocketChannel.class)</span><br><span class="line">        .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span>&#123;</span><br><span class="line">                <span class="type">ChannelPipeline</span> <span class="variable">p</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                <span class="comment">//5.通过childHandler()方法添加自定义客户端消息的业务处理逻辑</span></span><br><span class="line">                p.addLast(<span class="keyword">new</span> <span class="title class_">HelloServerHandler</span>());</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">     <span class="comment">//6.绑定端口，调用sync方法阻塞知道绑定完成</span></span><br><span class="line">     ChannelFuture f b.bind(port).sync();</span><br><span class="line">     <span class="comment">//7.阻塞等待直到服务器Channel关闭</span></span><br><span class="line">     f.channel().closeFuture().sync();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">     <span class="comment">//8.优雅关闭相关线程组资源</span></span><br><span class="line">     bossGroup.shutdownGracefully();</span><br><span class="line">     workerGroup.shutdownGracefully();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建一个NioEventLoopGroup对象实例</span></span><br><span class="line">EventLoopGroup group <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();<span class="number">3</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//2.创建客户端启动引导/辅助类：Bootstrap</span></span><br><span class="line">	Bootstrap b <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">	<span class="comment">//3.指定线程组</span></span><br><span class="line">	b.group(group)</span><br><span class="line">	<span class="comment">//4.指定I0模型</span></span><br><span class="line">	.channel(NioSocketChannel.class)</span><br><span class="line">	.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;（）&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">            ChannelPipeline p ch.pipeline（）;</span><br><span class="line">			<span class="comment">//5.这里可以自定义消息的业务处理逻辑</span></span><br><span class="line">			p.addLast(<span class="keyword">new</span> <span class="title class_">HelloclientHandler</span>(message));</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;);</span><br><span class="line">    <span class="comment">//6.尝试建立连接</span></span><br><span class="line">    ChannelFuture f b.connect(host,port).sync();</span><br><span class="line">    <span class="comment">//7.等待连接关闭(阻塞，直到Channel1关闭)</span></span><br><span class="line">    f.channel().closeFuture().sync();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    group.shutdownGracefully();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="什么是TCP粘包-拆包？Netty的解决办法"><a href="#什么是TCP粘包-拆包？Netty的解决办法" class="headerlink" title="什么是TCP粘包&#x2F;拆包？Netty的解决办法"></a>什么是TCP粘包&#x2F;拆包？Netty的解决办法</h4><p>Netty自带的解码器</p>
<ul>
<li>发送端发送数据包的时候，每个数据包之间以换行符作为分隔</li>
<li>自定义分隔符解码器</li>
<li>固定长度解码器，它能够按照指定的长度对消息进行相应的拆包。如果不够指定的长度，则空格补全</li>
</ul>
<h4 id="Netty长连接、心跳机制了解么？"><a href="#Netty长连接、心跳机制了解么？" class="headerlink" title="Netty长连接、心跳机制了解么？"></a>Netty长连接、心跳机制了解么？</h4><p>在TCP保持长连接的过程中，可能会出现断网等网络异常出现，异常发生的时候，client与server之间如果没有交互的话，它们是无法发现对方已经掉线的。为了解决这个问题，我们就需要引入心跳机制。</p>
<p>心跳机制的工作原理是：在client与server之间在一定时间内没有数据交互时，即处于idle状态时，客户端或服务器就会发送一个特殊的数据包给对方，当接收方收到这个数据报文后，也立即发送一个特殊的数据报文，回应发送方，此即一个PING-PONG交互。所以，当某一端收到心跳消息后，就知道了对方仍然在线，这就确保TCP连接的有效性</p>
<p>TCP实际上自带的就有长连接选项，本身是也有心跳包机制，也就是TCP的选项：KEEPALIVE。但是，TCP协议层面的长连接灵活性不够，判断存活的时间过长。所以，一般情况下我们都是在应用层协议上实现自定义心跳机制的，也就是在Netty层面通过编码实现。通过Net地y实现心跳机制的话，核心类是IdleStateHandler。</p>
<h4 id="Netty零拷贝"><a href="#Netty零拷贝" class="headerlink" title="Netty零拷贝"></a>Netty零拷贝</h4><p>所谓的 <code>Zero-copy</code>, 就是在操作数据时, 不需要将数据 buffer 从一个内存区域拷贝到另一个内存区域。在OS层面上的Zero-copy通常指避免在用户态(User-space)与内核态(Kernel-space)之间来回拷贝数据。在Netty层面，零拷贝主要体现在对于数据操作的优化。</p>
<p>Netty中的零拷贝体现在以下几个方面：<br>1.堆外内存，避免M堆内存到堆外内存的数据拷贝。<br>2.使用Netty提供的CompositeByteBuf类可以将多个ByteBuf合并为一个逻辑上的ByteBuf,避免了各个ByteBuf之间的拷贝。<br>3.ByteBuf支持slice操作，因此可以将ByteBuf分解为多个共享同一个存储区域的ByteBuf,避免了内存的拷贝。</p>
]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-03-10-集合类常用函数</title>
    <url>/posts/cb72.html</url>
    <content><![CDATA[<h1 id="集合类常用函数"><a href="#集合类常用函数" class="headerlink" title="集合类常用函数"></a>集合类常用函数</h1><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230331135001067.png" alt="image-20230331135001067" style="zoom:80%;" />

 <span id="more"></span>

<h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><p>boolean <code>contains(Object o)</code>  如果此队列包含指定的元素，则返回 <code>true</code> 。 </p>
<p>boolean <code>offer(E e)</code>  将指定的元素插入到此优先级队列中。 </p>
<p>boolean <code>remove(Object o)</code>  从该队列中删除指定元素的单个实例（如果存在）。 </p>
<p>E <code>peek()</code>  检索但不删除此队列的头，如果此队列为空，则返回 <code>null</code> 。 </p>
<p>E <code>poll()</code>  检索并删除此队列的头，如果此队列为空，则返回 <code>null</code> 。 </p>
<p>int <code>size()</code>  返回此集合中的元素数。 </p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>boolean <code>add(E e)</code>  将指定的元素追加到此列表的末尾</p>
<p>void <code>add(int index, E element)</code> </p>
<p>boolean <code>contains(Object o)</code>  如果此列表包含指定的元素，则返回 <code>true</code> 。</p>
<p>boolean <code>equals(Object o)</code></p>
<p>E <code>get(int index)</code>  返回此列表中指定位置的元素。 </p>
<p>int <code>indexOf(Object o)</code>  返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。</p>
<p>int <code>lastIndexOf(Object o)</code>返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。 </p>
<p>boolean <code>isEmpty()</code> 如果此列表不包含元素，则返回 <code>true</code> 。 </p>
<p>E  <code>remove(int index)</code>  删除该列表中指定位置的元素（可选操作）。 </p>
<p>boolean <code>remove(Object o)</code>  从列表中删除指定元素的第一个出现（如果存在）（可选操作）。 </p>
<p>E <code>set(int index, E element)</code>  用指定的元素（可选操作）替换此列表中指定位置的元素。 </p>
<p>int <code>size()</code>  返回此列表中的元素数。 </p>
<p>void <code>sort(Comparator&lt;? super E&gt; c)</code>  使用随附的 <code>Comparator</code>排序此列表来比较元素。</p>
<p>List&lt; E &gt; <code>subList(int fromIndex,  int toIndex)</code>  返回此列表中指定的 <code>fromIndex</code> （含）和 <code>toIndex</code>之间的视图。</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>继承List，API同List</p>
<h3 id="LinkdedList"><a href="#LinkdedList" class="headerlink" title="LinkdedList"></a>LinkdedList</h3><p>继承 List</p>
<p>boolean <code>offer(E e)</code>  将指定的元素添加为此列表的尾部（最后一个元素）。 </p>
<p>boolean <code>offerFirst(E e)</code>  在此列表的前面插入指定的元素。 </p>
<p>boolean <code>offerLast(E e)</code>  在该列表的末尾插入指定的元素。</p>
<p>E <code>peek()</code>  检索但不删除此列表的头（第一个元素）。 </p>
<p>E <code>peekFirst()</code>  检索但不删除此列表的第一个元素，如果此列表为空，则返回 <code>null</code> 。 </p>
<p>E <code>peekLast()</code>  检索但不删除此列表的最后一个元素，如果此列表为空，则返回 <code>null</code> 。 </p>
<p>E <code>poll()</code>  检索并删除此列表的头（第一个元素）。 </p>
<p>E <code>pollFirst()</code>  检索并删除此列表的第一个元素，如果此列表为空，则返回 <code>null</code> 。</p>
<p>E <code>pollLast()</code>  检索并删除此列表的最后一个元素，如果此列表为空，则返回 <code>null</code> 。 </p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>boolean <code>add(E e)</code>  如果指定的元素不存在，则将其指定的元素添加（可选操作）。 </p>
<p>boolean <code>contains(Object o)</code>  如果此集合包含指定的元素，则返回 <code>true</code> 。</p>
<p>boolean <code>equals(Object o)</code>  将指定的对象与此集合进行比较以实现相等。</p>
<p>boolean <code>isEmpty()</code>  如果此集合不包含元素，则返回 <code>true</code> 。</p>
<p>boolean <code>remove(Object o)</code>  如果存在，则从该集合中删除指定的元素（可选操作）。 </p>
<p>int <code>size()</code>  返回此集合中的元素数（其基数）。 </p>
<p>Iterator&lt; E &gt; <code>iterator()</code>  返回此集合中元素的迭代器。</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>继承Set，API基本相同</p>
<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>继承HashSet，API基本相同</p>
<p>注：在LinkedHashSet中各个元素会使用双链表连接。add默认在队列队尾插入。</p>
<p>注：在LinkedHashSet中并没有直接提供removeFirst的API，要实现删除队头元素，需要下面的技巧</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">firstKey = map.iterator().next();</span><br><span class="line">map.remove(firstKey)</span><br></pre></td></tr></table></figure>

<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>继承Set</p>
<p>E <code>ceiling(E e)</code>  返回此集合中最小元素大于或等于给定元素，如果没有此元素，则返回 <code>null</code> 。</p>
<p>E <code>floor(E e)</code>  返回此集合中最大的元素小于或等于给定元素，如果没有这样的元素，则返回 <code>null</code> 。 </p>
<p>E <code>first()</code>  返回此集合中当前的第一个（最低）元素。 </p>
<p>E <code>last()</code>  返回此集合中当前的最后（最高）元素。</p>
<p>E <code>pollFirst()</code>  检索并删除第一个（最低）元素，或返回 <code>null</code>如果该集合为空。 </p>
<p>E <code>pollLast()</code>  检索并删除最后一个（最高）元素，如果此集合为空，则返回 <code>null</code> 。 </p>
<h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>static &lt; T &gt; int <code>binarySearch(List&lt;?  extends T&gt; list, T key, Comparator&lt;? super T&gt; c)</code>  使用二叉搜索算法搜索指定对象的指定列表。 </p>
<p>static &lt; T &gt; void <code>fill(List&lt;?  super T&gt; list, T obj)</code> 用指定的元素代替指定列表的所有元素。 </p>
<p>static &lt; T &gt; boolean <code>replaceAll(List&lt;T&gt; list, T oldVal,  T newVal)</code>  将列表中一个指定值的所有出现替换为另一个。 </p>
<p>static void <code>reverse(List&lt;?&gt; list)</code>  反转指定列表中元素的顺序。 </p>
<p>static void <code>shuffle(List&lt;?&gt; list)</code>  使用默认的随机源随机排列指定的列表。 </p>
<p>static &lt; T &gt; void <code>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code>  根据指定的比较器引起的顺序对指定的列表进行排序。 </p>
<h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>注：arrays是数组的工具类(int[] Integer[])，并不是集合的工具类</p>
<p>static &lt; T &gt; List&lt; T &gt; <code>asList(T... a)</code>  返回由指定数组支持的固定大小的列表。 </p>
<p>static int <code>binarySearch(int[] a,  int key)</code>  使用二叉搜索算法搜索指定的int数组的指定值。</p>
<p>static &lt; T &gt; int <code>binarySearch(T[] a,  T key, Comparator&lt;? super T&gt; c)</code>  使用二叉搜索算法搜索指定对象的指定数组。</p>
<p>static void <code>fill(int[] a,  int val)</code>  将指定的int值分配给指定的int数组的每个元素。</p>
<p>static void <code>sort(int[] a)</code>  按照数字顺序排列指定的数组。 </p>
<p>static &lt; T &gt; void <code>sort(T[] a,  Comparator&lt;? super T&gt; c)</code>  根据指定的比较器引发的顺序对指定的对象数组进行排序。 </p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>boolean <code>containsKey(Object key)</code>  如果此映射包含指定键的映射，则返回 <code>true</code> 。</p>
<p>boolean <code>containsValue(Object value)</code>  如果此地图将一个或多个键映射到指定的值，则返回 <code>true</code> 。 </p>
<p>Set&lt;Map.Entry&lt;K,V&gt;&gt; <code>entrySet()</code>  返回此地图中包含的映射的<a href="../../java/util/Set.html"><code>Set</code></a>视图。 </p>
<p>V <code>get(Object key)</code>  返回到指定键所映射的值，或 <code>null</code>如果此映射包含该键的映射。 </p>
<p>V <code>getOrDefault(Object key, V defaultValue)</code>  返回到指定键所映射的值，或 <code>defaultValue</code>如果此映射包含该键的映射。 </p>
<p>boolean <code>isEmpty()</code>  如果此地图不包含键值映射，则返回 <code>true</code> 。 </p>
<p>Set&lt; K &gt; <code>isEmpty()</code>  如果此地图不包含键值映射，则返回 <code>true</code> 。 </p>
<p>V <code>put(K key, V value)</code>  将指定的值与该映射中的指定键相关联（可选操作）。 </p>
<p>V <code>putIfAbsent(K key, V value)</code>  如果指定的键尚未与某个值相关联（或映射到 <code>null</code> ）将其与给定值相关联并返回  <code>null</code> ，否则返回当前值。 </p>
<p>V <code>remove(Object key)</code>  如果存在（从可选的操作），从该地图中删除一个键的映射。 </p>
<p>int <code>size()</code>  返回此地图中键值映射的数量。 </p>
<p>Collection&lt; V &gt; <code>values()</code>  返回此地图中包含的值的<a href="../../java/util/Collection.html"><code>Collection</code></a>视图。</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>继承Map，API相同</p>
<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p>继承HashMap，API基本相同</p>
<p>注：在LinkedHashMap中各个元素会使用双链表连接。add默认在队列队尾插入。</p>
<p>注：在LinkedHashMap中并没有直接提供removeFirst的API，要实现删除队头元素，需要下面的技巧</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">firstKey = map.iterator().next();</span><br><span class="line">map.remove(firstKey)</span><br></pre></td></tr></table></figure>

<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>继承Map</p>
<p>K <code>ceilingKey(K key)</code>  返回大于或等于给定键的 <code>null</code>键，如果没有此键，则返回 <code>null</code> 。 </p>
<p>Map.Entry&lt;K,V&gt; <code>ceilingEntry(K key)</code>  返回与大于或等于给定键的最小键相关联的键值映射，如果没有此键，则 <code>null</code> 。</p>
<p>K <code>floorKey(K key)</code>  返回小于或等于给定键的最大键，如果没有这样的键，则返回 <code>null</code> 。 </p>
<p>Map.Entry&lt;K,V&gt; <code>floorEntry(K key)</code>  返回与小于或等于给定键的最大键相关联的键值映射，如果没有此键，则 <code>null</code> 。 </p>
<p>K <code>firstKey()</code>  返回此地图中当前的第一个（最低）键。 </p>
<p>Map.Entry&lt;K,V&gt; <code>firstEntry()</code>  返回与该地图中的最小键相关联的键值映射，如果地图为空，则返回 <code>null</code> 。 </p>
<p>K <code>lastKey()</code>  返回当前在此地图中的最后（最高）键。 </p>
<p>Map.Entry&lt;K,V&gt; <code>lastEntry()</code>  返回与该地图中最大关键字关联的键值映射，如果地图为空，则返回 <code>null</code> 。 </p>
<p>Map.Entry&lt;K,V&gt; <code>pollFirstEntry()</code>  删除并返回与该地图中的最小键相关联的键值映射，如果地图为空，则返回 <code>null</code> 。 </p>
<p>Map.Entry&lt;K,V&gt; <code>pollLastEntry()</code>  删除并返回与该地图中最大密钥相关联的键值映射，如果地图为空，则返回 <code>null</code> 。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-03-12-链表类算法</title>
    <url>/posts/299c.html</url>
    <content><![CDATA[<h1 id="链表类算法"><a href="#链表类算法" class="headerlink" title="链表类算法"></a>链表类算法</h1><h2 id="一-链表基础"><a href="#一-链表基础" class="headerlink" title="一.链表基础"></a>一.链表基础</h2><p>注：事实上，链表题目只要肯多用变量就可以轻松解决</p>
 <span id="more"></span>

<ul>
<li><p>单链表</p>
<p>插入：</p>
<p>删除：</p>
<p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a> 单链表</p>
<p><a href="https://leetcode.cn/problems/rotate-list/">61. 旋转链表</a> 单链表</p>
<p><a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a> 单链表</p>
<p><a href="https://leetcode.cn/problems/partition-list/">86. 分隔链表</a> 单链表dummy 插入</p>
<p><a href="https://leetcode.cn/problems/odd-even-linked-list/">328. 奇偶链表</a> 单链表dummy 插入</p>
<p><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a> 单链表dummy 插入 应用 √</p>
<p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a>  单链表 dummy 删除 快慢指针</p>
<p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a> 单链表 删除 快慢指针</p>
<p>快慢指针(快&#x3D;2*慢)判断链表奇偶长度，快指针最后停在fast.next&#x3D;&#x3D;null为奇数，停在fast&#x3D;&#x3D;null为偶数</p>
</li>
<li><p>双链表</p>
<p>插入：</p>
<p>删除：</p>
</li>
<li><p>循环链表</p>
<p><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a> （这部分放到常用数据结构）</p>
<p>循环链表加虚拟指针的好处，避免null值，不需要维护尾指针。因为链表为空是，dummy结点自己指向自己。</p>
<p>什么时候需要双向循环链表，在无法获取某个结点的前驱结点时删除该结点。</p>
</li>
</ul>
<h2 id="二-虚拟dummy结点"><a href="#二-虚拟dummy结点" class="headerlink" title="二.虚拟dummy结点"></a>二.虚拟dummy结点</h2><p>一般来说，在链表操作需要前驱结点(如：删除，插入)可以使用虚拟dummy结点来统一操作。当然可以自行灵活判断，当你觉得加虚拟dummy结点可以简化操作时，就可以加。</p>
<h2 id="三-链表的for循环方式"><a href="#三-链表的for循环方式" class="headerlink" title="三.链表的for循环方式"></a>三.链表的for循环方式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head;p != <span class="literal">null</span>;p = p.next)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四-链表的高级特性：递归"><a href="#四-链表的高级特性：递归" class="headerlink" title="四.链表的高级特性：递归"></a>四.链表的高级特性：递归</h2><p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表 </a>单链表 递归 √</p>
<p><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a> 单链表 递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//head每组的开头结点，n为剩余的结点个数</span></span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode cur,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> cur;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">newFirst</span> <span class="operator">=</span> reverseBetween(cur.next,n-<span class="number">1</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">post</span> <span class="operator">=</span> cur.next.next;</span><br><span class="line">    cur.next.next = cur;</span><br><span class="line">    cur.next = post;</span><br><span class="line">    <span class="keyword">return</span> newFirst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/flatten-a-multilevel-doubly-linked-list/">430. 扁平化多级双向链表</a> 双链表 递归</p>
<h2 id="五-链表算法"><a href="#五-链表算法" class="headerlink" title="五.链表算法"></a>五.链表算法</h2><ul>
<li><p>环形链表</p>
</li>
<li><p>排序：链表只有一种排序那就是归并排序</p>
<p><a href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a> 单链表 归并排序√</p>
</li>
<li><p>链表+哈希表</p>
<p><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">138. 复制带随机指针的链表</a> 单链表 哈希表</p>
<p><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a> 双向循环链表 哈希表（这部分放到常用数据结构）</p>
</li>
</ul>
<p>LinkedHashSet是链表和哈希集合的结合体。链表不能快速访问链表节点，但是插入元素具有时序；哈希集合中的元素无序，但是可以对元素进行快速的访问和删除。那么，它俩结合起来就兼具了哈希集合和链表的特性，既可以在 O(1) 时间内访问或删除其中的元素，又可以保持插入的时序</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-03-18-二分查找</title>
    <url>/posts/1ca0.html</url>
    <content><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="一-不能排序的数组使用二分查找"><a href="#一-不能排序的数组使用二分查找" class="headerlink" title="一.不能排序的数组使用二分查找"></a>一.不能排序的数组使用二分查找</h2><ol>
<li>对于一个旋转数组我们可以使用二分查找会得出以下规律：<ul>
<li>每一次二分都会把数组分为有序的一半和无序的一半。判断有序的方法是最右元素&gt;&#x3D;最左元素，反之则无序。</li>
<li>先判断左右哪边有序，在根据情况进行二分。nums[right] &lt; nums[mid]]就是判断左边有序的。</li>
<li>显然，在对无序部分进行二分的过程中，最后所查找的元素一定在有序数组部分（极限为数组只有一个元素）</li>
</ul>
</li>
<li>有些数组本身不是有序的，但是其前缀和一定是有序的。</li>
</ol>
 <span id="more"></span>

<p><strong>先判断左右哪边有序，在根据情况进行二分</strong></p>
<p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a> 解旋转数组的关键是，target比mid的小时，不一定是在左边；同理大时。</p>
<p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/">81. 搜索旋转排序数组 II</a> 有重复元素 √</p>
<p><strong>最小值一定在无序的一边</strong></p>
<p><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[mid]&gt;nums[hi])&#123;</span><br><span class="line">    lo = mid + <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    hi = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/">154. 寻找旋转排序数组中的最小值 II </a>有重复元素</p>
<p>当旋转数组中出现重复值时，会出现无法判断左右有序的情况，即nums[mid]&#x3D;&#x3D;nums[left]&amp;&amp;nums[mid]&#x3D;&#x3D;nums[right]。解决重复元素的方法是，让right-1&#x2F;(left+1)，从而改变mid的值</p>
<p><a href="https://leetcode.cn/problems/find-peak-element/">162. 寻找峰值</a> 爬坡法</p>
<p>在比较值时，我们习惯使用a1-a2正数还是负数来判断，但是需要注意如果a的值存在相加溢出就不能使用。</p>
<h2 id="二-二分查找的变形"><a href="#二-二分查找的变形" class="headerlink" title="二.二分查找的变形"></a>二.二分查找的变形</h2><p>事实上，二分查找的形式主要有两种，一种是查找中途就可以得到确切答案的，另一种是只有到最后一刻才能得到答案，思想和排除法差不多。他们的代码区别如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//形式一</span></span><br><span class="line"><span class="keyword">while</span>(lo &lt;= hi)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid] &gt; target) lo = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) hi = mid - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//形式二</span></span><br><span class="line"><span class="keyword">while</span>(lo &lt; hi)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid] &gt; target) lo = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) hi = mid;</span><br><span class="line">    <span class="keyword">else</span> hi = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> right;</span><br></pre></td></tr></table></figure>

<h2 id="三-存在重复值的二分查找"><a href="#三-存在重复值的二分查找" class="headerlink" title="三.存在重复值的二分查找"></a>三.存在重复值的二分查找</h2><p>思考两个问题：找第一个数还是最后一个数(取哪一半)，right可能为哪些数(补丁)</p>
<ol>
<li><p>找到第一个为target的数,如果不存在target返回floor(target)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] nums = &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            right = mid;<span class="comment">//在第一个数还是最后一个数</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//补丁</span></span><br><span class="line">    <span class="type">int</span> ans ;</span><br><span class="line">    <span class="keyword">if</span>(nums[right] &lt;= target) ans = right;</span><br><span class="line">    <span class="keyword">else</span> ans = right - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**总结：使用该模板(不考虑补丁)，如果数组中存在target的重复值，那么right会返回target的左边第一个索引；如果数组中不存在target，那么right会返回&gt;target的第一个数的索引，不需要补丁**</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>找到最后一个target的数，如果不存在target返回celling(target)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//补丁</span></span><br><span class="line">    <span class="type">int</span> ans ;</span><br><span class="line">    <span class="keyword">if</span>(nums[right - <span class="number">1</span>] == target) ans = right - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> ans = right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**总结：使用该模板(不考虑补丁)，无论数组中是否包含target，right都会返回大于target的第一个数。需要补丁，如果数组中不存在大于target的数，那么就会返回最右边的数。**</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>深入理解：</p>
<ul>
<li><p>约定：1. left &#x3D; 0，right &#x3D; nums.length - 1，即left，right一定是要在闭区间内的 </p>
<p>​			2. 统一使用right作为我们要查找的元素。</p>
</li>
<li><p>代码理解：</p>
<ol>
<li>left  &lt; right 与 left &lt;&#x3D; right 的区别：<br>当循环条件变成left &lt; right 时，循环体处理不了left&#x3D;&#x3D;right的情况，因此就需要打补丁，处理结束条件left &#x3D;&#x3D; right</li>
<li>a[mid] &#x3D;&#x3D; target 方法不是return语句的作用：<br>当满足target的条件值很多，且要执行到最后只剩一个元素时，就不能简单的使用return了。这时就需要分情况：1.当target很多时，找到最左边的那个，对应语句为right &#x3D; mid - 1&#x2F;right &#x3D; mid；2.找到最右边的那个，对应语句为left &#x3D; mid +1<br>注：这里有两个坑，一是单纯的加一条语句不一定能达到想要的结果；<strong>二是left&#x3D;mid是不被允许的。</strong></li>
<li>a[mid] &#x3D;&#x3D; target right &#x3D; mid - 1&#x2F;left &#x3D; mid +1的副作用：<br>会影响结束时的结果，详情见上面的版本一和二的代码注释</li>
<li>关于打补丁：打补丁是一种思想，不一定需要。</li>
</ol>
</li>
</ul>
</li>
<li><p>总结：</p>
<ul>
<li>二分查找如果循环不处理left &#x3D;&#x3D; right 一定要加补丁，因为用例复杂时，很难确定right的取值</li>
<li>二分查找的定义：nums[right] &gt;&#x3D; target &gt;&#x3D;nums[left] (有重复值) ；<br>nums[right] &gt; target &gt;&#x3D; nums[left] （无重复值）</li>
</ul>
</li>
</ol>
<p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></p>
<p><a href="https://leetcode.cn/problems/find-the-duplicate-number/">287. 寻找重复数</a></p>
<h2 id="四-找到y-f-x-的最优解"><a href="#四-找到y-f-x-的最优解" class="headerlink" title="四.找到y&#x3D;f(x)的最优解"></a>四.找到y&#x3D;f(x)的最优解</h2><p>1.二分查找的形式不是num[i]形式，而是f(x)形式</p>
<p>定义：f(x)为单调函数，定义域和值域有界，那么可以通过二分查找找到值为y的自变量x为多少。</p>
<p>步骤：</p>
<ul>
<li>给出y&#x3D;f(x)的函数关系，写出相关函数</li>
<li>给出x的取值范围</li>
<li>如果相同的y的值有多个，需要根据条件判断是给出x最小的还是x最大的。</li>
</ul>
<p><strong>画图</strong>：需要根据定义正确分析出定义域和值域，并分析出函数是单调递增还是递减。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数 f 是关于自变量 x 的单调函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数，在 f(x) == target 的约束下求 x 的最值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 问自己：自变量 x 的最小值是多少？</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> ...;</span><br><span class="line">    <span class="comment">// 问自己：自变量 x 的最大值是多少？</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> ... + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (f(mid) == target) &#123;</span><br><span class="line">            <span class="comment">// 问自己：题目是求左边界还是右边界？</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f(mid) &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 问自己：怎么让 f(x) 大一点？</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f(mid) &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 问自己：怎么让 f(x) 小一点？</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/sqrtx/">69. x 的平方根 </a></p>
<p><a href="https://leetcode.cn/problems/split-array-largest-sum/">410. 分割数组的最大值</a></p>
<p><a href="https://leetcode.cn/problems/koko-eating-bananas/">875. 爱吃香蕉的珂珂</a></p>
<p><a href="https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/">1011. 在 D 天内送达包裹的能力</a></p>
<p>2.f(x)的f函数在求解固定的x时比较容易，但需要求解满足y的最小&#x2F;大x，就可使用二分查找，给定某个x。</p>
<p><a href="https://leetcode.cn/problems/fair-distribution-of-cookies/">2305. 公平分发饼干</a> 二分查找 + 回溯</p>
<p>二，三的万法归一：</p>
<ol>
<li>保证值有序，无论是大到小还是小到大</li>
<li>在存在重复值的二分查找中，<strong>只有两种缩小方法</strong>，hi&#x3D;mid（值在左边）和lo&#x3D;mid+1（值在右边）</li>
<li>问自己三个问题，值相等时在哪边，值偏大时在哪边，值偏小时在哪边。</li>
<li><strong>最后的值中我们只返回hi</strong>，至于hi最终哪里需要根据条件判断，必要是加补丁</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-03-20-Redis</title>
    <url>/posts/b44d.html</url>
    <content><![CDATA[<h2 id="一-redis"><a href="#一-redis" class="headerlink" title="一.redis"></a>一.redis</h2><h3 id="redis优点"><a href="#redis优点" class="headerlink" title="redis优点"></a>redis优点</h3><p><strong>1.高性能</strong></p>
<p>Redis 基于内存，内存的访问速度是磁盘的上千倍；</p>
<p>基于 epoll&#x2F;select&#x2F;kqueue 等 I&#x2F;O 多路复用技术，实现高吞吐的网络 I&#x2F;O。</p>
<p>单线程模型，单线程无法利用多核，但是从另一个层面来说则避免了多线程频繁上下文切换，以及同步机制如锁带来的开销。</p>
<p><strong>2.高并发</strong></p>
<p>MySQL这类的数据库的QPS大概都在1w左右(4核8g),但是使用Redis缓存之后很容易达到10w+,甚至最高能达到30w+(就单机Redis的情况，Redis集群的话会更高)。<br>QPS(Query Per Second):服务器每秒可以执行的查询次数；由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。</p>
<p><strong>3.Redis 内置了多种优化过后的数据结构</strong>实现，使用非常方便。</p>
 <span id="more"></span>

<h3 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h3><ul>
<li><p><strong>5 种基础数据结构</strong> ：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</p>
<p>储存对象String和Hash选择哪一个？</p>
<ul>
<li>String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。</li>
<li>String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。</li>
</ul>
<p>使用场景：</p>
<p>Zset：排行榜，Set：数据不能重复，多个数据源交集、并集和差集的场景，例如共同好友。</p>
</li>
<li><p><strong>3 种特殊数据结构</strong> ：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)。</p>
<p>Bitmap：签到表 </p>
<p>Redis中是利用string类型数据结构实现BitMap，因此BitMap可以理解是对string类型的位操作。我们可以把年和月作为bitMap的key，然后保存到一个bitMap中，每次签到就到对应的位上把数字从0变成1，只要对应是1，就表明说明这一天已经签到了，反之则没有签到。</p>
<p>HyperLogLogs：独立访客量，1天内同一个用户多次访问该网站，只记录1次。</p>
</li>
</ul>
<h3 id="过期的数据的删除策略"><a href="#过期的数据的删除策略" class="headerlink" title="过期的数据的删除策略"></a>过期的数据的删除策略</h3><ol>
<li><strong>惰性删除</strong> ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li>
<li><strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li>
</ol>
<p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性&#x2F;懒汉式删除</strong> 。</p>
<p>仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p>
<h3 id="Redis-内存淘汰机制"><a href="#Redis-内存淘汰机制" class="headerlink" title="Redis 内存淘汰机制"></a>Redis 内存淘汰机制</h3><p><strong>volatile-lru</strong>：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。</p>
<p><strong>volatile-random</strong>：从已设置过期时间的数据集中挑选将要过期的数据淘汰。</p>
<p><strong>volatile-lfu</strong>：从已设置过期时间的数据集中挑选最不经常使用的数据淘汰。</p>
<p><strong>volatile-ttl</strong>：从已设置过期时间的数据集中挑选将要过期的数据淘汰。</p>
<p><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key</p>
<p><strong>allkeys-random</strong>:从数据集中任意选择数据淘汰。</p>
<p><strong>allkeys-lfu</strong>:当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。</p>
<h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p><strong>1.一种是数据库和缓存一致性要求比较高的，主要以数据库为主，适合读请求比较多的场景。</strong></p>
<p>旁路缓存模式中需要同时维护数据库和缓存的数据，主要以数据库为主，需要保持比较高的一致性。</p>
<p>读：</p>
<p>1.从cache中读取数据，读取到就直接返回；<br>2.cache中读取不到的话，就从db中读取数据返回；<br>3.再把db中读取到的数据放到cache中。</p>
<p>写：</p>
<p>1.先更新db;<br>2.直接删除cache。</p>
<p>删除缓存还是更新缓存？</p>
<ul>
<li>更新缓存：每次更新数据库都更新缓存，无效写操作较多</li>
<li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存(√)</li>
<li>对服务端资源造成浪费：删除cache更加直接，这是因为cache中存放的一些数据需要服务端经过大量的计算才能得出，会消耗服务端的资源，是一笔不小的开销。如果频繁修改db,就能会导致需要频繁更新cache,而cache中的数据可能都没有被访问到。</li>
</ul>
<p>先操作缓存还是先操作数据库？</p>
<ul>
<li>先删除缓存，再操作数据库</li>
<li>先操作数据库，再删除缓存</li>
<li>应当是先操作数据库，再删除缓存，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上redis中写入的就是旧的数据，造成了数据库和redis的数据不一致。</li>
</ul>
<p><strong>2.一种是一致性要求比较弱的，以缓存为主，适合写请求比较多的场景。</strong></p>
<p>任何数据的增删查改都在缓存中先完成，然后开启一个定时任务，定时的去将缓存中的数据同步到数据库中。</p>
<h3 id="常见并发场景"><a href="#常见并发场景" class="headerlink" title="常见并发场景"></a>常见并发场景</h3><h4 id="缓存穿透："><a href="#缓存穿透：" class="headerlink" title="缓存穿透："></a>缓存穿透：</h4><p>缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求就会穿透了缓存，直击数据库。如果请求比较多时，对数据库造成了巨大的压力。</p>
<p>1.最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p>
<p>2.缓存空对象：简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了。</p>
<p>3.布隆过滤器：使用布隆过滤器判断该数据是否在数据库中。</p>
<h4 id="缓存击穿："><a href="#缓存击穿：" class="headerlink" title="缓存击穿："></a>缓存击穿：</h4><p>缓存击穿中，请求的 key 对应的是热点数据 ，该数据存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期） 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力。</p>
<p>注：这些请求是同时发生的，因为根据缓存的更新策略，一旦有一个请求读取数据库成功就会去更新缓存，其他在它之后的请求就能去缓存查询了，所以同时的话就一起去读取数据库了。</p>
<p>redis实现锁的方法：redis setnx方法，该方法含义是redis中如果没有这个key，则插入成功，返回1，如果有这个key则插入失败，则返回0。一般来说为防止死等，还会加上一个过期时间</p>
<p>redis释放锁的方法：del key</p>
<h5 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h5><p>因为在缓存击穿中，是由于高并发场景下，同时访问一个失效key导致的，所以最简单的解决方法就是给这些请求加锁，保证在多个线程未命中缓存数据时，只有一个线程可以获得锁去数据库查询数据并更新到缓存中，其他获取锁失败的线程，隔一段时间去查询缓存或者尝试获取锁，如果查询成功则不需要获取锁了，但如果获取锁成功还要一下查询缓存，做双重确认，避免无效更新。所以这里的锁只锁住了数据库查询和更新缓存的操作，并没锁住查询缓存的操作，在一定程度下减少了锁的粒度。</p>
<h5 id="逻辑过期（异步操作）"><a href="#逻辑过期（异步操作）" class="headerlink" title="逻辑过期（异步操作）"></a>逻辑过期（异步操作）</h5><p>逻辑过期的基本思想是，不设置过期时间，这样就不会发生key的失效问题。它的策略是这样子的，把过期时间设置在 redis的value中，假设某个请求查询缓存发现逻辑时间过期，那么它会去尝试获取锁，一种情况获取锁成功，就会开启一个新的线程去完成查询数据库更新缓存数据的操作，新线程完成工作后释放锁，然后原线程先返回过期数据；另一种情况是获取锁失败，那么直接返回过期数据。也就是说，缓存的更新操作交由内部线程去异步执行了，在更新操作完成前只能得到过期的数据。</p>
<p>优缺点对比：</p>
<p>互斥锁方案：数据一致，且实现简单；串行执行性能会受影响</p>
<p>逻辑过期方案：数据不保证一致，实现起来麻烦；读取过程中不需要等待，性能好</p>
<h4 id="缓存雪崩："><a href="#缓存雪崩：" class="headerlink" title="缓存雪崩："></a>缓存雪崩：</h4><p>同一时段大量的缓存key同时失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。</p>
<p>设置不同的失效时间比如随机设置缓存的失效时间。</p>
<h4 id="缓存击穿和缓存雪崩的区别："><a href="#缓存击穿和缓存雪崩的区别：" class="headerlink" title="缓存击穿和缓存雪崩的区别："></a>缓存击穿和缓存雪崩的区别：</h4><p>击穿是一个被多次请求的key突然失效了，导致这些请求同时打在数据库中，针对一个key的情况；雪崩是多个key同时失效，多个请求同时在数据库上，针对多个key的情况。</p>
<h4 id="缓存击穿和缓存穿透的区别："><a href="#缓存击穿和缓存穿透的区别：" class="headerlink" title="缓存击穿和缓存穿透的区别："></a>缓存击穿和缓存穿透的区别：</h4><p>缓存穿透的请求的数据不存在于缓存中，也不在数据库中；缓存击穿的请求数据不在缓存中，但存在与数据库中</p>
<h3 id="如何基于redis实现分布式锁"><a href="#如何基于redis实现分布式锁" class="headerlink" title="如何基于redis实现分布式锁"></a>如何基于redis实现分布式锁</h3><h4 id="如何使用setnx实现分布式锁"><a href="#如何使用setnx实现分布式锁" class="headerlink" title="如何使用setnx实现分布式锁"></a><strong>如何使用setnx实现分布式锁</strong></h4><p>通过把锁放在redis中，使用set数据结构储存锁对象可以实现分布式锁。</p>
<p>setnx(<strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists)命令中，如果key值不存在的话，设置key的值并返回1；如果key值存在，则返回0。利用这一互斥特性可以实现加锁功能。一般来说为了避免锁无法被释放，需要给锁设置一个过期时间。</p>
<p>释放锁：直接使用del命令</p>
<h4 id="锁误删情况"><a href="#锁误删情况" class="headerlink" title="锁误删情况"></a><strong>锁误删情况</strong></h4><p>超时释放：持有锁的线程1执行时间过长，导致了它的锁因为超时而被释放了，这时另一个线程2获得锁，然后在线程2运行的过程中，线程1执行完后执行释放锁操作，就会把线程2中的锁误删了，这样就会导致其他线程也能获取锁了。</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><h5 id="获取锁时存入线程标识"><a href="#获取锁时存入线程标识" class="headerlink" title="获取锁时存入线程标识"></a>获取锁时存入线程标识</h5><p>key(lock:name)+value(threadId)</p>
<p>在set在存入锁时，放入当前线程的标识，在删除锁时，从set从取出线程标识判断标识是不是等于当前线程的id值，如果是，则进行删除，如果不是，则不进行删除。</p>
<p>对于取出线程id，判断线程id，删除锁的操作也就是整个释放锁阶段需要使用lua脚本保证原子性，否则也会出现锁误删情况。</p>
<p>这种方法虽然可以解决锁误删问题，但需要合理的设置超时时间，因为超时时间过短，会导致多线程的安全问题；过长又会影响性能。</p>
<h5 id="给锁进行续期"><a href="#给锁进行续期" class="headerlink" title="给锁进行续期"></a>给锁进行续期</h5><p>参考redisson的watchdog机制，可以实现在线程正常运行时，给锁进行续期；在线程崩溃时，超时释放。</p>
<p>当redisson的lock方法没有设置超时时间时，就会使用 Watch Dog 自动续期机制。</p>
<p>自动续约机制如下：开启一个定时任务线程每过10s 就会执行lua脚本实现续期操作，<strong>lua脚本会检查当前锁是否被当前线程持有</strong>，如果是，则延长锁的过期时间设置为30s，相当于给该线程无限续约了。当线程使用完锁后，使用Redis的DEL命令释放锁，并关闭看门狗机制。</p>
<p>watch dog可以避免因为线程异常关闭导致无法释放锁的情况。</p>
<h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><h4 id="redis单线程模型"><a href="#redis单线程模型" class="headerlink" title="redis单线程模型"></a>redis单线程模型</h4><p>对于读写命令来说，Redis 一直是单线程模型。Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）。</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20231204194645494.png" alt="image-20231204194645494" style="zoom: 67%;" /><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20231204200347078.png" alt="image-20231204200347078" style="zoom: 50%;" /></p>
<p>Redis基于Reactor模式开发了自己的网络事件处理器，也就是文件事件处理器。文件事件处理器使用IO多路复用技术，同时监听多个套接字，并为套接字关联不同的事件处理函数。当套接字的可读或者可写事件触发时，就会调用相应的事件处理函数。</p>
<p>文件事件是对套接字操作的抽象，每当一个套接字准备好执行 accept、read、write和 close 等操作时，就会产生一个文件事件。因为 Redis 通常会连接多个套接字，所以多个文件事件有可能并发的出现。尽管多个文件事件可能会并发地出现，但I&#x2F;O多路复用程序总是会将所有产生的套接字都放到同一个队列(也就是后文中描述的<code>aeEventLoop</code>的<code>fired</code>就绪事件表)里边，然后文件事件处理器会以有序、同步、单个套接字的方式处理该队列中的套接字，也就是处理就绪的文件事件。</p>
<p><strong>Redis 为何选择单线程：</strong></p>
<ul>
<li><p>官方：对于一个 DB 来说，CPU 通常不会是瓶颈，因为大多数请求不会是 CPU 密集型的，而是 I&#x2F;O 密集型。具体到 Redis 的话，如果不考虑 RDB&#x2F;AOF 等持久化方案，Redis 是完全的纯内存操作，执行速度是非常快的，因此这部分操作通常不会是性能瓶颈，Redis 真正的性能瓶颈在于网络 I&#x2F;O，也就是客户端和服务端之间的网络传输延迟，因此 Redis 选择了单线程的 I&#x2F;O 多路复用来实现它的核心网络模型。</p>
</li>
<li><p>其他：<strong>避免过多的上下文切换开销，避免同步机制的开销</strong></p>
</li>
</ul>
<h4 id="多线程异步任务"><a href="#多线程异步任务" class="headerlink" title="多线程异步任务"></a>多线程异步任务</h4><p>单线程网络模型是Redis 的核心网络模型，一直到 Redis v6.0 才改造成多线程模式，但这并不意味着整个 Redis 一直都只是单线程。</p>
<p>Redis 在 v4.0 版本的时候就已经引入了的多线程来做一些异步操作，此举主要针对的是那些非常耗时的命令，通过将这些命令的执行进行异步化，避免阻塞单线程的事件循环。</p>
<p>我们知道 Redis 的 <code>DEL</code> 命令是用来删除掉一个或多个 key 储存的值，它是一个阻塞的命令，大多数情况下你要删除的 key 里存的值不会特别多，最多也就几十上百个对象，所以可以很快执行完，但是如果你要删的是一个超大的键值对，里面有几百万个对象，那么这条命令可能会阻塞至少好几秒，又因为事件循环是单线程的，所以会阻塞后面的其他事件，导致吞吐量下降。</p>
<p><code>UNLINK</code> 命令其实就是 <code>DEL</code> 的异步版本，它不会同步删除数据，而只是把 key 从 keyspace 中暂时移除掉，然后将任务添加到一个异步队列，最后由后台线程去删除，不过这里需要考虑一种情况是如果用 <code>UNLINK</code> 去删除一个很小的 key，用异步的方式去做反而开销更大，所以它会先计算一个开销的阀值，只有当这个值大于 64 才会使用异步的方式去删除 key，对于基本的数据类型如 List、Set、Hash 这些，阀值就是其中存储的对象数量。</p>
<h4 id="redis多线程模型"><a href="#redis多线程模型" class="headerlink" title="redis多线程模型"></a>redis多线程模型</h4><p><strong>为什么用多线程</strong></p>
<p>Redis 最初选择单线程网络模型的理由是：CPU 通常不会成为性能瓶颈，瓶颈往往是<strong>内存</strong>和<strong>网络</strong>，因此单线程足够了。那么为什么现在 Redis 又要引入多线程呢？随着互联网的飞速发展，互联网业务系统所要处理的线上流量越来越大，Redis 的单线程模式会导致系统消耗很多 CPU 时间在网络 I&#x2F;O 上从而降低吞吐量。</p>
<h4 id="redis多线程模型与标准多线程网络模型的区别"><a href="#redis多线程模型与标准多线程网络模型的区别" class="headerlink" title="redis多线程模型与标准多线程网络模型的区别"></a>redis多线程模型与标准多线程网络模型的区别</h4><p>通常来说，单 Reactor 模式，引入多线程之后会进化为 Multi-Reactors 模式。区别于单 Reactor 模式，这种模式不再是单线程的事件循环，而是有多个线程（Sub Reactors）各自维护一个独立的事件循环，由 Main Reactor 负责接收新连接并分发给 Sub Reactors 去独立处理，最后 Sub Reactors 回写响应给客户端。</p>
<p>Redis 的多线程网络模型实际上并不是一个标准的 Multi-Reactors 模型，和其他主流的开源网络服务器的模式有所区别，最大的不同就是在标准的 Multi-Reactors模式下，Sub Reactors 会完成 <code>网络读 -&gt; 数据解析 -&gt; 命令执行 -&gt; 网络写</code> 整套流程，Main Reactor 只负责分派任务，而在 Redis 的多线程方案中，I&#x2F;O 线程任务仅仅是通过 socket 读取客户端请求命令并解析，却没有真正去执行命令，所有客户端命令最后还需要回到主线程去执行，因此对多核的利用率并不算高，而且每次主线程都必须在分配完任务之后忙轮询等待所有 I&#x2F;O 线程完成任务之后才能继续执行其他逻辑。</p>
<p>Redis 之所以如此设计它的多线程网络模型，我认为主要的原因是为了保持兼容性，因为以前 Redis 是单线程的，所有的客户端命令都是在单线程的事件循环里执行的，也因此 Redis 里所有的数据结构都是非线程安全的，现在引入多线程，如果按照标准的 Multi-Reactors 模式来实现，则所有内置的数据结构都必须重构成线程安全的，这个工作量无疑是巨大且麻烦的。</p>
<h4 id="redis的并发安全问题"><a href="#redis的并发安全问题" class="headerlink" title="redis的并发安全问题"></a>redis的并发安全问题</h4><p>redis使用单线程模型对键值对进行读写操作，能保证命令的序列化，因此原子操作可以保证数据的一致性。</p>
<p>PS：Redis6.0以前是单线程。这的单线程是说其网络I&#x2F;O和键值对读写是由一个线程完成的。Redis6.0以前是单线程。这的单线程是说其网络I&#x2F;O和键值对读写是由一个线程完成的。</p>
<p>这里我们说的redis安全问题通常是指，一个事务操作操作中包含多个redis命令，出现命令交叉执行的情况。解决方法是将多个操作写在 Lua 脚本中，然后把整个 Lua 脚本作为一个整体执行，在执行的过程中不会被其他命令打断，从而保证了 Lua 脚本中操作的原子性。</p>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>如果不考虑 RDB&#x2F;AOF 等持久化方案，Redis 是完全的纯内存操作，执行速度是非常快的。</p>
<p>持久化也就是将内存中的数据写入到硬盘中。大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了做数据同步（比如 Redis 集群的主从节点通过 RDB 文件同步数据）。</p>
<h4 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a><strong>RDB 持久化</strong></h4><p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。</p>
<ul>
<li>执行save命令：save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。</li>
<li>执行bgsave命令：这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。</li>
<li>Redis停机时</li>
</ul>
<h4 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a><strong>AOF 持久化</strong></h4><p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区<code>server.aof_buf</code> 中，然后再写入到 AOF 文件中（此时还在系统内核缓存区未同步到磁盘），最后再根据持久化方式（ <code>fsync</code>策略）的配置来决定何时将系统内核缓存区的数据同步到硬盘中的。</p>
<p><strong>1.AOF 持久化方式有哪些？</strong></p>
<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ <code>fsync</code>策略），它们分别是：</p>
<ol>
<li><code>appendfsync always</code>：主线程调用 <code>write</code> 执行写操作后，后台线程（ <code>aof_fsync</code> 线程）立即会调用 <code>fsync</code> 函数同步 AOF 文件（刷盘），<code>fsync</code> 完成后线程返回，这样会严重降低 Redis 的性能（<code>write</code> + <code>fsync</code>）。</li>
<li><code>appendfsync everysec</code>：主线程调用 <code>write</code> 执行写操作后立即返回，由后台线程（ <code>aof_fsync</code> 线程）每秒钟调用 <code>fsync</code> 函数（系统调用）同步一次 AOF 文件（<code>write</code>+<code>fsync</code>，<code>fsync</code>间隔为 1 秒）</li>
<li><code>appendfsync no</code>：主线程调用 <code>write</code> 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次（<code>write</code>但不<code>fsync</code>，<code>fsync</code> 的时机由操作系统决定）。</li>
</ol>
<p>可以看出：<strong>这 3 种持久化方式的主要区别在于 <code>fsync</code> 同步 AOF 文件的时机（刷盘）</strong>。</p>
<p>关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志。</p>
<ul>
<li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li>
<li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li>
</ul>
<p><strong>2.AOF 重写</strong></p>
<p>当 AOF 变得太大时，Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。比如AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p>
<p><strong>3.AOF 校验机制</strong></p>
<p>AOF 校验机制是 Redis 在启动时对 AOF 文件进行检查，以判断文件是否完整，是否有损坏或者丢失的数据。这个机制的原理其实非常简单，就是通过使用一种叫做 <strong>校验和（checksum）</strong> 的数字来验证 AOF 文件。这个校验和是通过对整个 AOF 文件内容进行 CRC64 算法计算得出的数字。如果文件内容发生了变化，那么校验和也会随之改变。因此，Redis 在启动时会比较计算出的校验和与文件末尾保存的校验和（计算的时候会把最后一行保存校验和的内容给忽略点），从而判断 AOF 文件是否完整。</p>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p><strong>1、布隆过滤器使用场景</strong></p>
<p>原本有10亿个号码，现在又来了10万个号码，要快速准确判断这10万个号码是否在10亿个号码库中？</p>
<p>解决办法一：将10亿个号码存入数据库中，进行数据库查询，准确性有了，但是速度会比较慢。</p>
<p>解决办法二：将10亿号码放入内存中，比如Redis缓存中，这里我们算一下占用内存大小：10亿*8字节&#x3D;8GB，通过内存查询，准确性和速度都有了，但是大约8gb的内存空间，挺浪费内存空间的。</p>
<p><strong>2、布隆过滤器简介</strong></p>
<p>布隆过滤器：一种数据结构，是由一串很长的二进制向量组成，可以将其看成一个二进制数组。既然是二进制，那么里面存放的不是0，就是1，但是初始默认值都是0。</p>
<p>如下所示：</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/v2-d80d37ab0f0ee768b59b63ccb9c1612e_b.jpg" alt="img"></p>
<p><strong>①、添加数据</strong></p>
<p>介绍概念的时候，我们说可以将布隆过滤器看成一个容器，那么如何向布隆过滤器中添加一个数据呢？</p>
<p>如下图所示：当要向布隆过滤器中添加一个元素key时，我们通过多个<a href="https://www.zhihu.com/search?q=hash%E5%87%BD%E6%95%B0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22149088311%22%7D">hash函数</a>，算出一个值，然后将这个值所在的方格置为1。</p>
<p>比如，下图<a href="https://www.zhihu.com/search?q=hash1(key)=1&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22149088311%22%7D">hash1(key)&#x3D;1</a>，那么在第2个格子将0变为1（数组是从0开始计数的），<a href="https://www.zhihu.com/search?q=hash2(key)=7&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22149088311%22%7D">hash2(key)&#x3D;7</a>，那么将第8个格子置位1，依次类推。</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/v2-505ae4590d4a2f8c8388f2b0454b0a4d_b.jpg" alt="img"></p>
<p><strong>②、判断数据是否存在？</strong></p>
<p>知道了如何向布隆过滤器中添加一个数据，那么新来一个数据，我们如何判断其是否存在于这个布隆过滤器中呢？</p>
<p>很简单，我们只需要将这个新的数据通过上面自定义的几个<a href="https://www.zhihu.com/search?q=%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22149088311%22%7D">哈希函数</a>，分别算出各个值，然后看其对应的地方是否都是1，如果存在一个不是1的情况，那么我们可以说，该新数据一定不存在于这个布隆过滤器中。</p>
<p>反过来说，如果通过哈希函数算出来的值，对应的地方都是1，那么我们能够肯定的得出：这个数据一定存在于这个布隆过滤器中吗？</p>
<p>答案是否定的，因为多个不同的数据通过hash函数算出来的结果是会有重复的，所以会存在某个位置是别的数据通过hash函数置为的1。</p>
<p>我们可以得到一个结论：布隆过滤器可以判断某个数据一定不存在，但是无法判断一定存在。</p>
<p><strong>③、布隆过滤器优缺点</strong></p>
<p>优点：优点很明显，二进制组成的数组，占用内存极少，并且插入和查询速度都足够快。</p>
<p>缺点：随着数据的增加，误判率会增加；还有无法判断数据一定存在；另外还有一个重要缺点，无法删除数据。</p>
<p><strong>3、Redis实现布隆过滤器</strong></p>
<ul>
<li><p>bitmaps 我们知道计算机是以二进制位作为底层存储的基础单位，一个字节等于8位。在Redis中，Bitmaps 提供了一套命令用来操作类似上面字符串中的每一个位。</p>
</li>
<li><p>Redisson Redis 实现布隆过滤器的底层就是通过 bitmap 这种数据结构，至于如何实现，这里就不重复造轮子了，介绍业界比较好用的一个客户端工具——Redisson。</p>
</li>
</ul>
<p>Redisson 是用于在 Java 程序中操作 Redis 的库，利用Redisson 我们可以在程序中轻松地使用 Redis。</p>
<h3 id="redis集群×（了解）"><a href="#redis集群×（了解）" class="headerlink" title="redis集群×（了解）"></a>redis集群×（了解）</h3><h3 id="bigkey"><a href="#bigkey" class="headerlink" title="bigkey"></a>bigkey</h3><h4 id="bigkey的定义"><a href="#bigkey的定义" class="headerlink" title="bigkey的定义"></a>bigkey的定义</h4><p>BigKey通常以Key的大小和Key中成员的数量来综合判定，例如：</p>
<ul>
<li>Key本身的数据量过大：一个String类型的Key，它的值为5 MB</li>
<li>Key中的成员数过多：一个ZSET类型的Key，它的成员数量为10,000个</li>
<li>Key中成员的数据量过大：一个Hash类型的Key，它的成员数量虽然只有1,000个但这些成员的Value（值）总大小为100 MB</li>
</ul>
<h4 id="bigkey的危害"><a href="#bigkey的危害" class="headerlink" title="bigkey的危害"></a>bigkey的危害</h4><p>网络阻塞：</p>
<p>BigKey的内容比较多，会导致带宽使用率被占满</p>
<p>cpu压力：</p>
<p>对BigKey的数据序列化和反序列化会导致CPU的使用率飙升，对元素较多的hash、list、zset等做运算会耗时较旧，使主线程被阻塞</p>
<h4 id="如何发现bigkey"><a href="#如何发现bigkey" class="headerlink" title="如何发现bigkey"></a>如何发现bigkey</h4><p>1.利用redis-cli提供的–bigkeys参数，可以遍历分析所有key，并返回Key的整体统计信息与每个数据的Top1的big key</p>
<p>2.自己编程，利用scan扫描Redis中的所有key，利用strlen、hlen等命令判断key的长度</p>
<p>3.第三方监控工具</p>
<h4 id="如何删除BigKey"><a href="#如何删除BigKey" class="headerlink" title="如何删除BigKey"></a>如何删除BigKey</h4><p>BigKey内存占用较多，即便时删除这样的key也需要耗费很长时间，导致Redis主线程阻塞，引发一系列问题。</p>
<ul>
<li>Redis在4.0后提供了异步删除的命令：unlink</li>
</ul>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><h4 id="某个请求的高并发处理"><a href="#某个请求的高并发处理" class="headerlink" title="某个请求的高并发处理"></a>某个请求的高并发处理</h4><p>利用 Redis 分布式集群多节点和数据分片负载均衡来提升性能和保证高可用。</p>
<h4 id="Redis-除了做缓存，还能做什么？"><a href="#Redis-除了做缓存，还能做什么？" class="headerlink" title="Redis 除了做缓存，还能做什么？"></a>Redis 除了做缓存，还能做什么？</h4><p><strong>分布式锁</strong>：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。</p>
<p><strong>限流</strong>：一般是通过 Redis + Lua 脚本的方式来实现限流。</p>
<p><strong>消息队列</strong>：Redis 自带的 List 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。发布 &#x2F; 订阅模式；按照消费者组进行消费；消息持久化；ACK 机制。</p>
]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-03-30-二叉树</title>
    <url>/posts/e3ac.html</url>
    <content><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="一-基本思维，回溯-分解"><a href="#一-基本思维，回溯-分解" class="headerlink" title="一.基本思维，回溯+分解"></a>一.基本思维，回溯+分解</h2><p>注：分解问题一般使用的都是后序遍历，因为我们要假设子问题已经解决了</p>
<p><a href="https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 55 - I. 二叉树的深度</a></p>
<p><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></p>
<p><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a> </p>
<p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a> 层序遍历</p>
 <span id="more"></span>

<h2 id="二-构造二叉树"><a href="#二-构造二叉树" class="headerlink" title="二.构造二叉树"></a>二.构造二叉树</h2><p>需要注意每次将中序分为两部分时，前序也要分成对应的两部分</p>
<p><a href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树</a></p>
<p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></p>
<p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a> </p>
<p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889. 根据前序和后序遍历构造二叉树</a> √</p>
<p><strong>注</strong>：</p>
<p><strong>前序+中序，后序+中序可以唯一确定一棵二叉树</strong>；<br>可以通过前序或者后序遍历结果找到根节点，然后根据中序遍历结果确定左右子树</p>
<p>而<strong>前序+后序不能唯一确定一棵二叉树</strong>关键在这一句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">leftRootVal</span> <span class="operator">=</span> preorder[preStart + <span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>我们假设前序遍历的第二个元素是左子树的根节点，但实际上左子树有可能是空指针，那么这个元素就应该是右子树的根节点。由于这里无法确切进行判断，所以导致了最终答案的不唯一。</p>
<p>例如：preorder &#x3D; [1,2,4,5,3,6,7], postorder &#x3D; [4,5,2,6,7,3,1]</p>
<ol>
<li>1是根节点</li>
<li>2可以是左子树的根节点，也可以是右子树的根节点，这样左子树就为null</li>
</ol>
<h2 id="三-二叉树序列化"><a href="#三-二叉树序列化" class="headerlink" title="三.二叉树序列化"></a>三.二叉树序列化</h2><p>1.使用正确的字符串规则表示该树</p>
<p>2.选择一种遍历顺序，序列化和反序列化都用同一种</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230630155131229.png" alt="image-20230630155131229" style="zoom: 33%;" />前序遍历并采用保留尾部null的形式[1,2,#,#,3,4,#,#,5,#,#,],#代表null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">preorder</span><span class="params">(String[] data_arr)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> data_arr[index];</span><br><span class="line">    index++;</span><br><span class="line">    <span class="keyword">if</span>(str.equals(<span class="string">&quot;#&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(str));</span><br><span class="line">    root.left = preorder(data_arr);</span><br><span class="line">    root.right = preorder(data_arr);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化</a></p>
<p><a href="https://leetcode.cn/problems/find-duplicate-subtrees/">652. 寻找重复的子树</a></p>
<p>1.使用后序遍历，左子树返回其序列化后的字符串，右子树返回其序列化后的字符串，按“左，右，根”的顺序拼起来，作为以该节点为根的子树的序列。<br>2.使用一个map保存上面的序列，并判断该序列是否存在重复，如果有重复说明子树重复</p>
<h2 id="四-后序遍历"><a href="#四-后序遍历" class="headerlink" title="四.后序遍历"></a>四.后序遍历</h2><p>树的后序遍历可以拿到左右子树的返回值，一般用于分解问题</p>
<p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a> √</p>
<p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></p>
<h2 id="五-二叉搜索树"><a href="#五-二叉搜索树" class="headerlink" title="五.二叉搜索树"></a>五.二叉搜索树</h2><h5 id="特性篇"><a href="#特性篇" class="headerlink" title="特性篇"></a>特性篇</h5><p><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></p>
<p><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></p>
<h5 id="基操篇"><a href="#基操篇" class="headerlink" title="基操篇"></a>基操篇</h5><p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></p>
<p>后序遍历，返回的左右子树应该删除完成后的<br>1.先找到这个结点，默认从右子树中找最小的结点替代<br>2.根据该节点的左右指针的情况可以分为三种情况：<br>    2.1.末尾结点<br>    2.2.只有右结点或者只有左节点<br>    上面两种比较简单<br>    2.3 左右结点都有</p>
<p>从右子树中找最小的结点替代，画图分析</p>
<p>提示：可以写一个min函数返回最小元素和一个deleteMin函数删除最小元素</p>
<p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></p>
<p>左子树的最大结点 &lt; 当前结点 &lt; 右子树的最小结点<br>注：可以返回一个大小为2的数组，一个储存当前数的最小值，一个储存最大值</p>
<h5 id="构造篇"><a href="#构造篇" class="headerlink" title="构造篇"></a>构造篇</h5><p><a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a> 动态规划&#x2F;分解问题+记忆数组</p>
<p><a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II</a> 分解问题</p>
<h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><p>实际上，归并排序，快速排序，二分查找都是二叉树的思想</p>
<h3 id="1-使树结构发生改变的操作一定要有返回值。"><a href="#1-使树结构发生改变的操作一定要有返回值。" class="headerlink" title="1.使树结构发生改变的操作一定要有返回值。"></a>1.使树结构发生改变的操作一定要有返回值。</h3><p>场景：删除root.left的某一个结点，root.left &#x3D; deleteNode(root.left)</p>
<p>误区：我们可能会直接使用deleteNode(root.left)。因为我们会认为删除操作会改变树的结构，即使不赋值，root.left的结构也会发生改变（指针操作）。但是如果root.left只剩一个元素呢？deleteNode(root.left)就为空了，而且root.left不赋空值的话，那么root.left还是有结点挂在上面。</p>
<p>扩展：不只是删除操作，结点发生变化的操作都会。例如：root.left被替换。</p>
<h3 id="2-树的递归参数"><a href="#2-树的递归参数" class="headerlink" title="2.树的递归参数"></a>2.树的递归参数</h3><p>树在向下递的过程中，可以在参数中保存遍历过的结点，或者上一结点。</p>
<p>树在向上归的过程中，可以返回一个值。</p>
<p>区别在于，递参数（形参）可以有多个，归参数（返回值）只能有一个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算从起点 start 到终点 target 的最近距离</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BFS</span><span class="params">(Node start, Node target)</span> &#123;</span><br><span class="line">    Queue&lt;Node&gt; q; <span class="comment">// 核心数据结构</span></span><br><span class="line">    Set&lt;Node&gt; visited; <span class="comment">// 避免走回头路</span></span><br><span class="line">    </span><br><span class="line">    q.offer(start); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录扩散的步数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q not empty) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有节点向四周扩散 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="comment">/* 划重点：这里判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span> (cur is target)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">/* 将 cur 的相邻节点加入队列 */</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.adj()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 划重点：更新步数在这里 */</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>队列 <code>q</code> 就不说了，BFS 的核心数据结构；<code>cur.adj()</code> 泛指 <code>cur</code> 相邻的节点，比如说二维数组中，<code>cur</code> 上下左右四面的位置就是相邻节点；<code>visited</code> 的主要作用是防止走回头路，大部分时候都是必须的，但是像一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要 <code>visited</code>。</p>
<p>BFS 可以找到最短距离，但是空间复杂度高，而 DFS 的空间复杂度较低</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-03-30-Kafka</title>
    <url>/posts/27b0.html</url>
    <content><![CDATA[<h2 id="二-kafka"><a href="#二-kafka" class="headerlink" title="二.kafka"></a>二.kafka</h2><p><a href="https://javaguide.cn/high-performance/message-queue/kafka-questions-01.html">https://javaguide.cn/high-performance/message-queue/kafka-questions-01.html</a></p>
<p><a href="https://juejin.cn/post/6850418106372882446">https://juejin.cn/post/6850418106372882446</a></p>
<h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>Kafka是一款分布式的、可分区和具有复制备份的（Replicated）、基于ZooKeeper协调管理的分布式流处理平台。作为一个流式处理平台，kafka具备以下3个关键特性。</p>
<p>（1）能够允许发布和订阅流数据。这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。</p>
<p>（2）存储流数据时提供相应的容错机制。Kafka 提供分布式复制备份的功能，有效避免了消息丢失的风险。</p>
<p>（3）当流数据到达时能够被及时处理。与其他的消息队列相比，主打一个高性能。</p>
 <span id="more"></span>

<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p><strong>异步处理</strong>：将用户的请求数据存储到消息队列之后就立即返回结果。随后，系统再对消息进行消费。</p>
<p><strong>服务解耦</strong>：生产者负责往消息队列里发布消息，消费者负责从消息队列里拉取消息，生产者没有直接调用消费者，这样就可以方便的扩展生产者或者消费者的功能。</p>
<p><strong>削峰&#x2F;限流</strong>：先将短时间高并发产生的消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息。</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/17351239f4db4a2ctplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p>
<h3 id="Kafka-架构"><a href="#Kafka-架构" class="headerlink" title="Kafka 架构"></a>Kafka 架构</h3><h4 id="什么是Broker，Producer、Consumer、Topic、Partition"><a href="#什么是Broker，Producer、Consumer、Topic、Partition" class="headerlink" title="什么是Broker，Producer、Consumer、Topic、Partition"></a>什么是Broker，Producer、Consumer、Topic、Partition</h4><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230413192304591.png" alt="image-20230413192304591" style="zoom:80%;" />

<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230314154632803.png" alt="image-20230314154632803" style="zoom:80%;" />

<p><strong>Kafka 中没有队列这个概念，与之对应的是 Partition（分区）</strong></p>
<ul>
<li><p>Broker</p>
<p>消息队列的处理结点，一个kafka节点就是一个broker，多个broker可以组成一个kafka集群。<del>同一个topic的多个partition可以分布在不同的Broker上，可以提高整个消息队列的性能。</del></p>
</li>
<li><p>Producer</p>
<p>发送消息的程序，Producer可以指定往哪个Topic哪个partition发送消息</p>
</li>
<li><p>Consumer</p>
<p>消费消息的程序，consumer是通过主动拉取自己感兴趣的topic的消息来消费。</p>
</li>
<li><p>Topic</p>
<p>kafka根据topic对消息进行归类，发布到kafka集群的每条消息都需要指定一个topic</p>
</li>
<li><p><strong>Partition（分区）</strong> : </p>
<p>同一个topic的多个partition可以分布在不同的Broker上，实现了分布式储存。通过在消费者组中定义多个消费者，每个消费者消费一个Partition的消息，从宏观上看就相当于有多个消费者在消费一个Topic，提高了消费效率。</p>
</li>
<li><p>Consumer Groups</p>
<p>消费者组，消费者组内的每个消费者负责消费不同分区的数据，提高消费能力。</p>
<p>由于一个partition只能被同组的一个consumer消费，所以可以通过创建多个消费者组来达到多个消费者消费同一个partition的目的。</p>
<p>（注：一个partition只能被一个consumer消费，但是一个consumer可以消费多个partition）</p>
</li>
<li><p>Offsets</p>
<p>记录消费者在消费某个partition的位置信息，每次从队列中获取消息消费时，都要提交offset，kafka内部使用了一个topic来专门保存消费者的offset信息。</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230523131221899.png" alt="image-20230523131221899"></p>
<p>ISR<br>Kafka在ZooKeeper中动态维护了一个ISR（In-Sync Replica），即保存同步的副本列表，该列表中保存的是与Leader副本保持消息同步的所有副本对应的代理节点ID。若一个Follower副本宕机或落后太多，则该Follower副本节点将从ISR列表中移除。*</p>
</li>
</ul>
<h3 id="单播与多播"><a href="#单播与多播" class="headerlink" title="单播与多播"></a><strong>单播与多播</strong></h3><p>单播：一个topic中的某个partition只能被同组的一个consumer消费，可以实现一条消息被一个消费者消费。</p>
<p>多播：一个topic中的某个partition可以被不同组的多个consumer消费，可以实现一条消息被多个消费者消费。</p>
<h3 id="Zookeeper-在-Kafka-中的作用知道吗？"><a href="#Zookeeper-在-Kafka-中的作用知道吗？" class="headerlink" title="Zookeeper 在 Kafka 中的作用知道吗？"></a>Zookeeper 在 Kafka 中的作用知道吗？</h3><p><strong>Broker 注册</strong> ：Kafka的每个broker启动时，都会到zookeeper中进行注册，告诉zookeeper其broker.id。Kafka将元数据信息（topic，partition信息等）保存在Zookeeper中（但是发送给Topic本身的数据是不会发到Zk上的）。</p>
<p><strong>Topic 注册</strong> ： 在 Kafka 中，同一个Topic 的消息会被分成多个partition并将其分布在多个 Broker 上，这些partition信息及与 Broker 的对应关系也都是由 Zookeeper 在维护。</p>
<p><strong>负载均衡</strong>：对于同一个 Topic 的不同 Partition，Kafka 会尽力将这些 Partition 分布到不同的 Broker 服务器上，当生产者产生消息后也会尽量投递到不同 Broker 的 Partition 里面。当 Consumer 消费的时候，Zookeeper 可以根据当前的 Partition 数量以及 Consumer 数量来实现动态负载均衡。</p>
<h3 id="Kafka-如何保证消息的消费顺序"><a href="#Kafka-如何保证消息的消费顺序" class="headerlink" title="Kafka 如何保证消息的消费顺序"></a>Kafka 如何保证消息的消费顺序</h3><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/KafkaTopicPartionsLayout.png" alt="img" style="zoom:80%;" />

<p>为什么需要保证消息的消费顺序？</p>
<p>首先，同一个<strong>Partition</strong>是有序的消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。Kafka 通过偏移量（offset）来保证消息在分区内的顺序性。</p>
<p>然而，Kafka不能保证同一个topic中多个partition中保证总的消费顺序。一个消费者可以消费多个partition</p>
<p>假设有生成订单和支付订单操作它们都同属于结账topic。生产者在对该topic发送消息，topic中的消息会均匀的分发到每个partition上，也就是说同一个partition存在两种操作，那先后顺序就不能通过offset来比较了，就会造成乱序问题。</p>
<ol>
<li>(使用) 1 个 Topic 只对应一个 Partition。</li>
<li>（推荐）发送消息的时候指定 key&#x2F;Partition。</li>
</ol>
<p>因此，kafka的顺序消费会牺牲性能</p>
<h3 id="Kafka-如何保证消息不丢失"><a href="#Kafka-如何保证消息不丢失" class="headerlink" title="Kafka 如何保证消息不丢失"></a>Kafka 如何保证消息不丢失</h3><h4 id="生产消息时丢失"><a href="#生产消息时丢失" class="headerlink" title="生产消息时丢失"></a><strong>生产消息时丢失</strong></h4><p>生产者(Producer) 调用<code>send</code>方法发送消息之后，消息可能因为网络问题并没有发送过去。所以不能默认在调用<code>send</code>方法发送消息之后消息发送成功了。而是要通过消息发送的结果来判断是否成功。</p>
<p>kafka中有两种方法可以获取发送的结果。一种是get()方法，但是这种方法是同步阻塞的，一般不推荐使用；另一种是使用回调函数的方式，当线程发送消息后，会把结果传给回调函数，并调用回调函数的逻辑，因此可以在回调函数中定义重新发送的逻辑即可。</p>
<h4 id="消费消息时丢失"><a href="#消费消息时丢失" class="headerlink" title="消费消息时丢失"></a>消费消息时丢失</h4><p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/kafka-offset.jpg" alt="kafka offset"></p>
<p>当消费者拉取到了分区的某个消息之后，消费者会自动提交了 offset。自动提交的话会有一个问题，试想一下，当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了。</p>
<p><strong>解决办法也比较粗暴，我们手动关闭自动提交 offset，每次在真正消费完消息之后再自己手动提交 offset 。</strong> 但是，细心的朋友一定会发现，这样会带来消息被重新消费的问题。比如你刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。</p>
<h4 id="储存消息时丢失"><a href="#储存消息时丢失" class="headerlink" title="储存消息时丢失"></a>储存消息时丢失</h4><p>针对多集群下，某个broker宕机的情况。</p>
<p>在kafka中可以为topic设置多个副本解决服务器宕机问题，topic会为每个partition都创建副本，并把这些partition副本部署在不同的broker上。其中partition可以分为leader 副本和follower 副本。</p>
<p>我们发送的消息会被发送到 leader 副本，leader 处理 partition 的所有读写请求，与此同时，follower会被动定期地去复制leader上的数据。生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。</p>
<p> 如下图所示，红色的为 leader，绿色的为 follower，leader复制自己到其他 Broker 中：</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230319135324679.png" alt="image-20230319135324679"></p>
<p> 如果leader发生故障或挂掉，如果挂掉的不是leader 副本所在的 broker ，那么就不会出现丢失。</p>
<p>一种情况是：有follower完全同步了leader，那么一个新leader被选举并接收客户端的消息。Kafka确保从同步副本列表中选举一个副本为 leader。</p>
<p>另一种情况是： leader 的数据还有一些没有被 follower 副本的同步的话，就会造成消息丢失。解决方法如下：</p>
<p>设置 <strong>acks &#x3D; all</strong>，当我们配置 <strong>acks &#x3D; all</strong> 表示只有所有 ISR 列表的副本全部收到消息时，生产者才会接收到来自服务器的响应. 这种模式是最高级别的，也是最安全的，可以确保不止一个 Broker 接收到了消息. 该模式的延迟会很高.</p>
<ul>
<li>（ 1 ）acks&#x3D;0： 表示producer不需要等待任何broker确认收到消息的回复，就可以继续发送下一条消息。性能最高，但是最容易丢消息。</li>
<li>（ 2 ）(默认)acks&#x3D;1： 至少要等待leader已经成功将数据写入本地log，但是不需要等待所有follower是否成功写入。就可以继续发送下一条消息。这种情况下，如果follower没有成功备份数据，而此时leader又挂掉，则消息会丢失。</li>
</ul>
<p>其他设置 replication.factor &gt;&#x3D; 3  保证每个 分区(partition) 至少有 3 个副本，</p>
<p>设置 min.insync.replicas &gt; 1，代表消息至少要被写入到 2 个副本才算是被成功发送。</p>
<p>推荐设置replication.factor &#x3D; min.insync.replicas + 1</p>
<h3 id="Kafka-如何保证消息不重复消费"><a href="#Kafka-如何保证消息不重复消费" class="headerlink" title="Kafka 如何保证消息不重复消费"></a>Kafka 如何保证消息不重复消费</h3><ul>
<li>消费消息服务做幂等校验，比如 Redis 的set、MySQL 的主键等天然的幂等功能。这种方法最有效。</li>
</ul>
<p>redis幂等校验：</p>
<ol>
<li>客户端先请求服务端，会拿到一个能代表这次请求业务的唯一字段</li>
<li>将该字段以 SETNX 的方式存入 redis 中</li>
<li>如果设置成功，证明这是第一次请求，则执行后续的业务逻辑</li>
<li>如果设置失败，则代表已经执行过当前请求，直接返回</li>
</ol>
<p>数据库幂等操作：</p>
<p>创建一个唯一索引的表来实现幂等性。</p>
<p>因为唯一字段就是业务的 ID，因此如果重复插入的话会触发唯一约束而导致插入失败。</p>
<h3 id="Rebalance机制"><a href="#Rebalance机制" class="headerlink" title="Rebalance机制"></a>Rebalance机制</h3><p>rebalance只针对subscribe这种不指定分区消费的情况，如果消费方式指定了分区，kafka不会进行rebanlance。</p>
<p>消费者没有指明分区消费。当消费组里消费者和分区的关系发生变化（消费能力过低(两次拉取消息之间的时间间隔超过30s)或者挂掉(心跳检测)），那么就会触发rebalance机制。</p>
<p>这个机制会重新调整消费者消费哪个分区。</p>
<ul>
<li>range：通过公式来计算某个消费者消费哪个分区</li>
<li>轮询：大家轮着消费</li>
<li>sticky：在触发了rebalance后，在消费者消费的原分区不变的基础上进行调整。</li>
</ul>
<h3 id="高水位"><a href="#高水位" class="headerlink" title="高水位"></a>高水位</h3><p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1ODM1OA==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<p>kafka中HW（High Watermark）</p>
<p>用来表示哪些消息可以被消费者消费，相当于分界线。leader的高水位取决于副本中最小的offset，因此高水位后面的属于未提交数据。也就是说，对于leader新写入的消息，consumer不能立刻消费，leader会等待该消息被所有ISR中的replicas同步后更新HW，此时消息才能被consumer消费。这样做可以保证消息的一致性。</p>
<h3 id="消息积压问题"><a href="#消息积压问题" class="headerlink" title="消息积压问题"></a>消息积压问题</h3><p>消息积压：消息队列中的消息越来越多，会导致磁盘被打满</p>
<p>消息积压的原因：</p>
<p>（1）consumer消费能力不足：可以考虑增加topic的partition的个数，同时增加消费者组的消费者的数量。</p>
<p>（2）消费能力弱的consumer被移除：在kafka中默认最大可以拉取500条消息消费，如果这500条消息不能再30s内被消费完(拉取的最大间隔为30s)，kafka就会认为这个consumer消费能力弱，会被移除触发Rebalance机制，Rebalance过程中是不能消费的，就会导致消息积压。可以考虑调整最大拉取数和最大拉取间隔时间的关系，避免消费者被频繁踢出消费组导致Rebalance。</p>
<h3 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h3><ul>
<li>Kafka 如何实现延时队列<ul>
<li>首先，先讲一个常见的业务场景吧，我们对这个场景进行扩展。比如，一个订单场景，一个用户下单后，如果超过30分钟后还没付款，那么我们就要取消这个订单，这时候就可以用延时队列了。</li>
<li>方案一：<ul>
<li>订单服务，用户下单就会生成一个新订单，然后把订单发送给kafka，因为kafka不支持延时队列，所以，我们自己做一个延迟服务，把kafka的订单消息发送给延时服务。</li>
<li>这个延时服务，过了30分钟后就要把这个订单消息发送kafka，然后订单服务消费这个延迟消息，再做业务处理（判断用户是否付款，如果没有付款就取消订单）。</li>
<li>至于这个延时服务，我们可以用Java的延时队列来做。</li>
<li>需要注意的是，我们需要保证延时服务的相对的可靠性，需要做：<ul>
<li>延迟消息的消费者手动提交offset</li>
<li>延迟消息的消费者要做幂等性处理（根据业务需要）</li>
<li>延时服务做 集群</li>
</ul>
</li>
<li><strong>问题</strong>：如果延时服务挂了，那么将会丢掉消息，即使做集群，也会丢失。比如，消息A发送给节点A，节点A挂了，消息A的数据就丢了。后续流量都打到节点B，也就是集群只是保证后续消息的可靠性。</li>
<li>思考：如果一定要用这种方案，如何优化呢？<ul>
<li>前端上做文章，比如，前端也搞个计时器，如果超过30分钟，那么订单页面就不要显示。（虽然前端防君子不防小人，但是99.99%的用户都是君子，前端还是有用的）</li>
<li>人工补偿，运维定时去扫描订单表，如果订单有些因为上诉问题带来未及时关闭的问题，那么运维可以手动关闭。</li>
</ul>
</li>
</ul>
</li>
<li>方案二：<ul>
<li>不要延时服务，订单服务发送一个消息，发送一个消息给kafka，这个消息要添加时间信息：30分钟的时间戳。为了保证顺序性，指定一个key，这样能保证所有消息在同一个partition（同一partition有序）。</li>
<li>然后订单服务，开启一个线程，一直轮询kafka，如果系统当前时间大于第一个消息的时间戳，那么就可以消费了。</li>
<li>问题：<ul>
<li>带来消息的积压，压力来到kafka这边。</li>
<li>而且要轮询，消费者也要牺牲一点轮询的性能。</li>
<li>降低吞吐量，因为指定了key，只使用了一个partition（为了保证消息在kafka内部的有序）。</li>
</ul>
</li>
<li>好处：解决了方案一的问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>事实上，一般不使用kafka来做延迟队列。</p>
<h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h3><p>死信队列是概念上的东西，本质就是一个保存消息的队列。Spring-kafka内部封装了可重试消费消息的方法，也就是可以设置为当消费数据出现异常时，重试这个消息。而且可以设置重试达到多少次后，让消息进入预定好的Topic。这个topic就是死信队列。</p>
<h4 id="nginx的作用"><a href="#nginx的作用" class="headerlink" title="nginx的作用"></a>nginx的作用</h4><p>1、静态HTTP服务器</p>
<p>首先，Nginx是一个HTTP服务器，可以将服务器上的静态文件（如HTML、图片）通过HTTP协议展现给客户端。</p>
<p>2、反向代理服务器</p>
<p>反向代理的作用处理解决跨域，还有负载均衡和虚拟主机的作用。</p>
<p>有的网站访问量大，需要负载均衡。然而并不是所有网站都如此出色，有的网站，由于访问量太小，需要节省成本，将多个网站部署在同一台服务器上。</p>
<p>例如将<a href="https://link.zhihu.com/?target=http://www.aaa.com">http://www.aaa.com</a>和<a href="https://link.zhihu.com/?target=http://www.bbb.com">http://www.bbb.com</a>两个网站部署在同一台服务器上，两个域名解析到同一个IP地址，但是用户通过两个域名却可以打开两个完全不同的网站，互相不影响，就像访问两个服务器一样，所以叫两个虚拟主机。</p>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><h4 id="1-kafka的多次提交和一次提交-kafka发送端3种不同的发送模式"><a href="#1-kafka的多次提交和一次提交-kafka发送端3种不同的发送模式" class="headerlink" title="1.kafka的多次提交和一次提交-kafka发送端3种不同的发送模式"></a>1.kafka的多次提交和一次提交-kafka发送端3种不同的发送模式</h4><p>Fire-and-forget</p>
<p>只发送消息，不关心消息是否发送成功。本质上也是一种异步发送的方式，消息先存储在缓冲区中，达到设定条件后批量发送。当然这是kafka吞吐量最高的一种方式,并配合参数acks&#x3D;0，这样生产者不需要等待服务器的响应，以网络能支持的最大速度发送消息。但是也是消息最不可靠的一种方式，因为对于发送失败的消息没有做任何处理。</p>
<p>Synchronous send</p>
<p>同步发送，send()方法会返回Futrue对象，通过调用Futrue对象的get()方法，等待直到结果返回，根据返回的结果可以判断是否发送成功。如果业务要求消息必须是按顺序发送的，那么可以使用同步的方式，并且只能在一个partation上，结合参数设置retries的值让发送失败时重试，设置max_in_flight_requests_per_connection&#x3D;1，可以控制生产者在收到服务器晌应之前只能发送1个消息，在消息发送成功后立刻flush，从而控制消息顺序发送。<br>在调用send()方法后再调用get()方法等待结果返回。如果发送失败会抛出异常，如果发送成功会返回一个RecordMetadata对象，然后可以调用offset()方法获取该消息在当前分区的偏移量。</p>
<p>KafkaProducer有两种类型的异常，</p>
<p>第一种是可以重试的Retriable，该类异常可以通过重新发送消息解决。例如是连接异常后重新连接、“no leader”异常后重新选取新的leader。KafkaProducer可以配置为遇到该类异常后自动重新发送消息直到超过重试次数。</p>
<p>第二类是不可重试的，例如是“message size too large”（消息太大），该类异常会马上返回错误。</p>
<p>Asynchronous send</p>
<p>异步发送，在调用send()方法的时候指定一个callback函数，当broker接收到返回的时候，该callback函数会被触发执行。如果业务需要知道消息发送是否成功，并且对消息的顺序不关心，那么可以用异步+回调的方式来发送消息，配合参数retries&#x3D;0，并将发送失败的消息记录到日志文件中；要使用callback函数，先要实现org.apache.kafka.clients.producer.Callback接口，该接口只有一个onCompletion方法。如果发送异常，onCompletion的参数Exception e会为非空。</p>
<p>异步发送相关参数<br>异步发送时，kafka会先把消息存储在缓冲池中，当到达设定条件触发缓冲池消息发送。</p>
<p>（1）消息缓存达到batch.size；</p>
<p>（2）距离上一次消息发送时间间隔linger.ms；</p>
<p>（3）调用flush（）方法，会立刻触发发送，并阻塞到当前缓冲区发送完毕；</p>
<p>（4）调用close（），触发发送，完毕后关闭。</p>
<h4 id="2-kafka的消费方式"><a href="#2-kafka的消费方式" class="headerlink" title="2.kafka的消费方式"></a>2.kafka的消费方式</h4><p>subscribe()与assign()</p>
<p>1、KafkaConsumer.subscribe()：为consumer自动分配partition，有内部算法保证topic-partition以最优的方式均匀分配给相同group下的不同consumer。</p>
<p>2、KafkaConsumer.assign()：为consumer手动、显示的指定需要消费的topic-partitions，不会被消费者的组管理功能管理的，不受group.id限制，相当与指定的group无效</p>
]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-04-10-博客1.0</title>
    <url>/posts/83ca.html</url>
    <content><![CDATA[<h2 id="1-博客项目"><a href="#1-博客项目" class="headerlink" title="1.博客项目"></a>1.博客项目</h2><h3 id="什么是跨域请求"><a href="#什么是跨域请求" class="headerlink" title="什么是跨域请求"></a>什么是跨域请求</h3><p> 在 HTML 中，&lt; a &gt;, &lt; form &gt;, &lt; img &gt;, &lt; script &gt;, &lt; iframe &gt;, &lt; link &gt;  等标签以及 Ajax 都可以指向一个资源地址，而所谓的跨域请求就是指：当前发起请求的域与该请求指向的资源所在的域不一样。这里的域指的是这样的一个概念：我们认为若协议 + 域名 + 端口号均相同，那么就是同域，否则就是跨域。</p>
<p> 举个例子：假如一个域名为aaa.cn的网站，它发起一个资源路径为aaa.cn&#x2F;books&#x2F;getBookInfo的 Ajax 请求，那么这个请求是同域的，因为资源路径的协议、域名以及端口号与当前域一致（例子中协议名默认为http，端口号默认为80）。但是，如果在aaa.cn的网站中发起一个资源路径为bbb.com&#x2F;pay&#x2F;purchase的 Ajax 请求，那么这个请求就是跨域请求。</p>
 <span id="more"></span>

<h3 id="什么是CSRF攻击"><a href="#什么是CSRF攻击" class="headerlink" title="什么是CSRF攻击"></a>什么是CSRF攻击</h3><p>跨域请求带来的问题就是CSRF攻击。</p>
<p>攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的登录凭证（一般是cookies），绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p>
<p>例如：小明登录了某a网站，并保留了登录凭证(cookies)，然后小明又去访问b网站，b网站是个钓鱼网站，在b网站中藏有对a网站的请求连接，小明点击之后，对a网站的请求就会携带之前的cookies。即攻击者在受害者不知情的情况下，冒充受害者，对a网站执行了操作。</p>
<h3 id="同源策略是什么"><a href="#同源策略是什么" class="headerlink" title="同源策略是什么"></a>同源策略是什么</h3><p>同源策略（Same-Origin Policy）是一种浏览器安全机制，浏览器仅允许从相同协议（如 HTTP 或 HTTPS）、主机名和端口号加载的文档和脚本之间进行交互。即禁止跨域请求。</p>
<p>浏览器的同源策略并不能完全解决CSRF攻击，例如有些网站会让用户挂上一些链接或者图片，那么它可以直接在本域发起攻击，这种情况下同源策略无法达到防护的作用。</p>
<h3 id="前后端分离项目如何解决跨域问题"><a href="#前后端分离项目如何解决跨域问题" class="headerlink" title="前后端分离项目如何解决跨域问题"></a>前后端分离项目如何解决跨域问题</h3><p>在前后端分离项目中，前端和后端是独立的应用程序，并且通常运行在不同的域名和端口上，属于跨域请求。根据同源策略的限制，浏览器会阻止前端应用程序向不同域名或端口的服务器发送的请求中携带cookies。所以前后端分离项目需要解决跨域问题</p>
<p>解决这个问题</p>
<ol>
<li>使用 CORS（跨域资源共享）：CORS是一种机制，可以让服务器告诉浏览器是否允许发送跨域请求。在后端服务器设置允许跨域请求的响应头，如 Access-Control-Allow-Origin 头部，以便浏览器可以发送跨域请求。同时也可以设置其他的跨域响应头，如 Access-Control-Allow-Methods、Access-Control-Allow-Headers 等。</li>
<li>使用反向代理：<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230404191012892-16815544003451.png" alt="image-20230404191012892" style="zoom:80%;" /></li>
</ol>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><p>如何防范CSRF攻击</p>
<p>使用token代替cookies：</p>
<p>先了解第一方和第三方cookie概念</p>
<p><a href="https://zhuanlan.zhihu.com/p/569770479">https://zhuanlan.zhihu.com/p/569770479</a></p>
<p>正向代理和反向代理</p>
<p>正向代理：代理服务器代表客户端向目标服务器请求资源，客户端知道请求资源地址，也能感知代理服务器的存在。</p>
<p>反向代理：代理服务器代表目标服务器向客户端提供服务，客户端只知道代理服务器的地址，并不知道具体服务器的地址 。</p>
<h5 id="简单原理"><a href="#简单原理" class="headerlink" title="简单原理"></a>简单原理</h5><ul>
<li><p>小壮登录了某网上银行，他来到了网上银行的帖子区，看到一个帖子下面有一个链接写着“科学理财，年盈利率过万”，小壮好奇的点开了这个链接，结果发现自己的账户少了 10000 元。这是这么回事呢？原来黑客在链接中藏了一个请求，这个请求直接利用小壮的身份给银行发送了一个转账请求,也就是通过你的 Cookie 向银行发出请求。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">src</span>=<span class="string">http://www.mybank.com/Transfer?bankId</span>=<span class="string">11&amp;money</span>=<span class="string">10000</span>&gt;</span>科学理财，年盈利率过万<span class="tag">&lt;/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>简而言之： 通过访问恶意网址，恶意网址返回来js自动执行访问你之前登陆的网址，因为你已经登录了，所以再次访问将会携带cookie，因为服务器只认有没有cookie，无法区分是不是用户正常的访问，所以会欺骗服务器，造成伤害</p>
<p> 因此，大多数浏览器都会跨域请求作出限制（同源策略），这是从浏览器层面上的对 CSRF 攻击的一种防御，但是需要注意的是在复杂的网络环境中借助浏览器来防御 CSRF 攻击并不足够，还需要从服务端或者客户端方面入手防御。</p>
<h4 id="项目中的部分："><a href="#项目中的部分：" class="headerlink" title="项目中的部分："></a>项目中的部分：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">        <span class="comment">//关闭csrf</span></span><br><span class="line">                .csrf().disable()</span><br><span class="line">                <span class="comment">//不通过Session获取SecurityContext</span></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">// 对于登录接口 允许匿名访问</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/login&quot;</span>).anonymous()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/logout&quot;</span>).authenticated()</span><br><span class="line"><span class="comment">//                .antMatchers(&quot;/article/list&quot;).authenticated()</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/user/userInfo&quot;</span>).authenticated()</span><br><span class="line"><span class="comment">//                .antMatchers(&quot;/upload&quot;).authenticated()//这里由于前端没有返回token，所以先注释掉</span></span><br><span class="line">                <span class="comment">// 除上面外的所有请求全部不需要认证即可访问</span></span><br><span class="line">                .anyRequest().permitAll();</span><br><span class="line"></span><br><span class="line">        http.exceptionHandling()</span><br><span class="line">                .authenticationEntryPoint(authenticationEntryPoint)</span><br><span class="line">                .accessDeniedHandler(accessDeniedHandler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里UsernamePasswordAuthenticationFilter并不在过滤器链中，但是添加的jwt过滤器是有的</span></span><br><span class="line">        http.addFilterAfter(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭默认的注销功能</span></span><br><span class="line">        http.logout().disable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//允许跨域</span></span><br><span class="line">        http.cors();</span><br></pre></td></tr></table></figure>

<p>anonymous()：表示只允许未登录的用户访问，已登录的用户无法访问，会进行权限检查，如：登录注册接口</p>
<p>permitAll()：表示未登录和已登录的用户都能访问，不会进行权限检查，如：静态资源，公共资源</p>
<p>authenticated()：表示只允许已登录的用户访问，会进行权限检查</p>
<p>详细的执行流程看gpt</p>
<p>anonymous()方法Spring Security会创建一个匿名Authentication对象，并将其存储到SecurityContextHolder中，以便在后续的请求中可以获取到该对象。</p>
<p>注：这三个方法都不会绕过过滤器，<code>permitAll()</code>方法会将对应的URL添加到Spring Security的忽略列表中，以便在安全认证时不对该URL进行拦截和处理。但自定义的过滤器不会被忽略。</p>
<h5 id="SpringSecurity去防止CSRF攻击的方式就是通过csrf-token。后端会生成一个csrf-token，前端发起请求的时候需要携带这个csrf-token-后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。"><a href="#SpringSecurity去防止CSRF攻击的方式就是通过csrf-token。后端会生成一个csrf-token，前端发起请求的时候需要携带这个csrf-token-后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。" class="headerlink" title="SpringSecurity去防止CSRF攻击的方式就是通过csrf_token。后端会生成一个csrf_token，前端发起请求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。"></a>SpringSecurity去防止CSRF攻击的方式就是通过csrf_token。后端会生成一个csrf_token，前端发起请求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。</h5><h5 id="我们可以发现CSRF攻击依靠的是cookie中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是token，而token并不是存储中cookie中，并且需要前端代码去把token设置到请求头中才可以，所以CSRF攻击也就不用担心了。"><a href="#我们可以发现CSRF攻击依靠的是cookie中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是token，而token并不是存储中cookie中，并且需要前端代码去把token设置到请求头中才可以，所以CSRF攻击也就不用担心了。" class="headerlink" title="我们可以发现CSRF攻击依靠的是cookie中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是token，而token并不是存储中cookie中，并且需要前端代码去把token设置到请求头中才可以，所以CSRF攻击也就不用担心了。"></a>我们可以发现CSRF攻击依靠的是cookie中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是token，而token并不是存储中cookie中，并且需要前端代码去把token设置到请求头中才可以，所以CSRF攻击也就不用担心了。</h5><p>项目如何解决跨域问题：</p>
<p>1.使用nginx作为反向代理服务器，绕过跨域</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230404190405239.png" alt="image-20230404190405239" style="zoom:80%;" /><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230404190410761.png" alt="image-20230404190410761" style="zoom: 50%;" /></p>
<p>前端项目中的请求地址都是192.168.138.100&#x2F;api</p>
<img data-src="E:\study\javawebSys\Algorithms-4th-Edition-master\截图\image-20230404191012892-17110049548653.png" alt="image-20230404191012892" style="zoom:80%;" />

<p>首先前端发给后端的请求都会先发给代理服务器，然后由代理服务器nginx重写请求的url地址，并发送请求给后端服务器，服务器再发送响应给代理服务器。这样就避免浏览器直接给后端服务器发送请求，也就避免了跨域问题。</p>
<p>2.使用security的CORS机制允许跨域，在后端服务器上设置允许跨域请求的响应头，如 Access-Control-Allow-Origin 头部，告诉浏览器允许发送跨域请求。</p>
<p>（实际上1，2是重复的）</p>
<p>3.然后使用token避免CSRF攻击。</p>
<h4 id="nginx的作用"><a href="#nginx的作用" class="headerlink" title="nginx的作用"></a>nginx的作用</h4><p>1、静态HTTP服务器</p>
<p>首先，Nginx是一个HTTP服务器，可以将服务器上的静态文件（如HTML、图片）通过HTTP协议展现给客户端。</p>
<p>2、反向代理服务器</p>
<p>反向代理的作用处理解决跨域，还有负载均衡和虚拟主机的作用。</p>
<p>有的网站访问量大，需要负载均衡。然而并不是所有网站都如此出色，有的网站，由于访问量太小，需要节省成本，将多个网站部署在同一台服务器上。</p>
<p>例如将<a href="https://link.zhihu.com/?target=http://www.aaa.com">http://www.aaa.com</a>和<a href="https://link.zhihu.com/?target=http://www.bbb.com">http://www.bbb.com</a>两个网站部署在同一台服务器上，两个域名解析到同一个IP地址，但是用户通过两个域名却可以打开两个完全不同的网站，互相不影响，就像访问两个服务器一样，所以叫两个虚拟主机。</p>
<h3 id="jwt-redis-security"><a href="#jwt-redis-security" class="headerlink" title="jwt + redis + security"></a>jwt + redis + security</h3><p>jwt<br><a href="https://javaguide.cn/system-design/security/jwt-intro.html">https://javaguide.cn/system-design/security/jwt-intro.html</a><br><a href="https://javaguide.cn/system-design/security/advantages&disadvantages-of-jwt.html">https://javaguide.cn/system-design/security/advantages&amp;disadvantages-of-jwt.html</a></p>
<p>JSON Web Token JWT 本身也是 Token，一种规范化之后的 JSON 结构的 Token。</p>
<p>1.Header(头） 作用：记录令牌类型、签名算法等 例如：{“alg”:”HS256”,”type”,”JWT}</p>
<p>2.Payload(有效载荷）作用：携带一些用户信息 例如{“userId”:”1”,”username”:”mayikt”}</p>
<p>3.Signature(签名）作用：服务器对Payload、Header 使用 Header 里面指定的签名算法和密钥生成的一个字符串</p>
<p>客户端接收到 JWT （Header、Payload、Signature组成）之后，会将其保存在者 localStorage 里面，以后客户端发出的所有请求的Header都会携带这个令牌。密钥只存在于服务端，服务通过密钥解密得到里面payload的内容后，一般是用户的信息，就可以知道是哪个用户的请求消息了</p>
<p>JWT 一般是存在在 localStorage避免了 CSRF 攻击，还可以储存敏感的json格式数据内容</p>
<p>保持令牌的有效期限短并经常轮换  JWT 的续签类似于 Session 认证中的做法</p>
<p>认证流程</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20211215094003288.png" alt="image-20211215094003288"></p>
<p>注：第一次登陆时服务端给前端发送一个jwt，随后前端每次给该服务端发送请求时都会携带这个token信息。</p>
<p>security自带的登录认证功能</p>
<p>如果登录路径是&#x2F;login时，会使用security的UsernamePasswordAuthenticationFilter进行登录认证，，也就是默认的登录认证流程，认证流程如下：</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20211214151515385.png" alt="image-20211214151515385"></p>
<p>（如果之前没问security的登录授权原理，则讲一下authenticationManager后面发生的事）</p>
<p>但是为了使用jwt+redis的登录方式，所以项目使用了自定义的过滤器完成登录认证操作。而且还自定义UserDetailsService去数据库中查找用户密码并封装到userDetail对象中。</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230212194826797-167871334825110.png" alt="image-20230212194826797"></p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230217233327432-167871335616413-16800592970161.png" alt="image-20230217233327432"></p>
<p>在自定义的jwt认证过滤器中。分为两种情况：这里token储存的是用户id信息</p>
<ol>
<li><p>请求不携带token：直接放行，放行的接口分为两种，一种是登录接口，一种是不需要登录就能访问的接口，可以在security配置中进行设置。</p>
<p>访问登录接口：登录功能除了设置token外，还需要把通过AutheticationManager认证完成后返回的Authetication储存到redis中，作为已登录的证明。</p>
</li>
<li><p>请求携带token：说明用户已经登录，因此过滤器获取到token并解析后，得到登录用户的id信息，然后去redis中获取登录时保存的Authentication对象保存在SecurityContextHolder中，这样就能根据Authentication对象中的权限信息访问指定接口了。</p>
</li>
</ol>
<p>退出登录时，会删除redis中的用户信息。</p>
<p>这里流一个坑，对于不需要登录的请求(permitAll())，如果没有携带token访问会发生什么？首先不需要登录的请求需要在security中permit，这样这些请求在经过security自带的过滤器就会被忽略，但是自己定义的jwt过滤还是会触发的，所以在jwt过滤器中对于没有携带token的请求就是直接放行。</p>
<h5 id="各部分的作用"><a href="#各部分的作用" class="headerlink" title="各部分的作用"></a>各部分的作用</h5><p>jwt：对用户的id进行加密传输，实现身份验证。<br>redis：使用一个String结构储存用户的权限信息。key为用户id，String为Security中Authentication对象的序列化<br>security：</p>
<ul>
<li>CORS（跨域资源共享）</li>
<li>认证和授权</li>
</ul>
<h3 id="oss对象储存"><a href="#oss对象储存" class="headerlink" title="oss对象储存"></a>oss对象储存</h3><p>前端根据图片url直接从oss服务器中请求资源，避免将图片储存在服务器中，而且也不需要向后端发送图片请求。</p>
<h3 id="使用kafka消息队列实现评论通知功能，解耦发表评论和评论验证功能，提高系统响应时间。"><a href="#使用kafka消息队列实现评论通知功能，解耦发表评论和评论验证功能，提高系统响应时间。" class="headerlink" title="使用kafka消息队列实现评论通知功能，解耦发表评论和评论验证功能，提高系统响应时间。"></a>使用kafka消息队列实现评论通知功能，解耦发表评论和评论验证功能，提高系统响应时间。</h3><p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/message-queue-pub-sub-model.63a717b4.png" alt="发布/订阅（Pub/Sub）模型"></p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230415194008607.png" alt="image-20230415194008607" style="zoom:80%;" />

<p>为什么选择kafka<br>kafka的优点是吞吐量高，主要场景是处理海量消息，如收集信息数据，</p>
<p>在搭建kafka环境时，又觉得kafka有点小题大做了，因为kafka是自带分布式特性的，可以通过建立多个集群提高性能。</p>
<p>而且在实际项目，topic只使用了一个partition，这主要考虑到消息的有序性。</p>
<p>如何实现</p>
<p>用户发表评论时，只需要验证登录信息就可以发送成功，然后把评论信息发到kafka的评论主题中，这个请求就算成功了。当kafka的topic中有新消息时，消费者会主动从评论主题中获取评论信息，使用前缀树算法过滤敏感词，再写入数据库，并在redis中写入未读消息数。</p>
<p>为什么要这样设计</p>
<p>评论验证功能中，使用了前缀树算法过滤敏感词，需要一定的时间处理；而且验证完成后需要完成数据库和redis的写入功能，需要花费一定的时间。</p>
<p>定义数据传输对象</p>
<p>定义发送信息实体</p>
<p>获取消息的消费者实体</p>
<p>注意：消费机制是通过监听器实现的,直接使用@KafkaListener(topics &#x3D; {“user-log”})注解，根据指定的条件进行消息的监听</p>
<h3 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h3><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p>比如在这个系统中，有些管理员可以对用户和文章进行管理，而有些管理员只能对文章进行管理，普通用户只能对友链进行管理。</p>
<p>但是不能只依赖前端去选择显示哪些菜单哪些按钮。因为这样的话，还是可以通过直接发送请求给接口获取数据。</p>
<p>解决方法就是在后台进行用户权限的判断</p>
<p>授权基本流程</p>
<p>在SpringSecurity中，会使用默认的FilterSecurityInterceptor来进行权限校验。</p>
<p>而且SpringSecurity还提供了PreAuthorize注解，用来控制一个接口是否能够被调用的</p>
<p>在PreAuthorize中可以传入一个自定义方法，方法的参数是接口的权限值，方法的返回值是一个Boolean值，可以用来判断是否具有权限。</p>
<p>然后在自定义方法中需要定义比对用户拥有的权限和资源所需的权限的逻辑</p>
<p>用户拥有的权限可以从SecurityContextHolder中的Authentication获取。</p>
<p>资源所需的权限会作为自定义方法的参数传入。</p>
<p>然后对比这两个权限，如果成功则返回true，对比失败则返回false，会抛出授权异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPermission</span><span class="params">(String permission)</span>&#123;</span><br><span class="line">    <span class="comment">//如果是超级管理员  直接返回true</span></span><br><span class="line">    <span class="keyword">if</span>(SecurityUtils.isAdmin())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则  获取当前登录用户所具有的权限列表 如何判断是否存在permission</span></span><br><span class="line">    List&lt;String&gt; permissions = SecurityUtils.getLoginUser().getPermissions();</span><br><span class="line">    <span class="keyword">return</span> permissions.contains(permission);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20211214144425527.png" alt="image-20211214144425527"></p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>数据库中储存articleid和position字段，根据articleid可以发送获取文章详情的请求，页面跳转到文章详情页面，position可以定位到文章的二级标题。</p>
<h3 id="AOP-reids实现根据ip或者用户限制接口请求功能"><a href="#AOP-reids实现根据ip或者用户限制接口请求功能" class="headerlink" title="AOP + reids实现根据ip或者用户限制接口请求功能"></a>AOP + reids实现根据ip或者用户限制接口请求功能</h3><p>AOP实现日志打印：</p>
<p>AOP + Redis实现根据ip或者用户限制接口请求次数功能：</p>
<p>在该项目用于限制用户的评论次数和文章的浏览量更新次数。</p>
<p>利用redis自带的给缓存数据设置过期时间的功能实现，key值为接口的urI拼上ip或者用户的id，value值为目前访问的次数，并给这个数据设置一个过期时间，当某个接口被访问时，先去redis中查看相关的key值，如果没有说明接口还没有被访问过；如果有，再通过value值判断是否超出访问次数。由于给key值设置了过期时间，因此，可以实现在一段时间内的限制功能。</p>
<p>然后把这个功能包装成一个切面，使用环绕通知增强需要限流的接口方法。在方法执行前判断某个用户或ip是否超出了访问次数，然后在方法执行后更新缓存数据。</p>
<h3 id="使用线程池技术，实现定时持久化redis中的数据到数据库中的功能"><a href="#使用线程池技术，实现定时持久化redis中的数据到数据库中的功能" class="headerlink" title="使用线程池技术，实现定时持久化redis中的数据到数据库中的功能"></a>使用线程池技术，实现定时持久化redis中的数据到数据库中的功能</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获得当前时间</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="comment">// 获取本周四 18:00:00.000</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">thursday</span> <span class="operator">=</span> </span><br><span class="line">    now.with(DayOfWeek.THURSDAY).withHour(<span class="number">18</span>).withMinute(<span class="number">0</span>).withSecond(<span class="number">0</span>).withNano(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 如果当前时间已经超过 本周四 18:00:00.000， 那么找下周四 18:00:00.000</span></span><br><span class="line"><span class="keyword">if</span>(now.compareTo(thursday) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    thursday = thursday.plusWeeks(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算时间差，即延时执行时间</span></span><br><span class="line"><span class="type">long</span> <span class="variable">initialDelay</span> <span class="operator">=</span> Duration.between(now, thursday).toMillis();</span><br><span class="line"><span class="comment">// 计算间隔时间，即 1 周的毫秒值</span></span><br><span class="line"><span class="type">long</span> <span class="variable">oneWeek</span> <span class="operator">=</span> <span class="number">7</span> * <span class="number">24</span> * <span class="number">3600</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;开始时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">executor.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;, initialDelay, oneWeek, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>

<p>使用场景：</p>
<p>对于文章的浏览量，在redis中一份，数据库中一份，由于文章的浏览量需要经常更新，而且对一致要求不高，所以使用异步缓存写入的方式。在读取和写入都是以redis为主，然后通过一个异步线程定时更新数据库中的浏览量。</p>
<p>为什么要使用线程池：</p>
<p>降低资源消耗，提高响应速度，提高线程的可管理性；理论上使用一个定时任务线程也能完成，但是当定时任务变多时，就不好管理了。</p>
<p>实现：</p>
<p>使用juc提供的ScheduledThreadPool线程池启动定时任务，使用scheduleAtFixedRate提交定时任务。scheduleAtFixedRate需要2个重要的参数，初始延迟时间和间隔时间，初始延迟时间是指该定时任务第一次执行的延迟时间，时间间隔指每隔多久重复执行任务，计算完这些参数值就可以把任务提交给线程池，由线程池分配线程执行任务了。</p>
<h2 id="2-点评项目"><a href="#2-点评项目" class="headerlink" title="2.点评项目"></a>2.点评项目</h2><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p><a href="https://www.yuque.com/snailclimb/mf2z3k/sy238z">https://www.yuque.com/snailclimb/mf2z3k/sy238z</a></p>
<p>本项目使用Cache Aside Pattern模式，即旁路缓存方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</p>
<p>读：</p>
<p>1.从cache中读取数据，读取到就直接返回；<br>2.cache中读取不到的话，就从db中读取数据返回；<br>3.再把db中读取到的数据放到cache中。</p>
<p>写：</p>
<p>1.先更新db;<br>2.直接删除cache。</p>
<p>删除缓存还是更新缓存？</p>
<ul>
<li>更新缓存：每次更新数据库都更新缓存，无效写操作较多</li>
<li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存(√)</li>
<li>对服务端资源造成浪费：删除cache更加直接，这是因为cache中存放的一些数据需要服务端经过大量的计算才能得出，会消耗服务端的资源，是一笔不小的开销。如果频繁修改db,就能会导致需要频繁更新cache,而cache中的数据可能都没有被访问到。</li>
</ul>
<p>先操作缓存还是先操作数据库？</p>
<ul>
<li>先删除缓存，再操作数据库</li>
<li>先操作数据库，再删除缓存</li>
<li>应当是先操作数据库，再删除缓存，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上redis中写入的就是旧的数据，造成了数据库和redis的数据不一致。</li>
</ul>
<h3 id="手动封装了一个Redis工具类，"><a href="#手动封装了一个Redis工具类，" class="headerlink" title="手动封装了一个Redis工具类，"></a>手动封装了一个Redis工具类，</h3><p>实现了防止缓存身透（缓存空对象）、缓存击穿(逻辑过期，互斥锁)和缓存雪崩（给不同的Key设置随机TTL)问题，并实现了一个简单的Redis分布式锁</p>
<h4 id="缓存穿透："><a href="#缓存穿透：" class="headerlink" title="缓存穿透："></a>缓存穿透：</h4><p>缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求就会穿透了缓存，直击数据库。如果请求比较多时，对数据库造成了巨大的压力。</p>
<p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p>
<p>缓存空对象思路分析：简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</p>
<p>缺点：这种方式可以解决请求的 key 变化不频繁的情况，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。</p>
<h4 id="缓存击穿："><a href="#缓存击穿：" class="headerlink" title="缓存击穿："></a>缓存击穿：</h4><p>缓存击穿中，请求的 key 对应的是热点数据 ，该数据存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期） 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力。</p>
<p>注：这些请求是同时发生的，因为根据缓存的更新策略，一旦有一个请求读取数据库成功就会去更新缓存，其他在它之后的请求就能去缓存查询了，所以同时的话就一起去读取数据库了。</p>
<p>redis实现锁的方法：redis setnx方法，该方法含义是redis中如果没有这个key，则插入成功，返回1，如果有这个key则插入失败，则返回0。一般来说为防止死等，还会加上一个过期时间</p>
<p>redis释放锁的方法：del key</p>
<h5 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h5><p>因为在缓存击穿中，是由于高并发场景下，同时访问一个失效key导致的，所以最简单的解决方法就是给这些请求加锁，保证在多个线程未命中缓存数据时，只有一个线程可以获得锁去数据库查询数据并更新到缓存中，其他获取锁失败的线程，隔一段时间去查询缓存或者尝试获取锁，如果查询成功则不需要获取锁了，但如果获取锁成功还要一下查询缓存，做双重确认，避免无效更新。所以这里的锁只锁住了数据库查询和更新缓存的操作，并没锁住查询缓存的操作，在一定程度下减少了锁的粒度。</p>
<h5 id="逻辑过期（异步操作）"><a href="#逻辑过期（异步操作）" class="headerlink" title="逻辑过期（异步操作）"></a>逻辑过期（异步操作）</h5><p>逻辑过期的基本思想是，不设置过期时间，这样就不会发生key的失效问题。它的策略是这样子的，把过期时间设置在 redis的value中，假设某个请求查询缓存发现逻辑时间过期，那么它会去尝试获取锁，一种情况获取锁成功，就会开启一个新的线程去完成查询数据库更新缓存数据的操作，新线程完成工作后释放锁，然后原线程先返回过期数据；另一种情况是获取锁失败，那么直接返回过期数据。也就是说，缓存的更新操作交由内部线程去异步执行了，在更新操作完成前只能得到过期的数据。</p>
<p>优缺点对比：</p>
<p>互斥锁方案：数据一致，且实现简单；串行执行性能会受影响</p>
<p>逻辑过期方案：数据不保证一致，实现起来麻烦；读取过程中不需要等待，性能好</p>
<h4 id="缓存雪崩："><a href="#缓存雪崩：" class="headerlink" title="缓存雪崩："></a>缓存雪崩：</h4><p>同一时段大量的缓存key同时失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。</p>
<p>设置不同的失效时间比如随机设置缓存的失效时间。</p>
<h4 id="缓存击穿和缓存雪崩的区别："><a href="#缓存击穿和缓存雪崩的区别：" class="headerlink" title="缓存击穿和缓存雪崩的区别："></a>缓存击穿和缓存雪崩的区别：</h4><p>击穿是一个被多次请求的key突然失效了，导致这些请求同时打在数据库中，针对一个key的情况；雪崩是多个key同时失效，多个请求同时在数据库上，针对多个key的情况。</p>
<h4 id="缓存击穿和缓存穿透的区别："><a href="#缓存击穿和缓存穿透的区别：" class="headerlink" title="缓存击穿和缓存穿透的区别："></a>缓存击穿和缓存穿透的区别：</h4><p>缓存穿透的请求的数据不存在于缓存中，也不在数据库中；缓存击穿的请求数据不在缓存中，但存在与数据库中</p>
<h3 id="基于Redis实现了优惠卷秒杀功能，"><a href="#基于Redis实现了优惠卷秒杀功能，" class="headerlink" title="基于Redis实现了优惠卷秒杀功能，"></a>基于Redis实现了优惠卷秒杀功能，</h3><p>并进行了一些优化：组合使用Redisson+Lua脚本来完成秒杀资格判断，并通过kafka消息队列实现优惠券异步秒杀下单功能，加快秒杀逻辑判断的同时保证分布式条件下的线程安全。</p>
<h4 id="Redis实现全局唯一Id"><a href="#Redis实现全局唯一Id" class="headerlink" title="Redis实现全局唯一Id"></a>Redis实现全局唯一Id</h4><p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/1653363172079-16797288973592.png" alt="1653363172079"></p>
<p>使用一个long型变量储存这个id，时间戳 &#x3D; 当前时间 - 某个开始时间戳，序列号使用redis的自增长</p>
<p>这样设计的主要目的是如果id直接使用redis自增长，很容易被别人财产敏感信息；并发环境下生产的订单id可能是相同的，保证全局唯一id</p>
<h4 id="优惠卷秒杀功能"><a href="#优惠卷秒杀功能" class="headerlink" title="优惠卷秒杀功能"></a>优惠卷秒杀功能</h4><p>主要流程</p>
<ul>
<li><p>新增秒杀优惠券的同时，将优惠券信息保存到Redis中</p>
</li>
<li><p>在进行秒杀逻辑前，使用redisson对用户id进行加锁，使得相同用户使用的是同一把锁，不同用户使用的是不同的锁，这样就能保证用户的多次秒杀操作只有一次是有效的。</p>
</li>
<li><p>基于Lua脚本，判断秒杀库存是否充足、是否一人一单（幂等），以此决定用户是否抢购成功</p>
</li>
<li><p>如果抢购成功，在redis中扣减库存和保存下单用户，将订单信息封装后存入阻塞队列</p>
</li>
<li><p>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</p>
</li>
<li><p>更新数据库中的数据</p>
</li>
</ul>
<h5 id="秒杀功能的实现"><a href="#秒杀功能的实现" class="headerlink" title="秒杀功能的实现"></a>秒杀功能的实现</h5><p>Redisson是一个基于Java的Redis客户端，他提供了许多分布式服务，其中包括各种分布锁的实现，可帮助开发人员构建分布式应用程序。</p>
<p>使用Lua脚本编写Redis命令语句的作用是可以将多个Redis命令组合成一个原子性的操作。这些Redis命令将按顺序执行，并且作为一个单独的操作来执行，这样可以确保这些命令被一起执行，有点类似数据库事务的作用。</p>
<p>分布式锁：通过把锁放在redis而不是jvm中可以实现多集群下使用同一把锁。</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230325181919550.png" alt="image-20230325181919550"></p>
<p>redis中需要储存优惠劵的库存，储存成功抢到优惠劵的用户id（set）</p>
<h5 id="秒杀功能"><a href="#秒杀功能" class="headerlink" title="秒杀功能"></a>秒杀功能</h5><p>分布式锁只是保证用户的多次秒杀操作只有一次是有效的，还需要解决不同用户的超卖问题。</p>
<p>lua脚本的内容包括判断库存是否充足，判断用户是否下单，扣减库存和保存下单用户，这些都是一个原子操作。</p>
<p>lua脚本执行并返回成功后，则把订单信息保存在消息队列中，由一个异步线程不断的取消息队列中的订单信息，并调用创建订单操作。</p>
<p>秒杀功能和创建订单通过消息队列解耦了</p>
<h5 id="创建订单功能"><a href="#创建订单功能" class="headerlink" title="创建订单功能"></a>创建订单功能</h5><p>创建订单操作中包括在数据库中更新秒杀劵的库存信息和插入订单信息。</p>
<p><del>为了防止一个用户登录同时抢多次优惠券，还需要对创建订单的操作加互斥锁，不过这个锁要求只阻塞相同用户的操作。实现方法是使用redisson尝试获取分布锁，获取失败说明已经有程序在执行该用户的下单业务，该用户可能重复下单了。获取成功的线程就可以继续更新数据库数据了。</del></p>
<p>更新秒杀劵库存借助乐观锁的思想，通过判断优惠券的库存是否大于0来决定此次秒杀是否成功，判断库存大于0和把库存数量减一是在一个sql语句中完成的，不用担心出现超买现象，因为数据库对同一行数据的更新操作会加锁。这里不使用版本号是因为版本号需要相等才能秒杀成功，而获取当前版本号和根据版本号更新数据库是两个不同的操作，会导致线程的失败率增大。</p>
<h3 id="基于Redis的SortedSet数据结构"><a href="#基于Redis的SortedSet数据结构" class="headerlink" title="基于Redis的SortedSet数据结构"></a>基于Redis的SortedSet数据结构</h3><p>实现简单的推模式Feed流，以及点赞排行榜功能</p>
<h4 id="点赞排行榜："><a href="#点赞排行榜：" class="headerlink" title="点赞排行榜："></a>点赞排行榜：</h4><p>实现查询最早点赞的5个用户</p>
<p>点赞实现：</p>
<p>redis中用一个sortedSet储存该笔记被哪些用户点过赞，value是用户id，score是点赞的当前时间，一个用户只能对一篇笔记点一次赞。点餐成功更新数据库中的点赞数。</p>
<h4 id="好友关注推送消息"><a href="#好友关注推送消息" class="headerlink" title="好友关注推送消息"></a>好友关注推送消息</h4><p>当我们关注了用户后，这个用户发了动态，那么我们应该把这些数据推送给用户，这个需求，其实我们又把他叫做Feed流，关注推送也叫做Feed流，直译为投喂。为用户持续的提供“沉浸式”的体验，通过无限下拉刷新获取新的信息。</p>
<p>对于新型的Feed流的的效果：不需要我们用户再去搜索信息，而是系统分析用户到底想要什么，然后直接把内容推送给用户，从而使用户能够更加的节约时间，不用主动去寻找。</p>
<p>推模式：每个用户都有自己的收件箱。当一个用户发表一篇文章时，需要给他的粉丝的收件箱都发一份数据，这样粉丝只需要通过查看自己收件箱就能获取推送消息。</p>
<p>拉模式：每个用户都有自己的发件箱，当一个用户发表一篇文章时，只需要在他的发件箱存一份数据，粉丝获取推送消息时，需要从所有他关注的人的发件箱中获取数据。</p>
<p>项目只实现了推模式，所以这里只提供推模式的思路</p>
<p>发布笔记：发表探店笔记(db)–&gt;查询作者粉丝(db)–&gt;推送笔记id给所有粉丝的sortset集合中(redis)</p>
<p>查询笔记：查询sortset中某页的笔记id(redis)-&gt;去数据库查询具体的笔记信息(db)-&gt;封装并返回响应</p>
<p>为什么不使用数据库直接存储？</p>
<p>数据库只使用笔记表和用户关注表时。</p>
<p>虽然在插入笔记时比较方便，但是查询笔记时需要根据进行多表查询，而且其中还会涉及排序和分页操作，不仅实现复杂，而且数据库压力变大。</p>
<p>优点</p>
<p>redis的读写性能更快；而且redis的sortset结构本身就是有序的，而数据库中的数据是无序储存的，需要对数据进行排序，因此redis的性能更好。</p>
<p>优化方案</p>
<ul>
<li><p>每当用户发布&#x2F;删除新的 feed，我们需要更新该用户所有的粉丝的 Feed流，该步骤一般比较耗时，所以建议异步处理(本项目没有)</p>
</li>
<li><p>为了避免一次性load出太多的粉丝数据，这里采用循环分页查询。</p>
</li>
</ul>
<p>​		循环分页：根据最后一条记录的id和页大小，取下一页的记录。</p>
<p>​		传统分页：根据页号和页大小得到下一页的初始id值，限尾部插入有效。</p>
<ul>
<li><p>不能使用传统分页的原因是sortset中的记录是在顶部插入的，所以根据页号和页的大小得到下一页的初始值。</p>
</li>
<li><p>为了避免粉丝的 Feed流过大，我们会限制 Feed 流的长度为1000，当Feed流长度超过1000时，会移除最旧的 Feed。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-04-10-回溯</title>
    <url>/posts/fd5f.html</url>
    <content><![CDATA[<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="一-回溯的个人理解"><a href="#一-回溯的个人理解" class="headerlink" title="一.回溯的个人理解"></a>一.回溯的个人理解</h2><p>回溯的重点在于回溯也就是在往回走的时候能够回到原来的状态</p>
<p>前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。</p>
<p>1.穷举；2.回溯要求在往回走的时候能够回到原来的状态；</p>
<h2 id="二-递归参数的理解："><a href="#二-递归参数的理解：" class="headerlink" title="二.递归参数的理解："></a>二.递归参数的理解：</h2><p>回溯：在回溯问题上，如果递归函数的参数中有对象（指针），那么该对象参数最好能够作为全局变量声明，因为在递归的过程中如果递的过程中修改了对象的值，然后在归的时候没有维护成为递之前的状态，就不能达到回溯的效果。<br>总的来说，对象始终只有一个。在回溯递归中，递归参数（基本数据类型）不需要回溯，因为递归栈本身就会保存每一次递归的值；全局变量需要手动回溯，即在归时要回溯。</p>
 <span id="more"></span>

<h2 id="三-回溯的解题步骤："><a href="#三-回溯的解题步骤：" class="headerlink" title="三.回溯的解题步骤："></a>三.回溯的解题步骤：</h2><p>1.路径：也就是已经做出的选择，回退时能够撤销选择；（递归深度）<br>2.选择：也就是你当前可以做的选择，每个节点的选择可能会发生变化；<br>3.剪枝：哪些选择是重复的或者是无用的；（剪枝决定算法是否超时）<br>4.结束条件：也就是到达决策树底层，无法再做选择的条件。开始回退的条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line">def <span class="title function_">backtrack</span><span class="params">(路径, 选择列表)</span>:</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">for</span> 选择 in 选择列表:</span><br><span class="line">		剪枝 <span class="keyword">continue</span>;</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<p><strong>注1</strong>：回溯的过程都可以使用一个递归树表示</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230617111724633-16883855875341.png" alt="image-20230617111724633" style="zoom: 50%;" />

<p>一般来说，递归的深度决定树的深度，for循环决定树水平方向的宽度。当某个实体作为递归的深度时，它的变量或者状态应该定义在递归函数参数中。</p>
<p><strong>注2</strong>：当回溯算法中的选择项会随递归深度变化时，不能直接修改包含选择项的集合，因为这样会导致在迭代数组的同时修改数组的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list;<span class="comment">//选择</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l:list)&#123;</span><br><span class="line">    list.remove();</span><br><span class="line">    list.add()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法：</p>
<ul>
<li><p>marked[]数组，标记哪些选择是使用过的。</p>
</li>
<li><p>usedState（int）状态量，使用位运算表示哪些选择是使用过的。好处是可以做备忘录。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将第 i 位标记为 1        // 将第 i 位标记为 0		判断某一位置是否为 1</span></span><br><span class="line">used |= <span class="number">1</span> &lt;&lt; i;				used ^= <span class="number">1</span> &lt;&lt; i;			((used &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="四-剪枝if-i-0-bucket-i-bucket-i-1-："><a href="#四-剪枝if-i-0-bucket-i-bucket-i-1-：" class="headerlink" title="四.剪枝if (i &gt; 0 &amp;&amp; bucket[i] &#x3D;&#x3D; bucket[i - 1])："></a>四.剪枝if (i &gt; 0 &amp;&amp; bucket[i] &#x3D;&#x3D; bucket[i - 1])：</h2><p>回溯算法的优化大部分取决于剪枝</p>
<p>排列组合中，剪枝 i &gt; start &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]，表示重复元素只取第一个。</p>
<p>球盒模型中，剪枝i &gt; 0 &amp;&amp; bucket[i] &#x3D;&#x3D; bucket[i - 1]，表示多个盒子状态一致时，球放在哪个都不行，只需要尝试第一个盒子即可。</p>
<p>这个剪枝在出现<strong>状态重复</strong>时，可以达到很好优化效果</p>
<h2 id="五-回溯算法的变体："><a href="#五-回溯算法的变体：" class="headerlink" title="五.回溯算法的变体："></a>五.回溯算法的变体：</h2><p>针对场景：有时我们并不需要遍历到终点的全部路径，我们只需要判断是否存在一条路径到终点，这时遍历到终点就不需要回溯了。（剪枝的一种）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line">def <span class="type">boolean</span> <span class="title function_">backtrack</span><span class="params">(路径, 选择列表)</span>:</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> 选择 in 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        <span class="keyword">if</span>(backtrack(路径, 选择列表))&#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="comment">//这一步的实现很巧妙，如果返回值为true那么接下来的选择都不要了，如果为false则遍历其他选择</span></span><br><span class="line">        撤销选择</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<h2 id="六-回溯与图的深度优先搜索的区别"><a href="#六-回溯与图的深度优先搜索的区别" class="headerlink" title="六.回溯与图的深度优先搜索的区别"></a>六.回溯与图的深度优先搜索的区别</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码1</span></span><br><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">ans = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">path.add(<span class="number">0</span>);</span><br><span class="line">dfs(<span class="number">0</span>,path,V-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> v,LinkedList&lt;Integer&gt; path,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v == end)&#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> w:adj[v])&#123;</span><br><span class="line">            path.addLast(w);</span><br><span class="line">            dfs(w,path,end);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///------------------------------------------------------///</span></span><br><span class="line"><span class="comment">//代码2</span></span><br><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">ans = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">dfs(<span class="number">0</span>,path,V-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> v,LinkedList&lt;Integer&gt; path,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">    path.addLast(v);</span><br><span class="line">    <span class="keyword">if</span>(v == end)&#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> w:adj[v])&#123;</span><br><span class="line">            dfs(w,path,end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    path.removeLast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释：这两块代码都可以实现查找0到V-1的所有路径。</p>
<p>区别：代码一在循环中进行回溯，代码二在循环外（递归开始和结束）进行回溯；而且代码一的初始路径必须包含根节点。</p>
<p>回溯算法和 DFS 算法的区别所在：回溯算法关注的不是节点，而是树枝。因此使用代码一就不会包含根节点了。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/5-16869717187621.jpg" alt="img" style="zoom: 33%;" />

<h2 id="七-具体题型"><a href="#七-具体题型" class="headerlink" title="七.具体题型"></a>七.具体题型</h2><h3 id="1-排列组合"><a href="#1-排列组合" class="headerlink" title="1.排列组合"></a>1.排列组合</h3><h5 id="元素不重复不可复选"><a href="#元素不重复不可复选" class="headerlink" title="元素不重复不可复选"></a><strong>元素不重复不可复选</strong></h5><ul>
<li><p>组合：每次只能从大于i数中选择，即i &gt; start，可以避免重复选（实际上也是保持相对顺序）</p>
<p><a href="https://leetcode.cn/problems/subsets/">78. 子集</a>  <a href="https://leetcode.cn/problems/combinations/">77. 组合</a>  </p>
</li>
<li><p>排列：每次都会从0开始选择，并使用used数组避免重复选</p>
<p><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></p>
</li>
</ul>
<h5 id="元素可重不可复选"><a href="#元素可重不可复选" class="headerlink" title="元素可重不可复选"></a>元素可重不可复选</h5><p><a href="https://leetcode.cn/problems/subsets-ii/">90. 子集 II</a> <a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></p>
<p><a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II</a></p>
<ol>
<li><p>不使用set</p>
<ul>
<li><p>组合：<strong>只要未选中的重复元素的索引最小的元素。</strong>每次只能从大于i数中选择，且每次从未选中的重复元素（同一父节点分支）选择时，只要未选中的重复元素的索引最小的元素。即重复元素在一次分支中只会选择一次。</p>
<p>剪枝 i &gt; start &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]</p>
</li>
<li><p>排列：<strong>保证相同元素在排列中的相对位置保持不变</strong> ++++2+++2’+++2’’++++</p>
<p>剪枝：</p>
<p>used[i];</p>
<p>i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1] &amp;&amp; !used[i - 1]；</p>
</li>
</ul>
</li>
<li><p>使用set</p>
<p>排列问题：可以不需要排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++) &#123;<span class="comment">//排列</span></span><br><span class="line">    <span class="keyword">if</span>(set.contains(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(used[i]) <span class="keyword">continue</span>;</span><br><span class="line">    set.add(nums[i]);</span><br><span class="line">    backtrace;</span><br><span class="line">    <span class="comment">//set不需要回溯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组合问题：需要先排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort();</span><br><span class="line">HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;i &lt; nums.length;i++) &#123;<span class="comment">//组合</span></span><br><span class="line">    <span class="keyword">if</span>(set.contains(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">//set不需要回溯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="元素无重可复选"><a href="#元素无重可复选" class="headerlink" title="元素无重可复选"></a>元素无重可复选</h5><p>组合：easy</p>
<p>排列：</p>
<p>回溯+备忘录：</p>
<p>动态规划：快，缺点是只能算出种类，不能打印每一种的形式</p>
<h3 id="2-棋盘"><a href="#2-棋盘" class="headerlink" title="2.棋盘"></a>2.棋盘</h3><p>一维递归：<a href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrace</span><span class="params">(<span class="type">char</span>[][] board,<span class="type">int</span> row,<span class="type">int</span> n)</span> &#123;<span class="comment">//行作为递归深度</span></span><br><span class="line">    <span class="keyword">if</span>(row == n) &#123;</span><br><span class="line">        ans.add(transfer(board));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>;col &lt; n;col++) &#123;<span class="comment">//列作为水平宽度</span></span><br><span class="line">        <span class="keyword">if</span>(!isValid(board, row, col)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        backtrace(board, row + <span class="number">1</span>, n);</span><br><span class="line">        board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二维递归：<a href="https://leetcode.cn/problems/sudoku-solver/">37. 解数独</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">traceback</span><span class="params">(<span class="type">char</span>[][] board,<span class="type">int</span> row,<span class="type">int</span> col)</span> &#123;<span class="comment">//行列都作为递归深度，实际上的递归深度为row * col</span></span><br><span class="line">    <span class="comment">//结束条件</span></span><br><span class="line">    <span class="keyword">if</span>(row == board.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下一次递归的参数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextCol</span> <span class="operator">=</span> col;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nextRow</span> <span class="operator">=</span> row;</span><br><span class="line">    <span class="keyword">if</span>(col &lt; board[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">        nextCol++;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        nextCol = <span class="number">0</span>;</span><br><span class="line">        nextRow++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//剪掉不为.的枝</span></span><br><span class="line">    <span class="keyword">if</span>(board[row][col] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">return</span> traceback(board, nextRow, nextCol);</span><br><span class="line">    <span class="comment">//水平</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>;k &lt; <span class="number">10</span>;k++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ck</span> <span class="operator">=</span> (<span class="type">char</span>)(k + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!isValid(board, row, col, ck)) <span class="keyword">continue</span>;</span><br><span class="line">        board[row][col] = ck;</span><br><span class="line">        <span class="keyword">if</span>(traceback(board, nextRow, nextCol)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同一3*3格（精髓）</span></span><br><span class="line"><span class="type">int</span> <span class="variable">initI</span> <span class="operator">=</span> (row/<span class="number">3</span>)*<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">initJ</span> <span class="operator">=</span> (col/<span class="number">3</span>)*<span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> initI;i &lt; initI+<span class="number">3</span>;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> initJ;j &lt; initJ+<span class="number">3</span>;j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(board[i][j] == value) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-球盒模型"><a href="#3-球盒模型" class="headerlink" title="3.球盒模型"></a>3.球盒模型</h3><p>球盒模型的特点是，球和盒需要选择一个作为递归深度，一个作为水平宽度。</p>
<p>选择的依据：假设一个回溯算法的递归深度为k，每次递归有n个选择，那么时间复杂度为$n^k$。因此当递归深度与选择可以互换时，应该取值较小的作为递归深度。</p>
<p><a href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/">698. 划分为k个相等的子集</a> √</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*数字作为递归深度，桶作为水平宽度*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartitionKSubsets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) sum += nums[i];</span><br><span class="line">    <span class="keyword">if</span> (sum % k != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum / k;</span><br><span class="line">    <span class="comment">// 排序优化</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[l];</span><br><span class="line">        nums[l] = nums[r];</span><br><span class="line">        nums[r] = temp;</span><br><span class="line">        l++;</span><br><span class="line">        r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> backtrack(nums, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">int</span>[k], k, target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*每一层递归都代表一个数字，选择进入哪个桶*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index, <span class="type">int</span>[] bucket, <span class="type">int</span> k, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// 结束条件优化</span></span><br><span class="line">    <span class="keyword">if</span> (index == nums.length) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="comment">// 优化点二 ！！！！这个剪枝很重要，没有这个剪枝这个算法会超时</span></span><br><span class="line">        <span class="comment">// 能走到这一步说明之前桶没有成功，如果当前桶和之前桶相等，那么当前桶也没有必要继续了</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; bucket[i] == bucket[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (bucket[i] + nums[index] &gt; target) <span class="keyword">continue</span>;</span><br><span class="line">        bucket[i] += nums[index];</span><br><span class="line">        <span class="keyword">if</span> (backtrack(nums, index + <span class="number">1</span>, bucket, k, target)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        bucket[i] -= nums[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*桶作为递归深度，数字作为选择*/</span></span><br><span class="line"><span class="comment">/*注：桶的数量并不等于递归的深度，因为桶可以装多个数字，所以不同层的递归用的可能是同一个桶*/</span></span><br><span class="line"><span class="comment">// 备忘录，存储 used 的状态</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Integer, Boolean&gt; memo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartitionKSubsets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) sum += nums[i];</span><br><span class="line">    <span class="keyword">if</span> (sum % k != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum / k;</span><br><span class="line">    <span class="comment">// 使用位图技巧</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">used</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[k + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> backtrack(nums, <span class="number">0</span>, bucket, k, target, used);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*每一层递归都代表某个桶，选择把哪个数字装进来*/</span></span><br><span class="line"><span class="comment">/*注：这里最重要的剪枝是start，与去掉start，i = 0对比*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span>[] bucket, <span class="type">int</span> k, <span class="type">int</span> target, <span class="type">int</span> used)</span> &#123;</span><br><span class="line">    <span class="comment">// k 个桶均装满</span></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前桶装满了，开始装下一个桶</span></span><br><span class="line">    <span class="keyword">if</span> (bucket[k] == target) &#123;</span><br><span class="line">        <span class="comment">// 注意：桶从下一个开始；球从第一个开始****！！！！！*****</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> backtrack(nums, <span class="number">0</span>, bucket, k - <span class="number">1</span>, target, used);</span><br><span class="line">        memo.put(used, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (memo.containsKey(used)) &#123;</span><br><span class="line">        <span class="comment">// 如果当前状态曾今计算过，就直接返回，不要再递归穷举了</span></span><br><span class="line">        <span class="keyword">return</span> memo.get(used);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第 k 个桶开始对每一个球选择进行选择是否装入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前球已经被装入，则跳过</span></span><br><span class="line">        <span class="keyword">if</span> (((used &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 如果装入当前球，桶溢出，则跳过</span></span><br><span class="line">        <span class="keyword">if</span> (bucket[k] + nums[i] &gt; target) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 装入 &amp;&amp; 标记已使用</span></span><br><span class="line">        bucket[k] += nums[i];</span><br><span class="line">        <span class="comment">// 将第 i 位标记为 1</span></span><br><span class="line">        used |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始判断是否选择下一个球</span></span><br><span class="line">        <span class="comment">// 注意：桶依旧是当前桶；球是下一个球</span></span><br><span class="line">        <span class="comment">// 注意：是 i + 1</span></span><br><span class="line">        <span class="keyword">if</span> (backtrack(nums, i + <span class="number">1</span>, bucket, k, target, used)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿出 &amp;&amp; 标记未使用</span></span><br><span class="line">        bucket[k] -= nums[i];</span><br><span class="line">        <span class="comment">// 将第 i 位标记为 0</span></span><br><span class="line">        used ^= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果所有球均不能使所有桶刚好装满</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/fair-distribution-of-cookies/">2305. 公平分发饼干</a> 二分查找 + 回溯</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//回溯</span></span><br><span class="line"><span class="type">int</span> <span class="variable">minSum</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">distributeCookies</span><span class="params">(<span class="type">int</span>[] cookies, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">//求平均值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(cookies).sum();</span><br><span class="line">    <span class="type">int</span> <span class="variable">average</span> <span class="operator">=</span> sum / k;</span><br><span class="line">    <span class="comment">//排序，从大到小</span></span><br><span class="line">    Arrays.sort(cookies);</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = cookies.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> cookies[left];</span><br><span class="line">        cookies[left] = cookies[right];</span><br><span class="line">        cookies[right] = temp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] buckets = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">    traceback(cookies, <span class="number">0</span>, buckets,average);</span><br><span class="line">    <span class="keyword">return</span> minSum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traceback</span><span class="params">(<span class="type">int</span>[] cookies,<span class="type">int</span> index,<span class="type">int</span>[] buckets,<span class="type">int</span> average)</span> &#123;<span class="comment">//cookies为深度，k为选择</span></span><br><span class="line">    <span class="comment">//结束条件</span></span><br><span class="line">    <span class="keyword">if</span>(index == cookies.length) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> bucket:buckets) &#123;</span><br><span class="line">            maxSum = Math.max(bucket, maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        minSum = Math.min(maxSum, minSum);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//选择</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; buckets.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; buckets[i] == buckets[i - <span class="number">1</span>]) <span class="keyword">continue</span>;<span class="comment">//剪枝2</span></span><br><span class="line">        <span class="keyword">if</span>(buckets[i] &gt;= average) <span class="keyword">continue</span>;<span class="comment">//剪枝1</span></span><br><span class="line"></span><br><span class="line">        buckets[i] += cookies[index];</span><br><span class="line">        traceback(cookies, index + <span class="number">1</span>, buckets, average);</span><br><span class="line">        buckets[i] -= cookies[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二分查找 + 回溯</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">distributeCookies</span><span class="params">(<span class="type">int</span>[] cookies, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">//排序，从大到小</span></span><br><span class="line">    Arrays.sort(cookies);	</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = cookies.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> cookies[left];</span><br><span class="line">        cookies[left] = cookies[right];</span><br><span class="line">        cookies[right] = temp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二分查找确定minSum</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> cookies[<span class="number">0</span>],hi = Arrays.stream(cookies).sum();</span><br><span class="line">    <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] buckets = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">if</span>(traceback(cookies,<span class="number">0</span>,buckets,mid)) &#123;</span><br><span class="line">            hi = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">traceback</span><span class="params">(<span class="type">int</span>[] cookies,<span class="type">int</span> index,<span class="type">int</span>[] buckets,<span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">//结束条件</span></span><br><span class="line">    <span class="keyword">if</span>(index == cookies.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//选择</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; buckets.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; buckets[i] == buckets[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(buckets[i] + cookies[index] &gt; target) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        buckets[i] += cookies[index];</span><br><span class="line">        <span class="keyword">if</span>(traceback(cookies, index + <span class="number">1</span>, buckets, target)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buckets[i] -= cookies[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/find-minimum-time-to-finish-all-jobs/">1723. 完成所有工作的最短时间</a> 二分查找 + 回溯</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-04-17-图论</title>
    <url>/posts/d7ba.html</url>
    <content><![CDATA[<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="一-存图方式"><a href="#一-存图方式" class="headerlink" title="一.存图方式"></a>一.存图方式</h2><p>主要有两种邻接矩阵和邻接表</p>
<p>邻接矩阵：适用于边数较多的稠密图使用，当边数量接近点的数量的平方，$m &#x3D; n^2$，邻接矩阵比较简单就不展示了。而且一般算法不会使用邻接矩阵，Floyd会使用。</p>
<p>邻接表：适用于边数较少的稀疏图使用，当边数量接近点的数量，$m &#x3D; n$</p>
 <span id="more"></span>

<ul>
<li><p>无向图：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt;[] adj;    adj[<span class="number">0</span>] = List(&#123;<span class="number">1</span>&#125;);		adj[<span class="number">1</span>] = List(&#123;<span class="number">0</span>&#125;)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//二维数组</span></span><br><span class="line"><span class="type">int</span>[][] g; g[<span class="number">0</span>]=&#123;<span class="number">1</span>&#125; , g[<span class="number">1</span>]=&#123;<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有向图：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt;[] adj;    adj[<span class="number">0</span>] = List(&#123;<span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组</span></span><br><span class="line"><span class="type">int</span>[][] g; g[<span class="number">0</span>]=&#123;<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>加权图：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用类来表示边</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> v/from;</span><br><span class="line">    <span class="type">int</span> w/to;</span><br><span class="line">    <span class="type">int</span> weigth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//无向加权图，对于无向图来说一个Edge对象会在adj中存在两份</span></span><br><span class="line">List&lt;Edge&gt;[] adj;</span><br><span class="line"><span class="comment">//有向加权图，对于有向图来说一个Edge对象只会在adj中存在一份</span></span><br><span class="line">List&lt;Edge&gt;[] adj;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注：二维数组的表示方法一般是题目给定的，需要自己构造时不建议使用二维数组，因为我们不知道边的数量，因此无法设置数组的大小。</p>
<p>还有一种特殊的图，一般为矩阵或者棋盘，这种虽然不属于上面的存图方式，但是不需要重新存图，因为每个点的邻接点都是在上下左右，直接遍历即可<a href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] direct = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//棋盘大小为m*n，深搜四个方向</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">DFS</span><span class="params">(<span class="type">int</span>[][] grid,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    grid[i][j] = <span class="number">0</span>;<span class="comment">//作用类似used数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>[] dir:direct)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> i + dir[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> j + dir[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[x][y] == <span class="number">1</span>)&#123;</span><br><span class="line">                area += DFS(grid,x,y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二-算法"><a href="#二-算法" class="headerlink" title="二.算法"></a>二.算法</h2><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p><a href="https://leetcode.cn/problems/keys-and-rooms/">841. 钥匙和房间</a></p>
<ul>
<li><p>深度优先：</p>
<ul>
<li><p>连通分量（无向图）：</p>
<p><a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a> dfs bfs 并查集</p>
<p><a href="https://leetcode.cn/problems/number-of-enclaves/">1020. 飞地的数量</a></p>
</li>
<li><p>二分图（无向图）:</p>
<p>二分图的充要条件：G至少有两个顶点,如果有回路则其所有回路的长度均为偶数。<strong>任何无回路的的图均是二分图</strong></p>
<p>程序中是如何判断二分图的？通过模拟上色的步骤。使用dfs算法，保证每次上色都使用与上一次上色不一样的颜色。如果在某个顶点上色完成后，下一个顶点已经上完色过，而且与它相同，那就不是二分图。</p>
<p><a href="https://leetcode.cn/problems/is-graph-bipartite/">785. 判断二分图</a></p>
<p><a href="https://leetcode.cn/problems/possible-bipartition/">886. 可能的二分法</a></p>
</li>
<li><p>环检测（无向图,有向图）:</p>
<p>无向图：只使用visited数组<br>有向图：需要使用visited数组+path数组</p>
<p><a href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a> 环检测</p>
</li>
<li><p>寻找路径(无向图,有向图)：</p>
<p>如果需要记下目前路径上的结点，可以使用<strong>回溯</strong>的方法维护一个外部变量</p>
<p>如果需要记录每个结点到起点s的路径，可以使用edgeTo[子节点]&#x3D;父节点</p>
<p><a href="https://leetcode.cn/problems/all-paths-from-source-to-target/">797. 所有可能的路径</a></p>
</li>
</ul>
</li>
<li><p>广度优先：</p>
<p>广度优先搜索天生支持最短路径(无向图，有向图)<br>它的实现是队列，<strong>在入队时标记</strong>，而不是在出队时再标记。<br>bfs不使用递归，而是循环</p>
<p><a href="https://leetcode.cn/problems/01-matrix/">542. 01 矩阵</a> 矩阵 bfs</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230823175711326.png" alt="image-20230823175711326" style="zoom:80%;" /></li>
</ul>
<h3 id="逆后序遍历（深度优先的变种）："><a href="#逆后序遍历（深度优先的变种）：" class="headerlink" title="逆后序遍历（深度优先的变种）："></a>逆后序遍历（深度优先的变种）：</h3><ul>
<li><p>简介：</p>
<ul>
<li>深度优先次序：深度优先搜索正好只会访问每个顶点一次，在递归调用之前还是之后进行保存，可以分成三种顺序：</li>
<li>前序:在递归调用之前将顶点加入队列；后序:在递归调用之后将顶点加入队列；逆后序:在递归调用之后将顶点压入栈。</li>
</ul>
</li>
<li><p>拓扑排序（有向图）：拓扑排序的充要条件是无环</p>
<ul>
<li><p>逆后序解法：一幅有向无环图的拓扑顺序即为所有顶点的逆后序排列，因为递归后面的顶点时出度为0的点，需要使用一个path数组判断无环。</p>
</li>
<li><p>bfs角度的解法：<br>引入一个indegree数组，储存某个顶点目前有多少个顶点指着它（入度）<br>bfs：indegree为0时入队，出队时使这个顶点周围的顶点的入度-1（相当于假删除这个顶点）<br>判断环的定理如下：如果这个图存在环，那么环中的点的入度永远不会为0（始终有顶点指着它），即在bfs遍历结束时有些顶点没有遍历到</p>
<p><a href="https://leetcode.cn/problems/course-schedule-ii/">210. 课程表 II</a> √</p>
</li>
</ul>
</li>
<li><p>强连通分量（有向图）：</p>
<p>先求出图的逆后序遍历的结果</p>
<p>根据逆后序的顺序深度优先，对于那些在同一个深度优先遍历中遍历到结点属于同一个强连通分量</p>
</li>
</ul>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] id;</span><br><span class="line">    UF(<span class="type">int</span> len)&#123;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">proot</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">qroot</span> <span class="operator">=</span> find(q);</span><br><span class="line">        id[proot] = qroot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> p)</span>&#123;<span class="comment">//优化版，树的高度只有1</span></span><br><span class="line">        <span class="keyword">if</span>(id[p] != p) id[p] = find(id[p]);</span><br><span class="line">        <span class="keyword">return</span> id[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnect</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/satisfiability-of-equality-equations/">990. 等式方程的可满足性</a></p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230616150434489.png" alt="image-20230616150434489" style="zoom:80%;" />

<h3 id="最小生成树-无向加权图"><a href="#最小生成树-无向加权图" class="headerlink" title="最小生成树(无向加权图)"></a>最小生成树(无向加权图)</h3><p>Kruskal：主要思想是按照边的权重顺序（从小到大）处理它们， 将边加入最小生成树中（图中的黑色边），加入的边不会与已经加入的边构成环，直到树中含有 V-1 条边为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KruskalMST</span> <span class="keyword">implements</span> <span class="title class_">MST</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> LinkedQueue&lt;Edge&gt; edges;</span><br><span class="line">	<span class="keyword">private</span> PriorityQueue&lt;Edge&gt; pq;</span><br><span class="line">	<span class="keyword">private</span> UF uf;  <span class="comment">//作用同Prim中的marked</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">KruskalMST</span><span class="params">(EdgeWeightedGraph G)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		edges = <span class="keyword">new</span> <span class="title class_">LinkedQueue</span>&lt;Edge&gt;();</span><br><span class="line">		pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Edge&gt;();</span><br><span class="line">		uf = <span class="keyword">new</span> <span class="title class_">UF</span>(G.V());</span><br><span class="line">		<span class="keyword">for</span>(Edge e:G.edges())</span><br><span class="line">			pq.insert(e);</span><br><span class="line">		<span class="keyword">while</span>(!pq.isEmpty()&amp;&amp;edges.size()&lt;G.V()-<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="type">Edge</span> <span class="variable">minEdge</span> <span class="operator">=</span> pq.delMin();</span><br><span class="line">			<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> minEdge.either();</span><br><span class="line">			<span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> minEdge.other(v);</span><br><span class="line">			<span class="keyword">if</span>(!uf.connected(v, w)) &#123;</span><br><span class="line">				edges.push(minEdge);</span><br><span class="line">				uf.union(v, w);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/min-cost-to-connect-all-points/">1584. 连接所有点的最小费用</a></p>
<p>Prim：一开始这棵树只有一个顶点，然后会向它添加 V-1 条边，每次总是将下一条连接树中的顶点与不在树中的顶点且权重最小的边（黑色表示）加入树中（即由树中的顶点所定义的切分 中的一条横切边）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyPrim</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span>[] marked;</span><br><span class="line">	<span class="keyword">private</span> LinkedQueue&lt;Edge&gt; mst;<span class="comment">//用边表示生成树</span></span><br><span class="line">	<span class="keyword">private</span> PriorityQueue&lt;Edge&gt; pq;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">LazyPrim</span><span class="params">(EdgeWeightedGraph G)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">V</span> <span class="operator">=</span> G.V();</span><br><span class="line">		marked = <span class="keyword">new</span> <span class="title class_">boolean</span>[V];</span><br><span class="line">		mst = <span class="keyword">new</span> <span class="title class_">LinkedQueue</span>&lt;Edge&gt;();</span><br><span class="line">		pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Edge&gt;();</span><br><span class="line">		visit(G,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">while</span>(!pq.isEmpty()) &#123;</span><br><span class="line">			<span class="type">Edge</span> <span class="variable">minEdge</span> <span class="operator">=</span> pq.delMin();</span><br><span class="line">			<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> minEdge.v;</span><br><span class="line">			<span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> minEdge.w;</span><br><span class="line">			<span class="comment">//如果该边形成环，延迟删除的精髓</span></span><br><span class="line">			<span class="keyword">if</span>(marked[v]&amp;&amp;marked[w]) <span class="keyword">continue</span>;</span><br><span class="line">			mst.push(minEdge);</span><br><span class="line">			<span class="keyword">if</span>(!marked[v]) visit(G,v);</span><br><span class="line">			<span class="keyword">if</span>(!marked[w]) visit(G,w);</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//visit的作用是，生成树添加一条边后，对于新添加顶点所需要进行的操作</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(EdgeWeightedGraph G,<span class="type">int</span> v)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		marked[v] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(Edge e:G.adj(v)) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!marked[e.other(v)]) pq.insert(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最短路径（有向加权图）"><a href="#最短路径（有向加权图）" class="headerlink" title="最短路径（有向加权图）"></a>最短路径（有向加权图）</h3><ol>
<li><p>单源最短路径：</p>
<p>单源最短路径  以s为源，到达其他所有结点（s可达）的最短路径</p>
<p><a href="https://leetcode.cn/problems/network-delay-time/">743. 网络延迟时间</a> </p>
<ul>
<li><p>Dijkstra：不带负权重</p>
<p>Dijkstra可以看做是在bfs的基础上加了dp数组，而且会经过同一个点多次，onQ数组的作用与used数组不同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//朴素的Dijkstra算法（顶点）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DijkstraNormal</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> DirectedEdge[] edgeTo;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span>[] distTo;</span><br><span class="line">	<span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] OnQ;<span class="comment">//判断某个顶点是否在队列中</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;DirectedEdge&gt;[] adj;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">DijkstraNormal</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">		edgeTo = <span class="keyword">new</span> <span class="title class_">DirectedEdge</span>[V];</span><br><span class="line">		distTo = <span class="keyword">new</span> <span class="title class_">double</span>[V];</span><br><span class="line">		queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;V;i++)</span><br><span class="line">			distTo[i] = Double.POSITIVE_INFINITY;<span class="comment">//初始正无穷</span></span><br><span class="line">		distTo[s] = <span class="number">0.0</span>;</span><br><span class="line">		queue.add(s);</span><br><span class="line">        OnQ[s] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            OnQ[v] = <span class="literal">false</span>;</span><br><span class="line">			relax(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">relax</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(DirectedEdge e : adj[v]) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> e.to();</span><br><span class="line">			<span class="keyword">if</span>(distTo[w]&gt;distTo[v]+e.weight()) &#123;</span><br><span class="line">				edgeTo[w] = e;</span><br><span class="line">				distTo[w]=distTo[v]+e.weight();</span><br><span class="line">				<span class="keyword">if</span>(!OnQ[w]) &#123;</span><br><span class="line">                    queue.add(w);</span><br><span class="line">                    OnQ[w] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//堆优化的Dijkstra算法（边）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DijkstraOptEdge</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> DirectedEdge[] edgeTo;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span>[] distTo;</span><br><span class="line">	<span class="keyword">private</span> PriorityQueue&lt;DirectedEdge&gt; pq;</span><br><span class="line">    <span class="keyword">private</span> List&lt;DirectedEdge&gt;[] adj;</span><br><span class="line">    <span class="comment">//这里实际上是通过pq自带的contain方法来判断某条边是否在队列中，由于堆中找一个元素比较快，可以不使用OnQ</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">DijkstraOptEdge</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">		edgeTo = <span class="keyword">new</span> <span class="title class_">DirectedEdge</span>[V];</span><br><span class="line">		distTo = <span class="keyword">new</span> <span class="title class_">double</span>[V];</span><br><span class="line">		pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;DirectedEdge&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(DirectedEdge edge1, DirectedEdge edge2)</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> (<span class="type">int</span>)(edge1.weight() - edge2.weight());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;V;i++)</span><br><span class="line">			distTo[i] = Double.POSITIVE_INFINITY;</span><br><span class="line">		distTo[s] = <span class="number">0.0</span>;</span><br><span class="line">		<span class="type">DirectedEdge</span> <span class="variable">init</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DirectedEdge</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.0</span>);</span><br><span class="line">		pq.add(init);</span><br><span class="line">		<span class="keyword">while</span>(!pq.isEmpty()) &#123;</span><br><span class="line">			relax(G,pq.poll().to());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">relax</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(DirectedEdge e : adj[v]) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> e.to();</span><br><span class="line">			<span class="keyword">if</span>(distTo[w]&gt;distTo[v]+e.weight()) &#123;</span><br><span class="line">				edgeTo[w] = e;</span><br><span class="line">				distTo[w]=distTo[v]+e.weight();</span><br><span class="line">				<span class="keyword">if</span>(!pq.contains(e)) pq.add(e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如何选取？</span></span><br><span class="line"><span class="comment">//1.朴素的D算法，队列中可以储存顶点。堆优化的D算法，堆中必须储存边</span></span><br><span class="line"><span class="comment">//2.当边的数量与顶点差不多时，使用堆优化的D算法。当边的数量远大于顶点的数量时，使用朴素的D算法。因为边太多时，维护堆的成本会提高。</span></span><br><span class="line"><span class="comment">//3.对于堆优化的D算法，第一次到达end就可以认为是最短路径了</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>BellmanFord：可以带负权重</p>
<p><a href="https://zhuanlan.zhihu.com/p/352724346">https://zhuanlan.zhihu.com/p/352724346</a></p>
<p>Bellman-Ford算法是一种处理存在负权边的单元最短路问题的算法。解决了Dijkstra无法求的存在负权边的问题。虽然其算法效率不高，但是也有其特别的用处。其实现方式是通过m次(一般是V-1次)迭代求出从源点到终点不超过m条边构成的最短路的路径。一般情况下要求途中不存在<strong>负环</strong>。但是在边数有限制的情况下允许存在负环，因此Bellman-Ford算法可以判断负环。（注：因为Bellman-Ford算法给出了路径数m的限制，所以不会求负环时不会无限循环）</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//朴素的BellmanFord，如果s点到n点中间存在负环或者本身不可达，那么distTo[n]就为负无穷</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BellmanFord</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> DirectedEdge[] edgeTo;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span>[] distTo;</span><br><span class="line">    <span class="keyword">private</span> List&lt;DirectedEdge&gt;[] adj;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BellmanFord</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">		edgeTo = <span class="keyword">new</span> <span class="title class_">DirectedEdge</span>[V];</span><br><span class="line">		distTo = <span class="keyword">new</span> <span class="title class_">double</span>[V];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;V;i++)</span><br><span class="line">			distTo[i] = Double.POSITIVE_INFINITY;</span><br><span class="line">		distTo[s] = <span class="number">0.0</span>;</span><br><span class="line">		<span class="type">DirectedEdge</span> <span class="variable">init</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DirectedEdge</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.0</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;p &lt; V;p++)&#123;</span><br><span class="line">            relax();</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">relax</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] prev = dist.clone(); <span class="comment">// 每次都使用上一次迭代的结果，执行松弛操作</span></span><br><span class="line">        <span class="keyword">for</span>(List&lt;DirectedEdge&gt; edges: adj)&#123; <span class="comment">//每次遍历所有边</span></span><br><span class="line">        	<span class="keyword">for</span>(DirectedEdge edge.:edges)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> edge.from();</span><br><span class="line">                <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> edge.to();</span><br><span class="line">                <span class="type">int</span> <span class="variable">weigth</span> <span class="operator">=</span> edge.weigth();</span><br><span class="line">                <span class="keyword">for</span>(prev[v] + weigth &lt; dist[w])&#123;</span><br><span class="line">                    edgeTo[w] = edge;</span><br><span class="line">                    dist[w] = prev[v] + weigth;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队列优化的BellmanFord（SPFA）说实话，感觉就是朴素的Dijkstra算法，代码参考上面</span></span><br><span class="line"><span class="comment">//注：该算法在存在负环时会无限循环，如果有负环建议还是使用上面的</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>多源最短路径：</p>
<p>多源最短路径  所有顶点都可以是源，各个源到达其他所有点的最短路径</p>
<p><a href="https://leetcode.cn/problems/cheapest-flights-within-k-stops/">787. K 站中转内最便宜的航班</a></p>
<p>Floyd：一般使用邻接矩阵的方法进行存图</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// floyd 基本流程为三层循环：</span></span><br><span class="line"><span class="comment">// 枚举中转点 - 枚举起点 - 枚举终点 - 松弛操作  </span></span><br><span class="line"><span class="comment">// 实际上，里循环就已经完整的遍历一次矩阵了</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;k &lt; n;k++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; n;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">            adj[i][j] = Math.min(adj[i][k]+adj[k][j], adj[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三-特殊"><a href="#三-特殊" class="headerlink" title="三.特殊"></a>三.特殊</h2><p>图的度可以反映某些信息。<a href="https://leetcode.cn/problems/D9PW8w/">LCP 62. 交通枢纽</a></p>
<p>图的深拷贝。<a href="https://leetcode.cn/problems/clone-graph/">133. 克隆图</a></p>
<p>图的应用 <a href="https://leetcode.cn/problems/evaluate-division/">399. 除法求值</a> &#x2F;&#x2F;图的另一种表示方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">图 + 深度优先搜索</span></span><br><span class="line"><span class="comment">1.a -2&gt; b -3&gt; c 用双向图来表示</span></span><br><span class="line"><span class="comment">  a &lt;1/2- b &lt;1/3- c </span></span><br><span class="line"><span class="comment">2.搜索[a,c]</span></span><br><span class="line"><span class="comment">先检查a,c是否都是图中的结点，否则返回-1</span></span><br><span class="line"><span class="comment">如果是，先找到结点a，如何搜索c的同时把路径乘起来就是答案</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">        String v;</span><br><span class="line">        String w;</span><br><span class="line">        <span class="type">double</span> weight;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(String v,String w,<span class="type">double</span> weight)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.v = v;</span><br><span class="line">            <span class="built_in">this</span>.w = w;</span><br><span class="line">            <span class="built_in">this</span>.weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> <span class="variable">ResSum</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="type">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">queriesLen</span> <span class="operator">=</span> queries.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">equationsLen</span> <span class="operator">=</span> equations.size();</span><br><span class="line">        <span class="type">double</span>[] ans = <span class="keyword">new</span> <span class="title class_">double</span>[queriesLen];</span><br><span class="line">        <span class="comment">//图数据结构</span></span><br><span class="line">        HashMap&lt;String,List&lt;Edge&gt;&gt; adj = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; node = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//构建图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; equationsLen;i++)&#123;</span><br><span class="line">            List&lt;String&gt; equation = equations.get(i);</span><br><span class="line">            <span class="type">String</span> <span class="variable">v</span> <span class="operator">=</span> equation.get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">w</span> <span class="operator">=</span> equation.get(<span class="number">1</span>);</span><br><span class="line">            node.add(v);</span><br><span class="line">            node.add(w);</span><br><span class="line">            <span class="type">Edge</span> <span class="variable">edgeV</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Edge</span>(v,w,values[i]);<span class="comment">//正向边</span></span><br><span class="line">            <span class="type">Edge</span> <span class="variable">edgeW</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Edge</span>(w,v,<span class="number">1</span>/values[i]);<span class="comment">//反向边</span></span><br><span class="line">            List&lt;Edge&gt; edgeVList = adj.getOrDefault(v,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Edge&gt;());</span><br><span class="line">            edgeVList.add(edgeV);</span><br><span class="line">            adj.put(v,edgeVList);</span><br><span class="line">            List&lt;Edge&gt; edgeWList = adj.getOrDefault(w,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Edge&gt;());</span><br><span class="line">            edgeWList.add(edgeW);</span><br><span class="line">            adj.put(w,edgeWList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//搜索[a,c]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i &lt; queriesLen;i++)&#123;</span><br><span class="line">            List&lt;String&gt; querie = queries.get(i);</span><br><span class="line">            <span class="type">String</span> <span class="variable">start</span> <span class="operator">=</span> querie.get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">end</span> <span class="operator">=</span> querie.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(!node.contains(start) || !node.contains(end)) &#123;</span><br><span class="line">                ans[i] = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;String&gt; marked = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">            ResSum = -<span class="number">1</span>;</span><br><span class="line">            dfs(adj,marked,<span class="number">1.0</span>,start,end);</span><br><span class="line">            ans[i] = ResSum;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回乘积</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(HashMap&lt;String,List&lt;Edge&gt;&gt; adj,Set&lt;String&gt; marked,<span class="type">double</span> pathSum,String v,String end)</span>&#123;</span><br><span class="line">        marked.add(v);</span><br><span class="line">        <span class="keyword">if</span>(v.equals(end)) ResSum = pathSum;</span><br><span class="line">        <span class="keyword">for</span>(Edge edge:adj.get(v))&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">w</span> <span class="operator">=</span> edge.w;</span><br><span class="line">            <span class="type">double</span> <span class="variable">weight</span> <span class="operator">=</span> edge.weight;</span><br><span class="line">            <span class="keyword">if</span>(!marked.contains(w))&#123;</span><br><span class="line">                dfs(adj,marked,pathSum*weight,w,end); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>堆优化的Dijkstra算法 堆中比较的不是边权重 实际上可以是更抽象的东西 它决定了遍历的方向 <a href="https://leetcode.cn/problems/path-with-minimum-effort/">1631. 最小体力消耗路径</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-04-24-堆(优先队列)+加权图</title>
    <url>/posts/f27d.html</url>
    <content><![CDATA[<h2 id="1-固定大小的优先队列-数据流。"><a href="#1-固定大小的优先队列-数据流。" class="headerlink" title="1.固定大小的优先队列 + 数据流。"></a>1.固定大小的优先队列 + 数据流。</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;ListNode&gt; pq =<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(maxSize,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;ListNode&gt;()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(ListNode a,ListNode b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.val - b.val;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>固定大小的大根堆：</p>
<p>固定大小的小跟堆：</p>
<p><a href="https://leetcode.cn/problems/find-median-from-data-stream/">295. 数据流的中位数</a> 数据流中的中位数</p>
<p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并 K 个升序链表</a> 单链表 dummy 插入 优先队列</p>
<p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素 </a> 优先队列&#x2F;快排</p>
<p><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a> 优先队列&#x2F;单调队列</p>
<p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a> 优先队列 哈希表</p>
<p><a href="https://leetcode.cn/problems/sort-an-array/">912. 排序数组</a> 堆排序</p>
 <span id="more"></span>

<h2 id="2-优先队列常用来实现加权图算法"><a href="#2-优先队列常用来实现加权图算法" class="headerlink" title="2.优先队列常用来实现加权图算法"></a>2.优先队列常用来实现加权图算法</h2><ul>
<li><p>加权无向图的最小生成树：</p>
<ul>
<li>prim算法</li>
<li>Kruskal算法</li>
</ul>
</li>
<li><p>加权有向图的Dijkstra算法啊（堆优化）</p>
<p>稠密图不要用优先级队列优化，此题看数据应该是稠密图，用优先级队列反而可能会耗时更长</p>
</li>
</ul>
<p><a href="https://leetcode.cn/problems/cheapest-flights-within-k-stops/">787. K 站中转内最便宜的航班</a> 有向加权图 Dijkstra算法&#x2F;Bellman</p>
<p><a href="https://leetcode.cn/problems/path-with-minimum-effort/">1631. 最小体力消耗路径</a> 矩阵 Dijkstra算法</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-04-30-贪心</title>
    <url>/posts/fb6e.html</url>
    <content><![CDATA[<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="一-概念"><a href="#一-概念" class="headerlink" title="一.概念"></a>一.概念</h2><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优</strong>。</p>
<p>这么说有点抽象，来举一个例子：</p>
<p>例如，有一堆钞票，你可以拿走十张，如果想达到最大的金额，你要怎么拿？</p>
<p>指定每次拿最大的，最终结果就是拿走最大数额的钱。</p>
<p>每次拿最大的就是局部最优，最后拿走最大数额的钱就是推出全局最优。</p>
 <span id="more"></span>

<h2 id="二-贪心的套路"><a href="#二-贪心的套路" class="headerlink" title="二.贪心的套路"></a>二.贪心的套路</h2><p><strong>贪心算法并没有固定的套路</strong>。唯一的难点就是如何通过局部最优，推出整体最优。</p>
<p>靠自己手动模拟，如果模拟可行，就可以试一试贪心策略，如果不可吗 行，可能需要动态规划。</p>
<h5 id="1-动态规划与贪心？"><a href="#1-动态规划与贪心？" class="headerlink" title="1.动态规划与贪心？"></a>1.动态规划与贪心？</h5><p>动态规划与贪心的最大区别在于：动态规划的某一个状态值在后续的遍历过程是可以改变的，具有叠加效应；而贪心的状态值一但确定就是最优值，后续不会改变。</p>
<p>因此动态规划的时间复杂度是$n^2$级别的</p>
<p>例如，以上面的钞票为例，拿走某一张之后，会出现一些限制条件，比如必须隔一张拿一张，这就涉及了状态的转换，即选择不同的钞票会陷入不同的状态，不同的状态又决定了不同的选择，也就是<strong>动态规划</strong>了。</p>
<p>动态规划也是局部最优到全局最优，一道题可能有动态规划和贪心两种做法。</p>
<h5 id="2-如何确定贪心？"><a href="#2-如何确定贪心？" class="headerlink" title="2.如何确定贪心？"></a>2.如何确定贪心？</h5><p>一般来说，能否使用贪心是需要严格的数学证明的，但是实际做题中，<strong>手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心</strong>。</p>
<h2 id="三-具体题目"><a href="#三-具体题目" class="headerlink" title="三.具体题目"></a>三.具体题目</h2><p><a href="https://leetcode.cn/problems/assign-cookies/">455. 分发饼干</a> 贪心 排序</p>
<p><a href="https://leetcode.cn/problems/lemonade-change/">860. 柠檬水找零</a>  贪心 贪在每次找最大面额兑换</p>
<p><a href="https://leetcode.cn/problems/gas-station/">134. 加油站</a> 贪心 贪在只要最低谷过了，其他点也能过，因此目标是找到最低谷</p>
<p><a href="https://leetcode.cn/problems/wiggle-subsequence/">376. 摆动序列</a> 贪心&#x2F;动态规划</p>
<p>对山峰山谷的定义为，某个顶点的左边的趋势和他的右边的趋势是不同的</p>
<p>贪心贪的地方在于，某个顶点要么是山峰要么是山谷，要么是半山腰，而且一旦出现山峰山谷就立即选择，不会出现我不选这个山峰反而会增加山峰的情况。</p>
<p>实现：<br>遍历所有顶点<br>用preT表示左边的趋势，用nextT表示右边的趋势，如果不同，则为山谷或者山峰</p>
<p>为了避免平顶的情况，当右边为平趋时，不会更新左边的趋势</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="number">0</span>] == nums[<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//假设数组的第一个要么是山峰要么是山谷</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums.length - <span class="number">1</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(nums[i] - nums[i-<span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">				left = nums[i] - nums[i-<span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[i+<span class="number">1</span>] - nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                right = nums[i+<span class="number">1</span>] - nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="keyword">if</span>((left &lt; <span class="number">0</span> &amp;&amp; right &gt; <span class="number">0</span>)||(left &gt; <span class="number">0</span> &amp;&amp; right &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">				result++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//如果数组有起伏，那么最后一个要么是山峰要么是山谷</span></span><br><span class="line">        <span class="keyword">if</span>(right != <span class="number">0</span>) result++;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设dp状态dp[i] [0]，表示考虑前i个数，第i个数作为山峰的摆动子序列的最长长度<br>设dp状态dp[i] [1]，表示考虑前i个数，第i个数作为山谷的摆动子序列的最长长度<br>则转移方程为：</p>
<p>dp[i] [0] &#x3D; max(dp[i] [0], dp[j] [1] + 1)，其中0 &lt; j &lt; i且nums[j] &lt; nums[i]，表示将nums[i]接到前面某个山谷后面，作为山峰。<br>dp[i] [1] &#x3D; max(dp[i] [1], dp[j] [0] + 1)，其中0 &lt; j &lt; i且nums[j] &gt; nums[i]，表示将nums[i]接到前面某个山峰后面，作为山谷。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1.dp:dp[i][0] dp[i][1],0表示i为山谷，1表示i为山峰，总体表示0-i之间，以i为山谷/山峰的最大长度</span></span><br><span class="line"><span class="comment">2.base:dp[0][0] = dp[0][1] = 1</span></span><br><span class="line"><span class="comment">3.选择:</span></span><br><span class="line"><span class="comment">4.动态转移:</span></span><br><span class="line"><span class="comment">dp[i][0] = max(dp[k][1] + 1) 0 &lt; k &lt; i，nums[i] &lt; nums[k]</span></span><br><span class="line"><span class="comment">dp[i][1] = max(dp[k][0] + 1) 0 &lt; k &lt; i，nums[i] &gt; nums[k]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">		<span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">		</span><br><span class="line">		dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; n;i++) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">max0</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="type">int</span> <span class="variable">max1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;k &lt; i;k++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(nums[i] &lt; nums[k]) max0 = Math.max(max0, dp[k][<span class="number">1</span>]);</span><br><span class="line">				<span class="keyword">if</span>(nums[i] &gt; nums[k]) max1 = Math.max(max1, dp[k][<span class="number">0</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">			dp[i][<span class="number">0</span>] = max0 + <span class="number">1</span>;</span><br><span class="line">			dp[i][<span class="number">1</span>] = max1 + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> Math.max(dp[n-<span class="number">1</span>][<span class="number">0</span>], dp[n-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a> 贪心&#x2F;动态规划</p>
<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a> 贪心 差分&#x2F;动态规划</p>
<p><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a> 隐式bfs 每次只走到能跳到最远距离的那个</p>
<p><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a> 每次只走到能跳到最远距离的那个</p>
<p><a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a> 贪心 双指针 每次只移动最短的那边</p>
<p><a href="https://leetcode.cn/problems/binary-tree-cameras/">968. 监控二叉树</a> 贪心 二叉树&#x2F;树形动态规划</p>
<h2 id="四-重叠区间问题"><a href="#四-重叠区间问题" class="headerlink" title="四.重叠区间问题"></a>四.重叠区间问题</h2><p>像<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230621200049546.png" alt="image-20230621200049546">对一个数字对进行排序，不能分开排序的，可以先依据其中一个点进行排序，然后在对另一个进行处理。</p>
<p>对于[7,0] [7,1]需要注意当以第一个数(7)为依据时，第二个数(0,1)如何排序。</p>
<p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a> 贪心 排序</p>
<p><a href="https://leetcode.cn/problems/non-overlapping-intervals/">435. 无重叠区间</a> 贪心 排序</p>
<p><a href="https://leetcode.cn/problems/partition-labels/">763. 划分字母区间</a> 贪心 排序</p>
<p><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a> 贪心 排序 </p>
<p><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a> 贪心 链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(points,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span>[] b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>] &gt; b[<span class="number">0</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">1</span>] &gt; b[<span class="number">1</span>]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-05-03-动态规划</title>
    <url>/posts/6f3.html</url>
    <content><![CDATA[<h2 id="动态规划通用框架："><a href="#动态规划通用框架：" class="headerlink" title="动态规划通用框架："></a>动态规划通用框架：</h2><h3 id="动态规划特点："><a href="#动态规划特点：" class="headerlink" title="动态规划特点："></a>动态规划特点：</h3><p>1.穷举；2.状态转移方程；3.最优子结构；4.重叠子问题</p>
<h3 id="动态规划解题步骤："><a href="#动态规划解题步骤：" class="headerlink" title="动态规划解题步骤："></a>动态规划解题步骤：</h3><p>1.确定「状态」，也就是原问题和子问题中会变化的变量,状态数对应dp数组的维度数<br>2.根据状态，确定初始状态的值baseline；<br>3.确定「选择」，也就是导致「状态」产生变化的行为。<br>4.写出状态转移方程。<br>！dp中如何确定最优化的方程式？可以从某个具体状态出发，模拟演绎该状态是如何‘’选择‘’出来的。<br>5.（可选）画出决策树，找到重叠子问题，使用备忘录解决重叠子问题。</p>
 <span id="more"></span>

<p>入门小例子：2,1,4,5,2,9,7</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/mytypraimage-20220914211900224.png" alt="image-20220914211900224" style="zoom: 67%;" />

<p>解题步骤：</p>
<ol>
<li><p>base: amount为0时，硬币数为0；amount小于0时，硬币数为-1</p>
</li>
<li><p>状态：各amount下的硬币数量，如果为-1则表示该amount下无解。</p>
</li>
<li><p>选择：硬币的种类</p>
</li>
<li><p>状态转移方程（最优解）：设各amount下的最小硬币数量为nums(amount)</p>
</li>
</ol>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20240321143046495.png" alt="image-20240321143046495"></p>
<ol start="5">
<li>重叠子问题：只需要一个大小为amount+1的数组就可以作为备忘录，数组索引为amount，值为对应amount下的最小硬币数，为了区分“子问题未遍历”和“子问题为base”，应该初始化为不为0和-1的值。</li>
</ol>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/mytypratmpBE99.png" alt="tmpBE99" style="zoom:75%;" />



<h3 id="1-如何找到动态规划的状态转移关系"><a href="#1-如何找到动态规划的状态转移关系" class="headerlink" title="1. 如何找到动态规划的状态转移关系"></a>1. 如何找到动态规划的状态转移关系</h3><p>1、明确 <code>dp</code> 数组的定义。这一步对于任何动态规划问题都很重要，如果不得当或者不够清晰，会阻碍之后的步骤。</p>
<p>2、根据 <code>dp</code> 数组的定义，运用数学归纳法的思想，假设 <code>dp[0...i-1]</code> （<strong>即上一次的各个选择</strong>）都已知，想办法求出 <code>dp[i]</code>，一旦这一步完成，整个题目基本就解决了。</p>
<p>但如果无法完成这一步，很可能就是 <code>dp</code> 数组的定义不够恰当，需要重新定义 <code>dp</code> 数组的含义；或者可能是 <code>dp</code> 数组存储的信息还不够，不足以推出下一步的答案，需要把 <code>dp</code> 数组扩大成二维数组甚至三维数组。</p>
<p>例如：<a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a> text1&#x3D;“abcde”，text2&#x3D;“ace” ,3.选择：i,j同时右移；i右移，j不变；j右移，i不变；具体为i&#x3D;e，j&#x3D;e时，此时dp[e] [c],dp[d] [e],dp[d] [c]都是已知的。</p>
<h3 id="2-最优子结构原理"><a href="#2-最优子结构原理" class="headerlink" title="2. 最优子结构原理"></a>2. 最优子结构原理</h3><p>想满足最优子结构，子问题之间必须互相独立。<br><strong>最优子结构可以理解为最优子问题</strong>，<strong>通过子问题的最优值推出规模更大的问题的最优值。</strong><br>最优子结构并不是动态规划独有的一种性质，能求最值的问题大部分都具有这个性质；<strong>但反过来，最优子结构性质作为动态规划问题的必要条件，一定是让你求最值的</strong>，以后碰到那种恶心人的最值题，思路往动态规划想就对了，这就是套路。</p>
<p>1.如何一眼看出重叠子问题<br><strong>最简单粗暴的方式就是画图，把递归树画出来，看看有没有重复的节点</strong>。<br>从代码出发，忽视其他代码，只看那些递归代码（或者跟状态转移相关的代码）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bool <span class="title function_">dp</span><span class="params">(string&amp; s, <span class="type">int</span> i, string&amp; p, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; n - <span class="number">1</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp(s, i, p, j + <span class="number">2</span>)</span><br><span class="line">               || dp(s, i + <span class="number">1</span>, p, j);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dp(s, i + <span class="number">1</span>, p, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; n - <span class="number">1</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dp(s, i, p, j + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool <span class="title function_">dp</span><span class="params">(string&amp; s, <span class="type">int</span> i, string&amp; p, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    dp(s, i, p, j + <span class="number">2</span>);     <span class="comment">// #1</span></span><br><span class="line">    dp(s, i + <span class="number">1</span>, p, j);     <span class="comment">// #2</span></span><br><span class="line">    dp(s, i + <span class="number">1</span>, p, j + <span class="number">1</span>); <span class="comment">// #3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个解法的「状态」也是 <code>(i, j)</code> 的值，那么我继续问你问题：<strong>如果我想从状态 <code>(i, j)</code> 转移到 <code>(i+2, j+2)</code>，有几种路径？</strong>显然，至少有两条路径：<code>(i, j) -&gt; #1 -&gt; #2 -&gt; #2</code> 和 <code>(i, j) -&gt; #3 -&gt; #3</code>，这就说明这个解法存在巨量重叠子问题。</p>
<h4 id="3-dp-数组的大小设置"><a href="#3-dp-数组的大小设置" class="headerlink" title="3.dp 数组的大小设置"></a>3.dp 数组的大小设置</h4><p>dp数组中索引一般会和状态联系起来，有些base case状态可能为-1，例如零钱兑换中钱的状态为负数时，所以我们会把dp数组扩大相应的base case，例如dp[n+1],其中dp[0]作为负数时的base line。<br>总而言之，<strong>理论上，你怎么定义都可以，只要根据定义处理好 base case 就可以</strong>。</p>
<p>一般来说使用递归可以避免memo数组大小扩大问题</p>
<h4 id="4-dp-数组的遍历方向"><a href="#4-dp-数组的遍历方向" class="headerlink" title="4.dp 数组的遍历方向"></a>4.dp 数组的遍历方向</h4><p><strong>1、遍历的过程中，所需的状态必须是已经计算出来的</strong>。<br><strong>2、遍历结束后，存储结果的那个位置必须已经被计算出来</strong>。</p>
<p>画图法（适用于二维以内的）</p>
<p>程序法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> max_k; k &gt;= <span class="number">1</span>; k--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i - <span class="number">1</span> == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 处理 base case</span></span><br><span class="line">                dp[i][k][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                dp[i][k][<span class="number">1</span>] = -prices[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][k][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][k][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>但为什么我从大到小遍历 <code>k</code> 也可以正确提交呢？因为你注意看，<code>dp[i][k][..]</code> 不会依赖 <code>dp[i][k - 1][..]</code>，而是依赖 <code>dp[i - 1][k - 1][..]</code>，而 <code>dp[i - 1][..][..]</code>，都是已经计算出来的，所以不管你是 <code>k = max_k, k--</code>，还是 <code>k = 1, k++</code>，都是可以得出正确答案的。</p>
<h4 id="5-dp数组的初始值"><a href="#5-dp数组的初始值" class="headerlink" title="5.dp数组的初始值"></a>5.dp数组的初始值</h4><p>dp数组的初始值应该是特殊值，即动态规划求不出来的值，原因是为了和重复值区别开来，递归调用时如果是重复值则直接返回，如果是特殊值则计算。</p>
<p><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></p>
<p><a href="https://leetcode.cn/problems/unique-paths-ii/">63. 不同路径 II</a></p>
<p><a href="https://leetcode.cn/problems/integer-break/">343. 整数拆分</a></p>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="模式："><a href="#模式：" class="headerlink" title="模式："></a>模式：</h3><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。求解将哪些物品装入背包里物品价值总和最大。根据<strong>每件物品只能用一次</strong>和<strong>每件物品可以用多次</strong>可以分为01背包和完全背包</p>
<p>背包问题的两个重要特点：多个物品可选，背包容量有限</p>
<h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p>二维数组：</p>
<p>公式：dp[i] [j] &#x3D; Max(dp[i-1] [j],<strong>dp[i-1]</strong> [j-weight[i]]+values[i])  </p>
<p>从公式可以看出，dp[i] [j]只依赖上一层的值</p>
<p>遍历：先遍历物品还是先遍历背包都不影响结果</p>
<p>一维数组（滚动数组）：</p>
<p>公式：dp[j] &#x3D; Max(dp[j],dp[j-weight[i]]+values[i])  </p>
<p>遍历：先遍历<strong>物品再遍历背包</strong>，而且遍历背包时需要<strong>倒序</strong>遍历</p>
<p>注：上面的解法只针对组合问题</p>
<p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">416. 分割等和子集</a></p>
<p><a href="https://leetcode.cn/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II</a></p>
<p><a href="https://leetcode.cn/problems/target-sum/">494. 目标和</a></p>
<p><a href="https://leetcode.cn/problems/ones-and-zeroes/">474. 一和零</a> 注：这道题中背包是二维的（不是多重背包）即dp[i] [m] [n]其中[m] [n]的作用与背包相同</p>
<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>二维数组：</p>
<p>公式：dp[i] [j] &#x3D; Max(dp[i-1] [j],<strong>dp[i]</strong> [j-weight[i]]+values[i])  </p>
<p>从公式可以看出，dp[i] [j]不只依赖上一层的值还依赖同一层的数据</p>
<p>遍历：先遍历物品还是先遍历背包都不影响结果</p>
<p>一维数组：</p>
<p>公式：dp[j] &#x3D; Max(dp[j],dp[j-weight[i]]+values[i])  </p>
<p>遍历：先遍历<strong>物品再遍历背包</strong>，而且遍历背包时需要<strong>正序</strong>遍历</p>
<p>注：上面的解法只针对组合问题</p>
<p><a href="https://leetcode.cn/problems/coin-change-ii/">518. 零钱兑换 II</a></p>
<p><a href="https://leetcode.cn/problems/perfect-squares/">279. 完全平方数</a></p>
<h3 id="完全背包的排列问题"><a href="#完全背包的排列问题" class="headerlink" title="完全背包的排列问题"></a>完全背包的排列问题</h3><p>以<a href="https://leetcode.cn/problems/combination-sum-iv/">组合总和 Ⅳ</a>为例</p>
<p>二维数组：（不推荐）</p>
<p>公式：dp[i] [j] &#x3D; dp[i] [j] + <strong>dp[i-1]</strong> [j-nums[k]]</p>
<p>遍历：需要3层循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len; i++) &#123;<span class="comment">//遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= t; j++) &#123;<span class="comment">//遍历背包</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u : nums) &#123;<span class="comment">//遍历物品</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= u) f[i][j] += f[i - <span class="number">1</span>][j - u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一维数组：</p>
<p>公式：公式：dp[j] &#x3D; dp[j] + dp [j-nums[k]]</p>
<p>遍历：先遍历<strong>背包再遍历物品</strong>，而且遍历<strong>物品</strong>时需要<strong>正序</strong>遍历</p>
<p>背包问题两层 for 循环， 一种是固定背包的大小，选元素，从少到多。 一种是固定元素的个数，循环背包大小，从小往大。 在一个元素只能用一次的时候，两种 for 循环，谁在外层，其实看都一样能得到答案。</p>
<p>以 <code>nums = [1,2,3], target = 4</code> 举例： 正确答案是： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1)</p>
<p>但是固定元素数量，遍历背包的时候，只会出现 (1,1,2)。 另外的 (2,1,1) 和 (1,2,1) 被视为同一种情况</p>
<p>为什么会出现这样的情况呢？</p>
<p>当固定元素的时候，遍历背包的时候，dp 记录的是当前元素及以前的排列，不包含后面元素的排列，例如在固定元素为 1 时，遍历结束背包容量的时候，dp 记录的是只有元素 1 的时候，背包从空到满的排列方式。当元素为 2 的时候，dp[i-v] 如果成立， 实际上是先排列了 1 元素， 然后再排列了2。但是由于此时已经固定的元素是2， 所以没办法查找 dp[i-元素1] 的情况，即 2， 1 这种排列方式漏掉了。</p>
<p>进一步，两种循环方式都是 m*n 的复杂度，为什么有一种方式会漏掉排列的情况了， 大家可以再想想，由于个人表达能力有限，可能说不清楚，这里不再赘述。只提供一个思路就是，统计的时候的先后顺序不同导致有排列的情况被漏掉。并没有少做操作。</p>
<p><a href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></p>
<p><a href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></p>
<h2 id="状态机问题"><a href="#状态机问题" class="headerlink" title="状态机问题"></a>状态机问题</h2><p>状态机问题也是动态规划，可以套用一般的动态规划模式。<strong>对于普通的动态规划问题，需要特别注意遍历顺序问题，如果不能确定遍历顺序可以使用递归形式</strong></p>
<p><strong>强调状态的改变。使用数组的下标表示状态，一般来说，状态有几个对应的数组大小就为多少</strong></p>
<p>打家劫舍</p>
<p><a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></p>
<p><a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II</a></p>
<p>股票买卖</p>
<p><a href="https://www.programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87.html#%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA">https://www.programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87.html#%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA</a></p>
<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></p>
<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></p>
<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></p>
<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></p>
<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 买卖股票的最佳时机含冷冻期</a></p>
<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></p>
<h4 id="连续子串"><a href="#连续子串" class="headerlink" title="连续子串"></a>连续子串</h4><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></p>
<p>子串问题需要注意连续和非连续的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非连续</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= l1;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt;= l2;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)&#123;</span><br><span class="line">            dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text1.charAt(i-<span class="number">1</span>) == text2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[l1][l2];</span><br><span class="line"><span class="comment">//连续</span></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= len1;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= len2;j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1[i-<span class="number">1</span>] == nums2[j-<span class="number">1</span>])</span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        max = Math.max(max, dp[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/distinct-subsequences/">115. 不同的子序列</a></p>
<h4 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h4><p><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作</a></p>
<p><a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a> 注意即使是初始值也要符合定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> word1.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> word2.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= len1;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt;= len2;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                dp[i][j] = j;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                dp[i][j] = i;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(word1.charAt(i-<span class="number">1</span>) == word2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>],Math.min(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j]))+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h4><p><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a> 注意遍历顺序，看不出来就用递归</p>
<p>树形dp</p>
<p>顾名思义，树形DP就是在树上所做的动态规划。我们一般所做的动态规划多是线性的，线性DP我们可以从前向后或从后向前两种方法，不妨类比一下，在树上我们同样可以有两种方法，从根向树叶或者从树叶向根。从根向树叶的题不多见（至今我没见到过），而从根向叶传送值的题较多，下面我们主要来分析这种题。<br>在分析树形DP之前，我们要先会实现几个必要的程序，因为他们是我们完成一道题的前提，对于一道题，想法固然非常重要，想清楚写代码的时候就好写，但是如果我们无法实现一些基木的程序，比如如果不会将一棵多叉树改成一棵二叉树，那我们的程序就会复杂很多。不会搜索那么程序根木无法实现，所以说必须要弄清楚这些基木知识。</p>
<p><a href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**自下而上*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    	<span class="type">int</span>[] ans = dp(root);</span><br><span class="line">    	<span class="keyword">return</span> Math.max(ans[<span class="number">0</span>], ans[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] dp(TreeNode root) &#123;</span><br><span class="line">    	<span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> dp;</span><br><span class="line">    	<span class="type">int</span>[] left = dp(root.left);</span><br><span class="line">    	<span class="type">int</span>[] right = dp(root.right);</span><br><span class="line">    	dp[<span class="number">1</span>] = left[<span class="number">0</span>] + right[<span class="number">0</span>] + root.val;</span><br><span class="line">    	dp[<span class="number">0</span>] = Math.max(left[<span class="number">0</span>],left[<span class="number">1</span>]) + Math.max(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 至上而下</span></span><br><span class="line"><span class="comment"> 1.状态：root.val = 从下往上该结点的盗取的最高金额 </span></span><br><span class="line"><span class="comment"> 2.base：root == null,return 0</span></span><br><span class="line"><span class="comment"> 3.选择：当前结点可以选择偷或者不偷</span></span><br><span class="line"><span class="comment"> 4.动态转移：偷(num1 = root.val + rob(root.left.left)+rob(root.left.right)+rob(root.right.left)+rob(root.right.left)) </span></span><br><span class="line"><span class="comment"> 不偷(num2 = rob(root.left) + rob(root.right))</span></span><br><span class="line"><span class="comment"> 最终答案为root.val</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">HashMap&lt;Integer,Integer&gt; memo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> dp(root,<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> dp(root,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.max(num1, num2);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(TreeNode root,<span class="type">int</span> isRoded)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(root,isRoded);</span><br><span class="line">        <span class="keyword">if</span>(memo.containsKey(hash)) <span class="keyword">return</span> memo.get(hash);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(isRoded == <span class="number">0</span>) &#123;</span><br><span class="line">        	num = Math.max(dp(root.left,<span class="number">1</span>),dp(root.left,<span class="number">0</span>)) + Math.max(dp(root.right,<span class="number">1</span>),dp(root.right,<span class="number">0</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        	num = root.val + dp(root.left,<span class="number">0</span>) + dp(root.right,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        memo.put(hash,num);</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(TreeNode node,<span class="type">int</span> isRoded)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> node.hashCode() &lt;&lt; <span class="number">1</span> | isRoded; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/binary-tree-cameras/">968. 监控二叉树</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 动归：</span></span><br><span class="line"><span class="comment"> 0：未覆盖，1：已覆盖，2：安装摄像头</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCameraCover</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = postOrder(root);</span><br><span class="line">        <span class="keyword">return</span> Math.min(dp[<span class="number">0</span>]+<span class="number">1</span>,Math.min(dp[<span class="number">1</span>],dp[<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span>[] postOrder(TreeNode root) &#123;</span><br><span class="line">		<span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">		<span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">			dp[<span class="number">0</span>] = Integer.MAX_VALUE/<span class="number">2</span>;</span><br><span class="line">			dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">			dp[<span class="number">2</span>] = Integer.MAX_VALUE/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">return</span> dp;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span>[] left_dp = postOrder(root.left);</span><br><span class="line">		<span class="type">int</span>[] right_dp = postOrder(root.right);</span><br><span class="line">		</span><br><span class="line">		dp[<span class="number">0</span>] = left_dp[<span class="number">1</span>] + right_dp[<span class="number">1</span>];</span><br><span class="line">		dp[<span class="number">1</span>] = Math.min(</span><br><span class="line">				Math.min(right_dp[<span class="number">1</span>], right_dp[<span class="number">2</span>])+left_dp[<span class="number">2</span>], </span><br><span class="line">				Math.min(left_dp[<span class="number">1</span>], left_dp[<span class="number">2</span>])+right_dp[<span class="number">2</span>]);</span><br><span class="line">		dp[<span class="number">2</span>] = Math.min(right_dp[<span class="number">0</span>], Math.min(right_dp[<span class="number">1</span>], right_dp[<span class="number">2</span>]))+</span><br><span class="line">				Math.min(left_dp[<span class="number">0</span>], Math.min(left_dp[<span class="number">1</span>], left_dp[<span class="number">2</span>]))</span><br><span class="line">				+ <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> dp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>记忆化搜索</p>
<p>在dp和dfs（回溯）中都会使用到记忆化搜索，而且一般是在递归形式中，其作用是剪枝</p>
<p>待总结</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20231111222655109.png" alt="image-20231111222655109"></p>
<p>初始化值的妙用</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-05-13-Java进阶</title>
    <url>/posts/c72a.html</url>
    <content><![CDATA[<h2 id="0-基础"><a href="#0-基础" class="headerlink" title="0.基础"></a>0.基础</h2><h3 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h3><p>重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理，发生在编译期。</p>
<p>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变，发生在运行期。遵循两同两小一大</p>
<p>两同两小一大：</p>
<ul>
<li>方法名相同，形参列表相同</li>
<li>子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等</li>
<li>子类方法的访问权限应比父类方法的访问权限更大或相等</li>
</ul>
 <span id="more"></span>

<h3 id="包装类型的缓存机制了解么？"><a href="#包装类型的缓存机制了解么？" class="headerlink" title="包装类型的缓存机制了解么？"></a>包装类型的缓存机制了解么？</h3><p><strong>包装类型的缓存机制是在valueOf方法中实现，主要是在自动装箱时避免创建重复对象，直接使用缓存中的对象</strong>。</p>
<p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<h3 id="自动装箱与拆箱了解吗？原理是什么？"><a href="#自动装箱与拆箱了解吗？原理是什么？" class="headerlink" title="自动装箱与拆箱了解吗？原理是什么？"></a>自动装箱与拆箱了解吗？原理是什么？</h3><ul>
<li><p>装箱(valueOf)：比如将一个int的值赋值给一个Integer引用，就会自动调用Integer的valueOf方法，创建一个Integer对象；</p>
<p><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></p>
</li>
<li><p>拆箱(intValue)：比如将一个Integer对象赋值给int时，就会自动调用Integer的intValue方法，返回一个int值；</p>
<p><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</p>
</li>
</ul>
<h3 id="为什么浮点数运算的时候会有精度丢失的风险？"><a href="#为什么浮点数运算的时候会有精度丢失的风险？" class="headerlink" title="为什么浮点数运算的时候会有精度丢失的风险？"></a>为什么浮点数运算的时候会有精度丢失的风险？</h3><ul>
<li><p>浮点数在计算机中的表示是通过二进制科学计数法，因此对于一些十进制数无法精确地表示为有限的二进制数，从而导致浮点数运算出现精度丢失的问题。</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/32b2c9a50d5b434a8f09f42e38ba361ctplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp" alt="img"></p>
</li>
</ul>
<h3 id="对注解的理解"><a href="#对注解的理解" class="headerlink" title="对注解的理解"></a>对注解的理解</h3><p><code>Annotation</code> （注解）可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。注解和注释不同的是，注解会被 Java 编译器处理而非跳过。</p>
<p>java 里注解有许多用途：</p>
<ul>
<li>编译检查：通过代码里标识的元数据让编译器能实现基本的编译检查。@Override</li>
<li>运行时处理：可以在运行时获取某些注解并处理。</li>
</ul>
<h3 id="SPI（Service-Provider-Interface）"><a href="#SPI（Service-Provider-Interface）" class="headerlink" title="SPI（Service Provider Interface）"></a>SPI（Service Provider Interface）</h3><p>SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”，我的理解是：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。</p>
<p>service-provider-interface										service-provider</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230918170259736.png" alt="image-20230918170259736" style="zoom:80%;" /><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230918165909904.png" alt="image-20230918165909904" style="zoom: 67%;" /></p>
<p>Logger:接口</p>
<p>LoggerService：使用ServiceLoader加载所有Logger的实现类，放到一个List数组中</p>
<p>service-provider:提供Logger接口的实现</p>
<p>Java 中的 SPI 机制就是在每次类加载的时候会先去找到 class 相对目录下的 <code>META-INF</code> 文件夹下的 services 文件夹下的文件，将这个文件夹下面的所有文件先加载到内存中，然后根据这些文件的文件名和里面的文件内容找到相应接口的具体实现类，找到实现类后就可以通过反射去生成对应的对象，保存在一个 list 列表里面，所以可以通过迭代或者遍历的方式拿到对应的实例对象，生成不同的实现。</p>
<p>优点：SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方的代码。</p>
<p>缺点：需要遍历加载所有的实现类，不能做到按需加载，这样效率还是相对较低的。</p>
<p>SPI 和 API 的区别：</p>
<p>SPI就只提供一个接口，由调用方确定接口规则，然后由不同的实现方去根据这个规则对这个接口进行实现</p>
<p>API会提供接口和接口的实现，所以都是接口和实现由实现方提供的</p>
<p>例如：SLF4J是 Java 的一个日志门面，相当于SPI，光引入SLF4J是不够的，还要引入接口的实现包，如Log4j，相当于服务提供者。当我们项目中需要更换为Logback时，可以直接引入Logback的包，而不需要修改源代码</p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>·<strong>序列化</strong>：将数据结构或对象转换成二进制字节流的过程<br>·<strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</p>
<p>对于Java这种面向对象编程语言来说，我们序列化的都是对象(Object)也就是实例化后的类(Class)</p>
<p>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230817195542118.png" alt="image-20230817195542118" style="zoom:80%;" />

<p>因为，OSI七层协议模型中的应用层、表示层和会话层对应的都是TCP&#x2F;IP四层模型中的应用层，所以序列化协议属于TCP协议应用层的一部分。</p>
<h4 id="常见的序列化协议"><a href="#常见的序列化协议" class="headerlink" title="常见的序列化协议"></a>常见的序列化协议</h4><p>二进制的序列化协议：JDK自带，Kryo</p>
<p>文本类的序列化协议：JSON，XML</p>
<h4 id="JDK自带的序列化方式"><a href="#JDK自带的序列化方式" class="headerlink" title="JDK自带的序列化方式"></a>JDK自带的序列化方式</h4><p>JDK自带的序列化，只需实现java.io.Serializable接口即可。</p>
<p><strong>serialVersionUlD有什么作用？</strong>序列化号serialVersionUID属于版本控制的作用。反序列化时，会检查serialVersionUID是否和当前类的serialVersionUID一致。如果serialVersionUID不致则会抛出InvalidClassException,异常。强烈推荐每个序列化类都手动指定其serialVersionUID,如果不手动指定，那么编译器会动态生成默认的serialVersionUID.</p>
<p><strong>serialVersionUlD不是被static变量修饰了吗？为什么还会被“序列化”？</strong>static修饰的变量是静态变量，位于方法区，本身是不会被序列化的。static变量是属于类的而不是对象。你反序列之后，static变量的值就像是默认赋予给了对象一样，看着就像是static变量被序列化，实际只是假象罢了。</p>
<p><strong>如果有些字段不想进行序列化怎么办？</strong>对于不想进行序列化的变量，可以使用transient关键字修饰。transient关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。</p>
<p>关于transient还有几点注意：</p>
<ul>
<li>transient只能修饰变量，不能修饰类和方法。</li>
<li>transient修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰int类型，那么反序列后结果就是0.</li>
<li>static变量因为不属于任何对象(Object),所以无论有没有transient关键字修饰，均不会被序列化。</li>
</ul>
<p><strong>为什么不推荐使用JDK自带的序列化？</strong></p>
<p>不支特跨语言调用：如果调用的是其他语言开发的服务的时候就不支持了。<br>性能差：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。<br>存在安全问题：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。</p>
<p><strong>Kryo</strong></p>
<p>Kryo是一个高性能的序列化&#x2F;反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。是一种比较成熟的序列化工具，Dubbo也推荐使用Kryo作为序列化方式。</p>
<h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><p>java的IO可以分为两种，一种是IO流，一种是IO模型。</p>
<h4 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h4><p>java中的IO流可以根据数据单位不同分为两类，字节流和字符流，分别对应InputStream，OutputStream，Reader，Writer。这些都是抽象类，需要调用子类创建对象。其中字节流中使用最多的就是FileInputStream用于文件，BufferInputStream是一个装饰器类用于给InputStream下的直接子类提供缓冲功能，ObjectInputStream用于读取序列化对象。然后字符流中使用最多的是FileReader，BufferReader，还提供了一个特殊的转换流InputStreamReader，可以将字节流转换成字符流。</p>
<h4 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h4><p>BIO：同步阻塞IO模型中，在进行I&#x2F;O操作时，会一直阻塞（线程挂起），直到内核把数据拷贝到用户空间后才能进行下一步操作。基于Stream流的IO基本都属于BIO。</p>
<p>NIO：同步非阻塞I&#x2F;O，在进行I&#x2F;O操作时，不会阻塞（线程运行），主线程一直在执行操作，对于select操作来说，线程要么在轮询判断哪个客户端就绪，要么就在执行IO操作（内核把数据拷贝到用户空间）。</p>
<p>AIO:AIO也就是NIO2。它是异步非阻塞的IO模型。异步IO是基于事件和回调机制实现的，在进行I&#x2F;O操作时，不需要等待操作完成，就可继续进行其他操作，当操作完成后会自动回调通知</p>
<h3 id="java中的函数传递都是值传递"><a href="#java中的函数传递都是值传递" class="headerlink" title="java中的函数传递都是值传递"></a>java中的函数传递都是值传递</h3><p>因为无论java的函数参数是基本数据类型还是引用类型都会在栈中生成它的一个拷贝，基本数据类型是拷贝值，引用类型是拷贝地址。</p>
<h3 id="jdk1-8新特性"><a href="#jdk1-8新特性" class="headerlink" title="jdk1.8新特性"></a>jdk1.8新特性</h3><p><strong>1. Lambda表达式：</strong>Lambda表达式是一种轻量级的匿名函数，可以作为一个函数式接口的实现。</p>
<p><strong>2. Stream API：</strong>Stream API提供了一种流式编程的方式来处理集合或数组中的数据。</p>
<p><strong>3. 默认方法：</strong>默认方法为接口添加了一种默认实现，使得接口的实现更加灵活。</p>
<h3 id="JDK与JRE的区别"><a href="#JDK与JRE的区别" class="headerlink" title="JDK与JRE的区别"></a>JDK与JRE的区别</h3><p>JDK的中文名称是Java开发工具，也就是说JDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，例如编译工具javac，文档工具javadoc，反编译工具javap，也包括了 JRE。</p>
<p>JRE的中文名称是Java 运行环境，也就是如果想要运行一个开发好的 Java 程序，计算机中只需要安装 JRE 即可，JRE包含了JVM和Java的核心类库。</p>
<h3 id="spring-boot-打包WAR和JAR包的区别"><a href="#spring-boot-打包WAR和JAR包的区别" class="headerlink" title="spring boot 打包WAR和JAR包的区别"></a>spring boot 打包WAR和JAR包的区别</h3><p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20231113171522583.png" alt="image-20231113171522583" style="zoom:50%;" /><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20231113171744600.png" alt="image-20231113171744600" style="zoom: 50%;" /></p>
<p>BOOT-INF&#x2F;classes：目录存放应用编译后的class文件。<br>BOOT-INF&#x2F;lib：目录存放应用依赖的第三方JAR包文件。<br>META-INF：目录存放应用打包信息(Maven坐标、pom文件)和MANIFEST.MF文件。Main-Class这个属性对应的class的main方法是作为程序入口启动应用的。<br>org：目录存放SpringBoot相关class文件。<br>jar：直接通过内置tomcat运行，不需要额外安装tomcat。如需修改内置tomcat的配置，只需要在spring boot的配置文件中配置。</p>
<p>war：传统的应用交付方式，需要安装tomcat，然后放到webapps目录下运行war包。</p>
<h2 id="1-面向对象"><a href="#1-面向对象" class="headerlink" title="1.面向对象"></a>1.面向对象</h2><h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><ul>
<li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li>
<li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li>
</ul>
<h3 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h3><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的。</p>
<ul>
<li><p>方法多态：重写和重载就体现多态。重写：B继承A类，B重写A的say方法。重载：A中的有两个say方法，但是他们的参数不一致。</p>
</li>
<li><p>对象多态：运行类型和编译类型是不等同的。通过上转型和下转型体现</p>
</li>
</ul>
<p>注：多态的底层是由动态绑定机制实现的，它遵循以下规则</p>
<p>1.当调用对象方法的时候，该方法会和该对象的运行类型绑定。</p>
<p>2.当调用对象属性的时候，没有动态绑定机制，使用编译类型的值。</p>
<p>例子：</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230402190516224.png" alt="image-20230402190516224" style="zoom:80%;" /><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230402190531569.png" alt="image-20230402190531569" style="zoom:80%;" /><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230402190511077.png" alt="image-20230402190511077" style="zoom:80%;" /><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230402190538704.png" alt="image-20230402190538704" style="zoom: 80%;" /></p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="泛型的作用"><a href="#泛型的作用" class="headerlink" title="泛型的作用"></a>泛型的作用</h4><p>泛型可以保证如果程序在编译时没有发生警告，运行就不会产生问题，提高了安全性</p>
<p>减少了类型转换的次数，提高效率</p>
<h4 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h4><p>泛型一般有三种使用方式:<strong>泛型类</strong>、<strong>泛型接口</strong>、<strong>泛型方法</strong></p>
<p>泛型类：</p>
<p>普通成员可以使用泛型，静态方法内不能使用类的泛型</p>
<p>给泛型指定具体类型后，可以传入该类型或者是其子类型</p>
<p>泛型方法：</p>
<p>泛型方法跟泛型类的区别在于，泛型方法的修饰符(public)后面加了一个泛型&lt; T &gt;</p>
<p>泛型方法的具体泛型通过方法参数确定，所以可以使用静态泛型方法</p>
<p><code>public static &lt; E &gt; void printArray( E[] inputArray )</code> 一般被称为静态泛型方法</p>
<h4 id="泛型的继承和通配符"><a href="#泛型的继承和通配符" class="headerlink" title="泛型的继承和通配符"></a>泛型的继承和通配符</h4><p>1.泛型不具备继承性，如：List&lt; Object &gt; &#x3D; new ArrayList&lt; String &gt;是错误的</p>
<p>2.&lt;?&gt;：支持任意泛型</p>
<p>3.&lt;? extends A&gt;:支持A类以及A类的子类，规定了泛型的上限(A为上限)</p>
<p>4.&lt;? super A&gt;:支持A类以及A类的父类，不限于直接父类，规定了泛型的下限(A为下限)</p>
<h3 id="接口和抽象类有什么共同点和区别？"><a href="#接口和抽象类有什么共同点和区别？" class="headerlink" title="接口和抽象类有什么共同点和区别？"></a>接口和抽象类有什么共同点和区别？</h3><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>1、接口可以包含变量、方法；变量被隐士指定为public static final，方法被隐士指定为public abstract（JDK1.8之前）；</p>
<p>2、接口支持多继承，即<strong>一个接口可以extends多个接口</strong>，间接的解决了Java中类的单继承问题；</p>
<p>3、一个类可以实现多个接口；</p>
<p>4、jdk8新特性</p>
<p>4.1、默认方法（default method）：JDK 1.8允许给接口添加非抽象的方法实现，但必须使用default关键字修饰；定义了default的方法可以不被实现子类所实现，但只能被实现子类的对象调用；如果子类实现了多个接口，并且这些接口包含一样的默认方法，则子类必须重写默认方法；</p>
<p>4.2、静态方法（static method）：JDK 1.8中允许使用static关键字修饰一个方法，并提供实现，称为接口静态方法。接口静态方法只能通过接口调用（接口名.静态方法名）。</p>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>1、抽象类不能被实例化，即不能使用new关键字来实例化对象，只能被继承；</p>
<p>2、包含抽象方法的一定是抽象类，但是抽象类不一定含有抽象方法；</p>
<p>3、抽象类中的抽象方法的修饰符只能为public或者protected，默认为public abstract；</p>
<p>4、抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。；</p>
<p>5、抽象类可以继承普通类，抽象类，接口；</p>
<p>6、抽象类可以包含属性、方法、构造方法，但是构造方法不能用于实例化，主要用途是被子类调用。</p>
<h4 id="共同点-："><a href="#共同点-：" class="headerlink" title="共同点 ："></a><strong>共同点</strong> ：</h4><ul>
<li>都不能被实例化。</li>
<li>都可以包含抽象方法。</li>
<li>都可以有默认实现的方法（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li>
</ul>
<h3 id="内部类和静态内部类"><a href="#内部类和静态内部类" class="headerlink" title="内部类和静态内部类"></a>内部类和静态内部类</h3><p>内部类在创建时，需要先创建外部类，然后再创建内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Outerclass</span> <span class="variable">q</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outerclass</span>();</span><br><span class="line">Outerclass.<span class="type">innerclass</span> <span class="variable">c</span> <span class="operator">=</span> q.<span class="keyword">new</span> <span class="title class_">innerclass</span>();</span><br></pre></td></tr></table></figure>

<p>为了方便，一般会在外部类中定义创建内部类的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> innerclass <span class="title function_">innerclass</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">innerclass</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而静态内部类可以直接创建</p>
<h3 id="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="headerlink" title="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"></a>深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h3><p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p>
<p><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p>
<p><strong>引用拷贝</strong>(值传递)：引用拷贝就是两个不同的引用指向同一个对象。</p>
<p>浅拷贝和深拷贝的实现方式：object.clone()，java默认浅拷贝；引用拷贝的实现方式：函数参数传递</p>
<h3 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h3><p>如果 <code>equals</code> 方法判断两个对象是相等的，那么这两个对象的 <code>hashCode</code> 值也要相等。否则就无法正常使用set和map集合。</p>
<h3 id="String、StringBuffer、StringBuilder-的区别？"><a href="#String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="String、StringBuffer、StringBuilder 的区别？"></a>String、StringBuffer、StringBuilder 的区别？</h3><p>主要体现在拼接字符串操作的性能上</p>
<p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。</p>
<p>StringBuffer和 StringBuilder都可以利用append方法在原对象上拼接字符串，不需要创建新的对象，因此性能会提高；</p>
<p>StringBuffer是多线程安全的，相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升。</p>
<h3 id="String-为什么是不可变的"><a href="#String-为什么是不可变的" class="headerlink" title="String 为什么是不可变的?"></a>String 为什么是不可变的?</h3><ul>
<li><p>字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</p>
</li>
<li><p><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</p>
</li>
</ul>
<h3 id="编译期就可以确定值的常量"><a href="#编译期就可以确定值的常量" class="headerlink" title="编译期就可以确定值的常量"></a>编译期就可以确定值的常量</h3><ul>
<li>基本数据类型( <code>byte</code>、<code>boolean</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>)以及字符串常量。</li>
<li><code>final</code> 修饰的基本数据类型和字符串变量</li>
<li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li>
</ul>
<h2 id="2-集合"><a href="#2-集合" class="headerlink" title="2.集合"></a>2.集合</h2><p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/java-collection-hierarchy.png" alt="img"></p>
<p>collection是单列结构，map是双列结构</p>
<h3 id="comparable-和-Comparator-的区别"><a href="#comparable-和-Comparator-的区别" class="headerlink" title="comparable 和 Comparator 的区别"></a>comparable 和 Comparator 的区别</h3><p>Comparable可以认为是一个内比较器，由需要排序的类内部实现排序方法，实现Comparable接口的类可以和自己比较。</p>
<p>Comparator可以认为是一个外比较器，由外部类实现排序方法。例如，在Collection.sort方法中可以传入一个匿名内部类Comparator，自定义排序规则，但是需要排序的类本身并不需要修改。</p>
<h3 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h3><p>线程是否安全，效率，</p>
<p>对 Null key 和 Null value 的支持：hashmap可以储存一个null key和多个null value；Hashtable两种都不允许</p>
<p>初始容量大小和每次扩充容量大小的不同：hashtable的忘了，讲一下hashmap的</p>
<p>底层数据结构：1.8之后，hashmap会树化</p>
<h3 id="HashSet-如何检查重复"><a href="#HashSet-如何检查重复" class="headerlink" title="HashSet 如何检查重复?"></a>HashSet 如何检查重复?</h3><h3 id="HashMap-多线程问题"><a href="#HashMap-多线程问题" class="headerlink" title="HashMap 多线程问题"></a>HashMap 多线程问题</h3><p>put操作破坏单链表结构</p>
<p>初始化</p>
<p>resize插入重复数据</p>
<h3 id="HashMap-的-7-种遍历方式与性能分析"><a href="#HashMap-的-7-种遍历方式与性能分析" class="headerlink" title="HashMap 的 7 种遍历方式与性能分析"></a>HashMap 的 7 种遍历方式与性能分析</h3><p><a href="https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw">https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw</a></p>
<ol>
<li>使用迭代器（Iterator）EntrySet 的方式进行遍历；</li>
<li>使用迭代器（Iterator）KeySet 的方式进行遍历；</li>
<li>使用 For Each EntrySet 的方式进行遍历；</li>
<li>使用 For Each KeySet 的方式进行遍历；</li>
<li>使用 Lambda 表达式的方式进行遍历；</li>
<li>使用 Streams API 单线程的方式进行遍历；</li>
<li>使用 Streams API 多线程的方式进行遍历。</li>
</ol>
<p>性能上：<code>EntrySet</code> 的性能比 <code>KeySet</code> 的性能高出了一倍，因为 <code>KeySet</code> 相当于循环了两遍 Map 集合，而 <code>EntrySet</code> 只循环了一遍。</p>
<h3 id="集合遍历的安全性"><a href="#集合遍历的安全性" class="headerlink" title="集合遍历的安全性"></a>集合遍历的安全性</h3><p>不要在 foreach 循环里进行元素的 <code>remove/add</code> 操作。remove 元素请使用 <code>Iterator</code> 方式或者使用Stream filter方式，如果并发操作，需要对 <code>Iterator</code> 对象加锁。</p>
<h3 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h3><p>底层结构：</p>
<p>实现线程安全的方式：**<code>Hashtable</code>(同一把锁)** :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。</p>
<h3 id="ArrayList源码与扩容机制"><a href="#ArrayList源码与扩容机制" class="headerlink" title="ArrayList源码与扩容机制"></a>ArrayList源码与扩容机制</h3><h4 id="Arraylist-和-Vector-的区别"><a href="#Arraylist-和-Vector-的区别" class="headerlink" title="Arraylist 和 Vector 的区别"></a>Arraylist 和 Vector 的区别</h4><h4 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别"></a>Arraylist 与 LinkedList 区别</h4><p>是否保证线程安全，底层数据结构，插入和删除是否受元素位置的影响，是否支持快速随机访问</p>
<h4 id="ArrayList-扩容机制分析"><a href="#ArrayList-扩容机制分析" class="headerlink" title="ArrayList 扩容机制分析"></a>ArrayList 扩容机制分析</h4><ul>
<li><strong>以无参数构造方法创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong> </li>
<li>当数组容量为10，还要添加数据时就会触发扩容机制</li>
<li>int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）</li>
<li>扩容是通过创建一个新的数组，然后把旧的数组元素复制在新数组上实现的</li>
</ul>
<h4 id="ensureCapacity方法"><a href="#ensureCapacity方法" class="headerlink" title="ensureCapacity方法"></a><code>ensureCapacity</code>方法</h4><p>当用户知道要扩容的数量是多少的时候，可以调用此方法，避免频繁的扩容，但这个方法很少使用。</p>
<h3 id="HashMap源码与底层数据结构分析"><a href="#HashMap源码与底层数据结构分析" class="headerlink" title="HashMap源码与底层数据结构分析"></a>HashMap源码与底层数据结构分析</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h4><p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。</p>
<p>JDK1.8 之后 HashMap 底层是 <strong>数组和链表或红黑树</strong> 结合在一起使用。</p>
<p>HashMap 的长度为2的幂次方，<strong>即使是自定义的长度也会将其扩充为 2 的幂次方大小</strong>， 原因是hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是 2 的 n 次方，采用二进制位操作 &amp;，相对于%能够提高运算效率；</p>
<h5 id="loadFactor-加载因子"><a href="#loadFactor-加载因子" class="headerlink" title="loadFactor 加载因子"></a><strong>loadFactor 加载因子</strong></h5><p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 &#x3D; 12 就需要将当前 16 的容量进行扩容</p>
<p>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值。</p>
<h5 id="threshold"><a href="#threshold" class="headerlink" title="threshold"></a><strong>threshold</strong></h5><p>threshold &#x3D; capacity  * loadFactor， 衡量数组是否需要扩增的一个标准。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>hashmap在一开始并没有初始化,而是在put(K,V)第一个元素的时候,初始化一个大小为16的Node数组</p>
<h5 id="put"><a href="#put" class="headerlink" title="put"></a>put</h5><p>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度）。</p>
<p><strong>如果当前位置存在元素的话</strong>，还要判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接替换，不相同就通过<strong>尾插法</strong>解决冲突。</p>
<p><strong>如果当前位置不存在存在元素的话</strong>，就直接插入。</p>
<p>注：hashmap是先插入再判断是否需要扩容的</p>
<p>在put时有两种情况会发生扩容：</p>
<ol>
<li>当数组中的元素使用容量大于负载容量时，负载容量等于负载因子乘以数组最大容量，也会对数组进行扩容。</li>
<li>当链表长度大于阈值（默认为 8）时，会首先调用 <code>treeifyBin()</code>方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 <code>resize()</code> 方法对数组扩容。（注，在jdk1.7中，链表时没有阈值的）</li>
</ol>
<h5 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h5><p>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，重新插入新数组中，是非常耗时的。</p>
<h3 id="ConcurrentHashMap源码与底层数据结构分析"><a href="#ConcurrentHashMap源码与底层数据结构分析" class="headerlink" title="ConcurrentHashMap源码与底层数据结构分析"></a>ConcurrentHashMap源码与底层数据结构分析</h3><h4 id="ConcurrentHashMap-1-7"><a href="#ConcurrentHashMap-1-7" class="headerlink" title="ConcurrentHashMap 1.7"></a>ConcurrentHashMap 1.7</h4><h5 id="1-存储结构"><a href="#1-存储结构" class="headerlink" title="1. 存储结构"></a>1. 存储结构</h5><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230320113855754.png" alt="image-20230320113855754" style="zoom:80%;" />

<p>数据结构：ReentrantLock+Segment数组+HashEntry数组，每个Segment都可以关联一个HashEntry数组，HashEntry数组是跟HashMap一样的数组加链表的结构。</p>
<p>并发原理：Segment分段锁继承了ReentrantLock,锁定操作的Segment,其他的Segment不受影响，并发度为segment个数，可以通过构造函数指定，数组扩容不会影响其他的segment，<code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>。 <code>Segment</code> 数组的大小是由并发级别决定的，默认是 16，也就是说默认可以同时支持 16 个线程并发写。</p>
<h5 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化"></a>2.初始化</h5><p>以无参构造函数为例，即使用默认的容量16，加载因子0.75，并发度16</p>
<ol>
<li>计算Segment数组的长度，保证是2 的幂次方值。</li>
<li>计算Segment中HashEntry的默认长度，默认为2。(计算公式为2的n次方，其中n&#x3D;log2(容量&#x2F;并发级别))</li>
<li><strong>创建长度为16的Segment数组，并创建一个Segment对象，在这个Segment对象中创建一个大小为2的HashEntry数组。并把这个Segment对象放入索引0的位置</strong></li>
<li><strong>Segment数组其他元素为null，只有在使用时才会以Segment[0]为模板进行创建。</strong></li>
</ol>
<h5 id="3-put"><a href="#3-put" class="headerlink" title="3.put"></a>3.put</h5><p>ConcurrentHashMap的put方法</p>
<ol>
<li><p>第一次计算hash值，这里计算的hash值是对应Segment数组的索引。</p>
</li>
<li><p>判断该索引位的Segment对象是否创建</p>
<ul>
<li><p>没有就调用ConcurrentHashMap的ensureSegment方法创建，然后调用Segmetn的put方法实现元素添加。</p>
</li>
<li><p>有就直接调用Segmetn的put方法实现元素添加。</p>
</li>
</ul>
</li>
</ol>
<p>ConcurrentHashMap的ensureSegment方法</p>
<ol>
<li>以索引为0的Segment的为模板，根据它的容量和加载因子，创建一个Segment对象</li>
<li>自旋+cas的方式，将创建的Segment对象放到Segment[]数组中，确保线程安全</li>
</ol>
<p>Segment的put方法</p>
<ol>
<li>自旋使用<code>tryLock()</code> 获取锁</li>
<li>第二次计算hash值，这里计算的hash值是对应HashEntry数组的索引。</li>
<li>找到put的数据在数组的位置后，接下来的put操作就和hashmap的put操作的流程差不多。</li>
<li>包括插入(不会树化，<strong>头插法</strong>)，替换和扩容操作</li>
</ol>
<h5 id="4-get"><a href="#4-get" class="headerlink" title="4.get"></a>4.get</h5><p>不加锁，用UNSAFE.getObjectVolatile保证可见性</p>
<h5 id="5-扩容"><a href="#5-扩容" class="headerlink" title="5.扩容"></a>5.扩容</h5><p>发生在 put 中，因为此时已经获得了锁，因此扩容时不需要考虑线程安全</p>
<p>只针对当前访问的segment的HashEntry进行扩容，每个segment的扩容的都是独立</p>
<ol>
<li>创建一个新的两倍大的HashEntry数组</li>
<li>对于旧数组数据，重新计算hash值并插入到新的HashEntry数组中。</li>
</ol>
<h4 id="ConcurrentHashMap-1-8"><a href="#ConcurrentHashMap-1-8" class="headerlink" title="ConcurrentHashMap 1.8"></a>ConcurrentHashMap 1.8</h4><h5 id="1-存储结构-1"><a href="#1-存储结构-1" class="headerlink" title="1. 存储结构"></a>1. 存储结构</h5><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230320114251434.png" alt="image-20230320114251434" style="zoom:80%;" />

<p>数据结构：synchronized+Node数组+链表&#x2F;红黑树，Node的val和next都用volatile修饰，保证可见性。</p>
<p>并发原理：<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样<strong>只要 hash 不冲突，就不会产生并发</strong>，就不会影响其他 Node 的读写，锁粒度更细，效率大幅提升。</p>
<p>特殊变量：sizeCtl</p>
<ol>
<li>-1 说明正在初始化</li>
<li>-N 说明有N-1个线程正在进行扩容</li>
<li>0 表示 table 初始化大小，如果 table 没有初始化</li>
<li>&gt;0 表示 table 扩容的阈值，如果 table 已经初始化。</li>
</ol>
<h5 id="2-初始化-1"><a href="#2-初始化-1" class="headerlink" title="2.初始化"></a>2.初始化</h5><p>1.8的ConcurrentHashMap的数组初始化是在第一次添加元素时完成</p>
<p>Node元素的初始化通过自旋和 CAS 操作完成的。cas修改sizeCtl的值为-1，修改成功，进行数组初始化，将扩容阈值，赋值给sizeCtl。</p>
<h5 id="3-put-1"><a href="#3-put-1" class="headerlink" title="3.put"></a>3.put</h5><p>判断ConcurrentHashMap数组是否初始化，否则先进行初始化，初始化大小为16。</p>
<p>（注：传递进来一个初始容量，1.8的ConcurrentHashMap会基于这个值计算一个比这个值大的2的幂次方数作为初始容量）</p>
<p>根据 key 计算出 hashcode，hashcode对应Node数组的索引。</p>
<p>如果该node的链表尚未创建，就使用 cas 创建链表；</p>
<p>如果该node已经存在链表，synchronized锁住链表头进行后续 put 操作，元素添加至链表的尾部</p>
<p>这里同样会发生包括插入(不会树化，<strong>尾插法</strong>)，替换和扩容操作</p>
<h5 id="4-get-1"><a href="#4-get-1" class="headerlink" title="4.get"></a>4.get</h5><p>直接查找，因为Node的val和next都用volatile修饰，保证可见性。</p>
<h5 id="5-扩容-1"><a href="#5-扩容-1" class="headerlink" title="5.扩容"></a>5.扩容</h5><p>扩容前会创建一个两倍大新数组，然后将旧数据重新插入新数组中</p>
<p>支持多个线程同时扩容，当某个线程进行put时，如果发现ConcurrentHashMap正在扩容，那么该线程也加入扩容</p>
<h4 id="与hashtable的区别："><a href="#与hashtable的区别：" class="headerlink" title="与hashtable的区别："></a>与hashtable的区别：</h4><p><strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p>
<h4 id="1-7与1-8的对比："><a href="#1-7与1-8的对比：" class="headerlink" title="1.7与1.8的对比："></a>1.7与1.8的对比：</h4><ul>
<li><p>储存结构不同</p>
</li>
<li><p>Segments 数组默认大小为16，这个容量初始化指定后就不能改变了，并且不是懒惰初始化</p>
</li>
<li><p>1.7中锁住的是某个HashEntry数组，1.8中锁住的是Node数组中的某个链表，因此1.8中的锁粒度更细</p>
</li>
<li><p>1.7中各个HashEntry数组的扩容是相互独立的，1.8中实现了多线程扩容</p>
</li>
</ul>
<h2 id="3-反射"><a href="#3-反射" class="headerlink" title="3.反射"></a>3.反射</h2><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230319154638755.png" alt="image-20230319154638755" style="zoom:80%;" />

<h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><ul>
<li>反射就是把java类中的各种成分映射成一个个的Java对象，通过反射可以程序运行时获取任意一个类的所有属性和方法，还可以调用这些方法和属性。正常情况下，需要先获取对象然后调用对象的方法，而通过反射可以实现先拿到类的方法对象，然后传入该类的一个对象来实现调用方法。</li>
<li>反射的实现依赖于Class对象，所以使用反射获取Class对象时需要先进行类加载</li>
<li>Class对象中包含有该对象的method，field，constructor等对象信息。targetClass.getDeclaredMethods</li>
</ul>
<h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><ul>
<li>像spring框架，动态代理都是通过反射实现的。</li>
<li>缺点：反射是解释执行的，影响效率</li>
</ul>
<h3 id="反射相关的类："><a href="#反射相关的类：" class="headerlink" title="反射相关的类："></a>反射相关的类：</h3><ul>
<li>java.lang.Class:代表一个类，Class对象表示某个类加载后在堆中的对象</li>
<li>java.lang.reflect.Method:代表类的方法，Method对象表示某个类的方法</li>
<li>java.lang.reflect.Field:代表类的成员变量，Field对象表示某个类的成员变量</li>
<li>java.lang.reflect.Constructor:代表类的构造方法，Constructor对象表示构造器</li>
</ul>
<h3 id="获取-Class-对象的四种方式："><a href="#获取-Class-对象的四种方式：" class="headerlink" title="获取 Class 对象的四种方式："></a>获取 Class 对象的四种方式：</h3><ol>
<li><p>知道具体类的情况下可以使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass</span> <span class="operator">=</span> TargetObject.class;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 <code>Class.forName()</code>传入类的全路径获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过对象实例<code>instance.getClass()</code>获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TargetObject</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TargetObject</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass2</span> <span class="operator">=</span> o.getClass();</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过类加载器<code>xxxClassLoader.loadClass()</code>传入类路径获取:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="使用反射创建对象的方式："><a href="#使用反射创建对象的方式：" class="headerlink" title="使用反射创建对象的方式："></a>使用反射创建对象的方式：</h3><ol>
<li>使用Class类的newInstance()方法创建，无参数，所以只能是无参构造器构建</li>
<li>使用Constructor构造器对象创建。</li>
</ol>
<p>注：通过new创建对象的效率比较高。通过反射时，先找查找类资源，使用类加载器创建，过程比较繁琐， 所以效率较低</p>
<h3 id="爆破："><a href="#爆破：" class="headerlink" title="爆破："></a>爆破：</h3><p>field.setAccessible(true);method.setAccessible(true);</p>
<p>对于私有变量和方法通过取消安全检查可以访问到。field.set(targetObject, “JavaGuide”);method.invoke(targetObject);</p>
<h2 id="4-异常"><a href="#4-异常" class="headerlink" title="4.异常"></a>4.异常</h2><h3 id="异常的类型"><a href="#异常的类型" class="headerlink" title="异常的类型"></a>异常的类型</h3><p>异常包括Exception和Error，Exception包括编译异常和运行时异常</p>
<ul>
<li><p><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等</p>
</li>
<li><p>Exception中除了除了<code>RuntimeException</code>及其子类以外，都是编译异常，如FIleNotFoundException，ClassNotFoundException。</p>
</li>
<li><p><code>RuntimeException</code> 及其子类都统称为运行时异常。</p>
<p>常用的包括<code>NullPointerException</code>(空指针错误)，<code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)，<code>ArrayIndexOutOfBoundsException</code>（数组越界错误），<code>ClassCastException</code>（类型转换错误），<code>ArithmeticException</code>（算术错误）</p>
</li>
</ul>
<p>Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。</p>
<h3 id="异常处理的方式"><a href="#异常处理的方式" class="headerlink" title="异常处理的方式"></a>异常处理的方式</h3><ul>
<li>try-catch-finally：在代码中捕获异常，自行处理</li>
<li>throws：将发生的异常抛出，交给调用者处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getCustomerInfo</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			ex();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException ex) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;FileNotFoundException&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;IOException&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">//		int i = 1/0; 运行输出Exception</span></span><br><span class="line">		<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">		<span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);<span class="comment">//运行输出FileNotFoundException</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>try下面可以设置多个catch，但是catch应该遵循递进规则，而且只会匹配其中的一个catch，不会穿透</p>
<h3 id="不要在finally中使用return"><a href="#不要在finally中使用return" class="headerlink" title="不要在finally中使用return"></a>不要在finally中使用return</h3><p>当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p>
<h3 id="如何使用-try-with-resources-代替try-catch-finally"><a href="#如何使用-try-with-resources-代替try-catch-finally" class="headerlink" title="如何使用 try-with-resources 代替try-catch-finally"></a>如何使用 <code>try-with-resources</code> 代替<code>try-catch-finally</code></h3><ul>
<li><p><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象</p>
</li>
<li><p><strong>关闭资源和 finally 块的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，先关闭资源再执行catch和finally</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-代理模式"><a href="#5-代理模式" class="headerlink" title="5.代理模式"></a>5.代理模式</h2><p>作用：</p>
<p>使用代理对象来代替对目标对象的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</p>
<p>特点：</p>
<p>实现类和代理类都是实现了同一个接口。代理模式使用组合的思想</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230402164851259.png" alt="image-20230402164851259" style="zoom:80%;" />

<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理实现步骤:</p>
<ol>
<li><p>定义一个接口及其实现类；</p>
</li>
<li><p>创建一个代理类同样实现这个接口</p>
</li>
<li><p>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</p>
</li>
</ol>
<h3 id="动态代理："><a href="#动态代理：" class="headerlink" title="动态代理："></a>动态代理：</h3><p>我们要扩展一个类无非两种方法，继承或者实现。</p>
<p>动态代理的类型：</p>
<ol>
<li><p>jdk动态代理</p>
<ol>
<li>定义一个接口及其实现类；</li>
<li>编写 <code>InvocationHandler</code>接口的实现类，用于定义增强的业务逻辑。通过传入要代理的对象并重写<code>invoke(Object proxy, Method method, Object[] args)</code>方法，在 <code>invoke</code> 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；（此时自定义的InvocationHandler跟实现类是没有任何关系的，他只是定义了增强的逻辑）</li>
<li>通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象；（这个时候通过传入一个实现类的加载器，才是把实现类联系起来）</li>
<li>代理对象会继承它所定义的接口，并在调用这些接口定义的方法时，使用InvocationHandler增强的方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmsService</span>&#123;</span><br><span class="line">	String <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(string message)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span>message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>&#123;</span><br><span class="line">    <span class="comment">//代理类中的真实对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> object target;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DebugInvocationHandler</span><span class="params">(object target)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.target target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> object <span class="title function_">invoke</span><span class="params">(Object proxy,Method method,Object[]args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span>method.getName());</span><br><span class="line">        <span class="comment">//这里可以看出target是需要含有method方法的，对应代理类和真实对象都实现了统一接口</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target,args);</span><br><span class="line">        System.out.printin(<span class="string">&quot;after method &quot;</span>method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyFactory</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> object <span class="title function_">getProxy</span><span class="params">(object target)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">            target.getclass().getclassLoader(),<span class="comment">//目标类的类加载</span></span><br><span class="line">            target.getclass().getInterfaces(),<span class="comment">//代理需要实现的接口，可指定多个</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">DebugInvocationHandler</span>(target)<span class="comment">//代理对象对应的自定义InvocationHandle</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SmsService <span class="title function_">smsService</span> <span class="params">(SmsService)</span>JdkProxyFactory.getProxy(<span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>());</span><br><span class="line">smsService.send(<span class="string">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>CGLIB动态代理</p>
<ol>
<li>定义一个类；</li>
<li>编写 <code>MethodInterceptor</code>接口的实现类，用于定义增强的业务逻辑。通过传入要代理的对象并重写<code>intercept</code>方法，在 <code>intercept</code> 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li>
<li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类，在<code>Enhancer</code> 类中设置类加载器，设置被代理类，设置方法拦截器，和Proxy.newProxyInstance类似；</li>
</ol>
</li>
</ol>
<h4 id="jdk动态代理和CGLIB动态代理的区别："><a href="#jdk动态代理和CGLIB动态代理的区别：" class="headerlink" title="jdk动态代理和CGLIB动态代理的区别："></a>jdk动态代理和CGLIB动态代理的区别：</h4><ul>
<li>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li>
<li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li>
</ul>
<h3 id="静态代理跟动态代理的对比："><a href="#静态代理跟动态代理的对比：" class="headerlink" title="静态代理跟动态代理的对比："></a>静态代理跟动态代理的对比：</h3><ul>
<li><p><strong>灵活性</strong> ：</p>
<ul>
<li><p>静态代理：</p>
<p>接口中的每一个方法都要增强时，即使每个方法的增强逻辑都一样，也还是要重写每个方法。</p>
<p><strong>一个目标类对应一个代理类，增强逻辑跟增强方法写在一起</strong>。</p>
</li>
<li><p>动态代理：</p>
<p>在动态代理中，代理对象会增强接口的所有方法。</p>
<p><strong>不需要创建具体的代理类，动态代理将目标类的增强方法和增强逻辑解耦了，增强方逻辑在InvocationHandler定义，通过传入不同的目标对象，可以实现对不同对象的代理</strong></p>
</li>
</ul>
</li>
<li><p><strong>jvm层面</strong>：</p>
<p><strong>静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</strong></p>
</li>
</ul>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="外部排序-多路归并排序"><a href="#外部排序-多路归并排序" class="headerlink" title="外部排序&amp;多路归并排序"></a>外部排序&amp;多路归并排序</h3><p>外排序的一个例子是外归并排序（External merge sort），它读入一些能放在内存内的数据量，在内存中排序后输出为一个顺串（即是内部数据有序的临时文件），处理完所有的数据后再进行归并。比如，要对900MB 的数据进行排序，但机器上只有100 MB的可用内存时，外归并排序按如下方法操作：</p>
<ol>
<li>读入100 MB的数据至内存中，用某种常规方式（如<a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a>、<a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a>、<a href="https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a>等方法）在内存中完成排序。</li>
<li>将排序完成的数据写入磁盘。</li>
<li>重复步骤1和2直到所有的数据都存入了不同的100 MB的块（临时文件）中。在这个例子中，有900 MB数据，单个临时文件大小为100 MB，所以会产生9个临时文件。</li>
<li>读入每个临时文件（顺串）的前10 MB（ &#x3D; 100 MB &#x2F; (9块 + 1)）的数据放入内存中的输入缓冲区，最后的10 MB作为输出缓冲区。（实践中，将输入缓冲适当调小，而适当增大输出缓冲区能获得更好的效果。）</li>
<li>执行九路归并算法，将结果输出到输出缓冲区。一旦输出缓冲区满，将缓冲区中的数据写出至目标文件，清空缓冲区。一旦9个输入缓冲区中的一个变空，就从这个缓冲区关联的文件，读入下一个10M数据，除非这个文件已读完。这是“外归并排序”能在主存外完成排序的关键步骤 – 因为“归并算法”(merge algorithm)对每一个大块只是顺序地做一轮访问(进行归并)，每个大块不用完全载入主存。</li>
</ol>
<h3 id="稳定的排序："><a href="#稳定的排序：" class="headerlink" title="稳定的排序："></a><strong>稳定的排序</strong>：</h3><p>当需要排序的元素相等时，可以保持原来的顺序不变，即排在前面的任然排在前面</p>
<p><a href="https://worktile.com/blog/pingcode-80/amp/">https://worktile.com/blog/pingcode-80/amp/</a></p>
<p>冒泡排序，插入排序，归并排序</p>
<h3 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a><strong>Linux常用命令</strong></h3><p><strong>目录操作：</strong></p>
<p><code>ls</code>：显示目录中的文件和子目录的列表。</p>
<p><code>mkdir [选项] 目录名</code>：创建新目录（增）。</p>
<p><code>rm [选项] 文件或目录名</code>：删除文件&#x2F;目录（删）。</p>
<p><strong>文件操作：</strong></p>
<p><code>touch [选项] 文件名..</code>：创建新文件或更新已存在文件</p>
<p><code>cat/more/less/tail 文件名</code>：文件的查看（查） 。命令 <code>tail -f 文件</code> 可以对某个文件进行动态监控。</p>
<p><code>vim 文件名</code>：修改文件的内容（改）。</p>
<p><code>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</code>：z表示压缩</p>
<p><code>tar [-xvf] 压缩文件</code>：x表示解压</p>
<p><strong>文件权限</strong></p>
<p>在 Linux 中权限一般分为读(readable)、写(writable)和执行(excutable)，分为三组。分别对应文件的属主(owner)，属组(group)和其他用户(other)</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20231113185635065.png" alt="image-20231113185635065" style="zoom:80%;" />

<p><strong>系统状态：</strong></p>
<p><code>top [选项]</code>：用于实时查看系统的 CPU 使用率、内存使用率、进程信息等。</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20231113191942423.png" alt="image-20231113191942423"></p>
<p><code>free [选项]</code>：用于查看系统的内存使用情况，包括已用内存、可用内存、缓冲区和缓存等</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20231113192036934.png" alt="image-20231113192036934" style="zoom: 80%;" />

<p><code>ps [选项]</code>：用于查看系统中的进程信息，包括进程的 ID、状态、资源使用情况等。<code>ps -ef</code>&#x2F;<code>ps -aux</code>：这两个命令都是查看当前系统正在运行进程</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20231113192513494.png" alt="image-20231113192513494" style="zoom:80%;" />

<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20231113192538240.png" alt="image-20231113192538240" style="zoom: 67%;" />

<p><code>ifconfig</code> 或 <code>ip</code>：用于查看系统的网络接口信息，包括网络接口的 IP 地址、MAC 地址、状态等。</p>
<p><code>netstat [选项]</code>：用于查看系统的网络连接状态和网络统计信息，可以查看当前的网络连接情况、监听端口、网络协议等。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-05-20-Java虚拟机(JVM)</title>
    <url>/posts/a050.html</url>
    <content><![CDATA[<h2 id="jvm整体结构"><a href="#jvm整体结构" class="headerlink" title="jvm整体结构"></a>jvm整体结构</h2><img data-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_001/0015.png" style="zoom:80%;" >

<p>jvm包含4个部分，类装载器子系统，运行时数据区，执行引擎，本地方法接口</p>
 <span id="more"></span>

<h2 id="一-字节码文件（不属于jvm）"><a href="#一-字节码文件（不属于jvm）" class="headerlink" title="一.字节码文件（不属于jvm）"></a>一.字节码文件（不属于jvm）</h2><p>JVM 可以理解的代码就叫做字节码。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。</p>
<p>Class文件结构：</p>
<ul>
<li><p>魔数：作用是确定这个文件是否为一个能被虚拟机接收的 Class 文件。</p>
</li>
<li><p>常量池：</p>
<p>常量池主要存放两大常量：字面量和符号引用。</p>
<p>字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。</p>
<p>符号引用包括，类和接口的全限定名，字段的名称和描述符，方法的名称和描述符。如果你在一个类中引用了另一个类，那么你完全无法知道他的内存地址，那怎么办，我们只能用他的类名作为符号引用，在类加载完后用这个符号引用去获取他的内存地址。</p>
</li>
<li><p>访问标志：这个 Class 是类还是接口，是否为 <code>public</code> 或者 <code>abstract</code> 类型</p>
</li>
<li><p>当前类、父类、接口集合：Java 类的继承关系</p>
</li>
<li><p>字段表集合：用于描述每个字段的作用域和对常量池的引用等信息，包括类级变量以及实例变量，不包括在方法内部声明的局部变量。</p>
</li>
<li><p>方法表集合：同字段表</p>
</li>
</ul>
<p><strong>静态链接和动态链接</strong></p>
<p>当一个字节码文件被装载进jvm内部时，如果被调用的目标方法在编译期可知，且运行期保持不变。为静态链接。</p>
<p>非虚方法：<br>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的，这样的方法称为非虚方法。静态方法、私有方法、final方法、构造器方法都是非虚方法。</p>
<p>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期间调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</p>
<p>虚方法：在编译期间无法确定的方法。java中可以重写的方法都是虚方法。</p>
<h2 id="二-类装载器子系统"><a href="#二-类装载器子系统" class="headerlink" title="二.类装载器子系统"></a>二.类装载器子系统</h2><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230512123107429.png" alt="image-20230512123107429" style="zoom:80%;" />

<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h4 id="类加载器的作用"><a href="#类加载器的作用" class="headerlink" title="类加载器的作用"></a>类加载器的作用</h4><p>类加载器的主要作用就是加载 Java 类的字节码（ <code>.class</code> 文件）到 JVM 中（在内存中生成一个代表该类的 <code>Class</code> 对象）</p>
<h4 id="类加载器加载规则"><a href="#类加载器加载规则" class="headerlink" title="类加载器加载规则"></a>类加载器加载规则</h4><p>源码流程：判断是否加载+双亲委派</p>
<h4 id="类加载器类型："><a href="#类加载器类型：" class="headerlink" title="类加载器类型："></a>类加载器类型：</h4><p><code>BootstrapClassLoader</code>(启动类加载器)：主要用来加载 JDK 内部的核心类库</p>
<p><code>ExtensionClassLoader</code>(扩展类加载器**)**：主要负责加载 <code>ext</code> 目录下的 jar 包和类</p>
<p><code>AppClassLoader</code>(应用程序类加载器)：负责加载当前应用 classpath 下的所有 jar 包和类。</p>
<p><code>自定义的类加载器</code>：作用包括隔离加载类，扩展加载源，防止源码泄漏</p>
<p>每个 <code>ClassLoader</code> 可以通过<code>getParent()</code>获取其父 <code>ClassLoader</code>，如果获取到 <code>ClassLoader</code> 为<code>null</code>的话，那么该类是通过 <code>BootstrapClassLoader</code> 加载的。（注：类加载器的上下层关系不是继承关系，而是包含关系，他们都继承<code>ClassLoader</code>抽象类）</p>
<h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><h5 id="为什么要自定义类加载器？"><a href="#为什么要自定义类加载器？" class="headerlink" title="为什么要自定义类加载器？"></a>为什么要自定义类加载器？</h5><ol>
<li>隔离加载类（比如说我假设现在Spring框架，和RocketMQ有包名路径完全一样的类，类名也一样，这个时候类就冲突了。不过一般的主流框架和中间件都会自定义类加载器，实现不同的框架，中间件之间是隔离的）</li>
<li>扩展加载源（还可以考虑从数据库中加载类）</li>
<li>防止源码泄漏（对字节码文件进行解密，自己用的时候通过自定义类加载器来对其进行解密）</li>
</ol>
<h5 id="如何实现自定义类加载器？"><a href="#如何实现自定义类加载器？" class="headerlink" title="如何实现自定义类加载器？"></a>如何实现自定义类加载器？</h5><ol>
<li><p>继承 <code>ClassLoader</code>抽象类</p>
</li>
<li><p>重写两个方法：</p>
<ul>
<li><p>loadClass：</p>
<p>findLoadedClass(String) 调用这个方法，查看这个Class是否已经别加载</p>
<p>如果没有被加载，继续往下走，查看父类加载器，递归调用loadClass()</p>
<p>如果父类加载器是null，说明是启动类加载器，查找对应的Class</p>
<p>如果都没有找到，就调用自己的findClass(String)</p>
</li>
<li><p>findClass：默认为空方法，重写逻辑包括读取指定名称的class文件，并调用defineClass将字节流解析成jvm能够识别的Class对象</p>
</li>
</ul>
</li>
</ol>
<p>​		如果我们不想打破双亲委派模型，就重写<code>findClass()</code> 方法，无法被父类加载器加载的类最终会通过这个方法被加载；如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法。</p>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。</p>
<h2 id="三-运行时数据区"><a href="#三-运行时数据区" class="headerlink" title="三.运行时数据区"></a>三.运行时数据区</h2><p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230308185435782-16838658042841.png" alt="image-20230308185435782"></p>
<p>线程私有的包括：程序计数器，虚拟机栈，本地方法栈</p>
<p>线程共享的包括：堆，方法区，直接内存</p>
<p>注：1.7之后是将字符串常量池和静态变量从方法区中转移到堆中；1.8之后是移除了永久代，将方法区移到元空间；永久代使用的是堆中的内存，而元空间使用的是本地内存。</p>
<h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h3><p>程序计数器主要有两个作用：</p>
<ul>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ul>
<p>程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域</p>
<h3 id="2-Java-虚拟机栈"><a href="#2-Java-虚拟机栈" class="headerlink" title="2.Java 虚拟机栈"></a>2.Java 虚拟机栈</h3><h4 id="虚拟机栈简介"><a href="#虚拟机栈简介" class="headerlink" title="虚拟机栈简介"></a>虚拟机栈简介</h4><p> Java 方法调用都是通过栈来实现的（除了本地方法）。方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。</p>
<p>每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。</p>
<h4 id="栈的组成部分"><a href="#栈的组成部分" class="headerlink" title="栈的组成部分"></a>栈的组成部分</h4><p>局部变量表：储存方法中的局部变量，可能是基本数据类型或者是指向堆对象的一个引用。</p>
<p>操作数栈：用于存放方法执行过程中产生的中间计算结果。</p>
<p>动态链接：动态链接的作用就是为了将符号引用转换为调用方法的直接引用。动态链接用来实现方法多态。</p>
<p>（Java中任何一个普通的方法其实都具备虚函数的特征，只能够在程序运行期根据实际的类型绑定相关的方法）</p>
<p>方法返回地址：调用该方法的指令的下一条指令的地址</p>
<h4 id="栈中出现的两种错误"><a href="#栈中出现的两种错误" class="headerlink" title="栈中出现的两种错误"></a>栈中出现的两种错误</h4><ul>
<li><strong><code>StackOverFlowError</code>：</strong> 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。</li>
<li><strong><code>OutOfMemoryError</code>：</strong> 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</li>
</ul>
<h3 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3.本地方法栈"></a>3.本地方法栈</h3><p>和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</p>
<h3 id="4-堆"><a href="#4-堆" class="headerlink" title="4.堆"></a>4.堆</h3><h4 id="堆的特点"><a href="#堆的特点" class="headerlink" title="堆的特点"></a>堆的特点</h4><ul>
<li>堆主要储存对象实例，还会储存字符串常量池，静态变量(Class对象中)；但并不是所有的对象都储存在堆中，通过栈上分配、标量替换优化技术对象可以直接在栈上分配内存。</li>
<li>堆是垃圾收集器管理的主要区域，收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代</li>
<li>关于永久代，JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存。</li>
</ul>
<h4 id="堆的错误"><a href="#堆的错误" class="headerlink" title="堆的错误"></a>堆的错误</h4><p>**<code>OutOfMemoryError: GC Overhead Limit Exceeded</code>**：当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</p>
<p><strong><code>OutOfMemoryError: Java heap space</code></strong> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。</p>
<h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>栈上分配：在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p>
<p>标量替换：在编译期间根据逃逸分析的结果，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p>
<h3 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5.方法区"></a>5.方法区</h3><h4 id="方法区的储存内容"><a href="#方法区的储存内容" class="headerlink" title="方法区的储存内容"></a>方法区的储存内容</h4><p>方法区储存jvm读取并解析 Class 文件后的相关信息，储存的内容同样包括类信息、字段信息、方法信息，不同的是class文件中常量池在类加载后会变为运行时常量池，常量池经过解析之后，把符号引⽤替换为直接引⽤，同时在字符串常量池中储存字符串字面量。</p>
<p><strong>Java的对象（包括class对象）中保存着指向相应类的元数据的引用，元数据中又保存着指向class对象的引用。</strong></p>
<h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><h4 id="方法区的异常"><a href="#方法区的异常" class="headerlink" title="方法区的异常"></a>方法区的异常</h4><p>1.7中方法区储存在永久代：永久代属于堆空间，可以设置大小，当超过这个大小时，会报异常OutofMemoryError:PermGen space。</p>
<p>1.8中方法区储存在元空间：默认情况下不设置大小，虚拟机会耗尽所有的可用系统内存。当设置大小后，会报异常OutOfMemoryError:Metaspace。</p>
<h3 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6.直接内存"></a>6.直接内存</h3><p>直接内存是在Java堆外的、直接向系统申请的内存区间。Java的NIO库允许Java程序使用直接内存，用于数据缓冲区。可能导致 <code>OutOfMemoryError</code> 错误出现。</p>
<h3 id="补充：对象相关"><a href="#补充：对象相关" class="headerlink" title="补充：对象相关"></a>补充：对象相关</h3><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><p>Step1:类加载检查</p>
<p>虚拟机遇到一条 new 指令时，检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<p>Step2:分配内存</p>
<p>需要把确定大小的内存从 Java 堆中划分出来。分配方式有 <strong>“</strong>指针碰撞<strong>”</strong> 和 <strong>“</strong>空闲列表<strong>”</strong> 两种，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”）</p>
<p>指针碰撞：</p>
<ul>
<li>适用场合：堆内存规整（即没有内存碎片）的情况下。</li>
<li>原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li>
</ul>
<p>空闲列表：</p>
<ul>
<li>适用场合：堆内存不规整的情况下。</li>
<li>原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li>
</ul>
<p>Step3:初始化零值</p>
<p>分配到的内存空间都初始化为零值，这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用</p>
<p>Step4:设置对象头</p>
<p>对象头中包含Mark Word（包括锁，哈希码，分代年龄等信息），指向方法区的类元数据指针，数组长度</p>
<p>Step5:执行 init 方法</p>
<p>也就是为对象的实例字段赋初始值。</p>
<h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>对象在内存中的布局可以分为 3 块区域：对象头、实例数据和对齐填充。</p>
<h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p> Java 程序通过栈上的 reference 数据来操作堆上的具体对象。</p>
<p><strong>句柄</strong>：Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了指向对象实例数据指针和指向方法区的类元数据指针。</p>
<p><strong>直接指针</strong>：reference 中存储的直接就是对象的地址，在对象中包含指向方法区的类元数据指针。</p>
<p>Java的对象（包括class对象）中保存着指向相应类的元数据的引用，元数据中又保存着指向class对象的引用。</p>
<p>HotSpot 虚拟机主要使用的就是直接指针</p>
<h4 id="对象的分配原则"><a href="#对象的分配原则" class="headerlink" title="对象的分配原则"></a>对象的分配原则</h4><p><strong>对象优先在 Eden 区分配。</strong>当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p>
<p><strong>大对象直接进入老年代。</strong>（比如：字符串、数组）</p>
<p><strong>长期存活的对象将进入老年代。</strong> Eden 区的对象在进行Minor GC后，如果存活将被移动到 Survivor 区，对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。</p>
<p> <strong>空间分配担保</strong>。在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 -XX:HandlePromotionFailure 参数的设置值是否允许担保失败(Handle Promotion Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的;如果小于或者 -XX: HandlePromotionFailure 设置不允许冒险，那这时就要改为进行一次 Full GC。</p>
<h4 id="对象的指针在哪里存在？"><a href="#对象的指针在哪里存在？" class="headerlink" title="对象的指针在哪里存在？"></a>对象的指针在哪里存在？</h4><p>栈，堆(实例变量，静态变量，字符串常量池)，方法区(指向class对象)</p>
<h2 id="四-执行引擎"><a href="#四-执行引擎" class="headerlink" title="四.执行引擎"></a>四.执行引擎</h2><p>执行引擎（Execution Engine）的任务就是将字节码指令解释&#x2F;编译为对应平台上的本地机器指令。</p>
<img data-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_008/0007.png" style="zoom:80%;" >

<h5 id="为什么Java是半编译半解释型语言？"><a href="#为什么Java是半编译半解释型语言？" class="headerlink" title="为什么Java是半编译半解释型语言？"></a>为什么Java是半编译半解释型语言？</h5><p>HotSpot的执行引擎包含解释器和JIT编译器(即时编译器)</p>
<p>解释器：对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。解释器的好处是程序启动就能立即执行，缺点是执行速度比较慢</p>
<p>JIT编译器：将源代码一次性直接编译成和本地机器平台相关的机器语言。编译器的好处是执行速度快，缺点是先要对源代码进行编译并不是马上执行</p>
<p>Java 代码执行的分类</p>
<ol>
<li><p>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行</p>
</li>
<li><p>第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行</p>
</li>
</ol>
<p>在此模式下，在Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</p>
<p>一般来说，JIT编译器会选择把那些“热点代码”进行编译，“热点代码”指一个被多次调用的方法，或者是一-个方法体内部循环次数较多的循环体，以此提升Java程序的执行性能。</p>
<p>jvm可以设置采用解释器模式执行程序，采用即时编译器模式执行程序，混合模式共同执行程序。</p>
<h2 id="五-本地方法接口"><a href="#五-本地方法接口" class="headerlink" title="五.本地方法接口"></a>五.本地方法接口</h2><p>提供本地方法接口可以让java程序与操作系统的交互，直接使用操作系统提供的功能。</p>
<h2 id="六-垃圾回收器"><a href="#六-垃圾回收器" class="headerlink" title="六.垃圾回收器"></a>六.垃圾回收器</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>垃圾回收主要针对堆内存中对象的回收。在堆中会分为新生代和老年代，根据不同区域的特点使用不同的垃圾回收器和回收算法。</p>
<h3 id="各gc的触发条件"><a href="#各gc的触发条件" class="headerlink" title="各gc的触发条件"></a>各gc的触发条件</h3><p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230512202024182.png" alt="image-20230512202024182"></p>
<p>一般来说full gc的代价很高，垃圾回收器都会尽量避免full gc</p>
<h3 id="死亡对象判断方法"><a href="#死亡对象判断方法" class="headerlink" title="死亡对象判断方法"></a>死亡对象判断方法</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。<strong>很难解决对象之间循环引用的问题。</strong></p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p><strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p>
<h4 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize 方法"></a><code>finalize</code> 方法</h4><p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。</p>
<p>如果中与引用链上的任何一个对象建立了联系，那么该对象就不会被回收。不过，一个对象的finalize()方法只会被调用一次，下一次对该对象进行回收时就不会调用finalize()方法来看。</p>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>强引用：如果一个对象具是强引用，垃圾回收器绝不会回收它。强引用包括虚拟机栈中引用的对象，方法区中类静态属性引用的对象等。</p>
<p>软引用：如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。</p>
<p>弱引用：当垃圾回收器发现弱引用时，不管当前内存空间足够与否，都会回收它的内存。</p>
<p>虚引用：虚引用并不会决定对象的生命周期，跟没有引用一样，主要用来跟踪对象被垃圾回收的活动。 虚引用必须和引用队列（ReferenceQueue）联合使用。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。</p>
<h4 id="如何判断一个类是无用的类？"><a href="#如何判断一个类是无用的类？" class="headerlink" title="如何判断一个类是无用的类？"></a>如何判断一个类是无用的类？</h4><ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 <code>ClassLoader</code> 已经被回收。</li>
<li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。</p>
<p>会产生大量不连续的内存碎片。</p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。</p>
<p>可用内存缩小为原来的一半。</p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>标记出所有不需要回收的对象，在标记完成后让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p>
<p>由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景。</p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230512211207502.png" alt="image-20230512211207502" style="zoom:80%;" />

<p>吞吐量：吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量&#x3D;运行用户代码时间 &#x2F;（运行用户代码时间+垃圾收集时间）</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230512211219375.png" alt="image-20230512211219375" style="zoom:80%;" />

<p>工作原理：</p>
<ol>
<li>初始标记：在这个阶段中，会因为“<strong>Stop-the-World</strong>”机制而出现短暂的暂停，这个阶段只是标记出GC Roots能直接关联到的对象。所以<strong>速度非常快</strong>。</li>
<li>并发标记：从GC Roots的直接关联对象开始，使用可达性分析算法标记存活对象，这个过程耗时较长但是<strong>不需要停顿用户线程****，</strong>可以与垃圾收集线程一起并发运行。</li>
<li>重新标记：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，<strong>因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，</strong>会导致“Stop-the-World”的发生，但比并发标记阶段的时间短。</li>
<li>并发清除（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。<strong>由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</strong></li>
</ol>
<p>缺点：</p>
<ul>
<li><strong>会产生内存碎片</strong>，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。</li>
</ul>
<ol start="2">
<li><strong>CMS收集器对CPU资源非常敏感</strong>。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。 </li>
<li><strong>CMS收集器无法处理浮动垃圾</strong>。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，<strong>那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收</strong></li>
</ol>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230512211238477.png" alt="image-20230512211238477"></p>
<p>工作流程：</p>
<p>G1在实现垃圾回收时一共提供了3种回收的方法，分别是新生代回收（称为Young GC， YGC），混合回收（称为Mixed GC），全回收（称为Full GC， FGC）。这3种垃圾回收触发的时机通常如下：</p>
<ol>
<li>应用程序分配对象时，发现内存不足，触发YGC；</li>
<li>在YGC执行中，判断整体内存使用是否大于一定的阈值，如果大于启动并发标记；在并发标记完成后，当下一次启动垃圾回收称为Mixed GC，在Mixed GC执行过程中不仅回收新生代分区，同时也回收部分老生代分区；</li>
<li>在用程序分配对象时，发现内存不足，触发YGC或者Mixed GC；垃圾回收结束后再次尝试分配对象，如果内存还不足，此时将触发FGC。</li>
</ol>
<h2 id="其他面试题"><a href="#其他面试题" class="headerlink" title="其他面试题"></a>其他面试题</h2><h3 id="jvm角度下的String类"><a href="#jvm角度下的String类" class="headerlink" title="jvm角度下的String类"></a>jvm角度下的String类</h3><h4 id="intern-方法的说明"><a href="#intern-方法的说明" class="headerlink" title="intern() 方法的说明"></a>intern() 方法的说明</h4><ul>
<li>jdk6：如果字符串常量池中不存在该字符串，复制一份到字符串常量池中（方法区）</li>
<li>jdk7&#x2F;8：如果字符串常量池中不存在该字符串，则字符串常量池中的引用指向该字符串</li>
</ul>
<h4 id="new-String-的说明"><a href="#new-String-的说明" class="headerlink" title="new String() 的说明"></a>new String() 的说明</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：</span></span><br><span class="line"><span class="comment"> * new String(&quot;ab&quot;)会创建几个对象？看字节码，就知道是两个。</span></span><br><span class="line"><span class="comment"> *     一个对象是：new关键字在堆空间创建的</span></span><br><span class="line"><span class="comment"> *     另一个对象是：字符串常量池中的对象&quot;ab&quot;。 字节码指令：ldc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringNewTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思考：</span></span><br><span class="line"><span class="comment"> * new String(&quot;a&quot;) + new String(&quot;b&quot;)呢？</span></span><br><span class="line"><span class="comment"> *  对象1：new StringBuilder()</span></span><br><span class="line"><span class="comment"> *  对象2： new String(&quot;a&quot;)</span></span><br><span class="line"><span class="comment"> *  对象3： 常量池中的&quot;a&quot;</span></span><br><span class="line"><span class="comment"> *  对象4： new String(&quot;b&quot;)</span></span><br><span class="line"><span class="comment"> *  对象5： 常量池中的&quot;b&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  深入剖析： StringBuilder的toString():</span></span><br><span class="line"><span class="comment"> *      对象6 ：new String(&quot;ab&quot;)</span></span><br><span class="line"><span class="comment"> *       强调一下，toString()的调用，在字符串常量池中，没有生成&quot;ab&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringNewTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringIntern1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//执行完下一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);<span class="comment">//new String(&quot;11&quot;)</span></span><br><span class="line">        <span class="comment">//在字符串常量池中生成对象&quot;11&quot;，代码顺序换一下，实打实的在字符串常量池里有一个&quot;11&quot;对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s3.intern();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s3 是堆中的 &quot;ab&quot; ，s4 是字符串常量池中的 &quot;ab&quot;</span></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// s5 是从字符串常量池中取回来的引用，当然和 s4 相等</span></span><br><span class="line">        System.out.println(s5 == s4);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);<span class="comment">//new String(&quot;ab&quot;)</span></span><br><span class="line">        <span class="comment">//在上一行代码执行完以后，字符串常量池中并没有&quot;ab&quot;</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		1、jdk6中：在字符串常量池（此时在永久代）中创建一个字符串&quot;ab&quot;</span></span><br><span class="line"><span class="comment">        2、jdk8中：字符串常量池（此时在堆中）中没有创建字符串&quot;ab&quot;,而是创建一个引用，指向new String(&quot;ab&quot;)，		  将此引用返回</span></span><br><span class="line"><span class="comment">        3、详解看上面</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern();</span><br><span class="line"></span><br><span class="line">        System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:true  jdk8:true</span></span><br><span class="line">        System.out.println(s == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:false  jdk8:true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="jvm调优的常用命令"><a href="#jvm调优的常用命令" class="headerlink" title="jvm调优的常用命令"></a>jvm调优的常用命令</h3><p>这个要理解一下ivm内存区就好理解命令。<br>1.栈是线程和方法执行的地方。主要耗的是cpu。 jstack就是看栈的快照。所以Cpu过高，或者死锁等就用jstack检查问题<br>2.堆存的是对象，垃圾回收的主要区域。主要耗内存，所以内存溢出等优先排查堆。jmap是看堆里对象的情况。jmap可以生产heap dump文件。</p>
<p>heap dump 是 Java 虚拟机 ( JVM )堆中某个时间点上所有对象的快照。</p>
<p>3.jconsole性能监控工具</p>
<h3 id="CPU爆满问题产生的原因"><a href="#CPU爆满问题产生的原因" class="headerlink" title="CPU爆满问题产生的原因"></a>CPU爆满问题产生的原因</h3><ul>
<li>并发量提升：</li>
</ul>
<blockquote>
<p>首先针对这个原因导致的CPU飙升，本身不在代码层，而在于架构层上，既然并发量提高，那么紧急提升服务器资源或对并发进行限流是比较好的措施</p>
</blockquote>
<ul>
<li>功能耗费计算资源：</li>
</ul>
<blockquote>
<p>这类问题导致的CPU飙升主要有两种处理思路，一是先定位到是哪个功能占用的cpu资源居高不小，如何定位我们将在下面讲解；然后考量这个功能本身能不能优化，是否真的需要占用这么多资源；如果本身确实是计算非常复杂，那么就要考虑增加服务器资源</p>
</blockquote>
<ul>
<li>循环递归：</li>
</ul>
<blockquote>
<p>死循环和过深递归这是我们明确要避免的，但如何定位到是难点，这也是我们将在下面讲解的。定位到后，就要进行代码优化，避免此种情况</p>
</blockquote>
<ul>
<li>资源竞争：</li>
</ul>
<blockquote>
<p>资源竞争这类的要根据实际占用的什么资源来分析，比如是锁竞争，那么应当就采取避免竞争的措施，比如减少锁的使用、使用<a href="https://so.csdn.net/so/search?q=%E4%B9%90%E8%A7%82%E9%94%81&spm=1001.2101.3001.7020">乐观锁</a>、使用JUC同步组件等</p>
</blockquote>
<h3 id="泄漏和内存溢出"><a href="#泄漏和内存溢出" class="headerlink" title="泄漏和内存溢出"></a>泄漏和内存溢出</h3><p>申请了一块内存空间，使用完毕后没有释放掉。它的一般表现方式是程序运行时间越长，占用内存越多，最终的结果将会使应用程序耗尽内存资源，无法正常服务，导致程序崩溃，抛出 java.lang.OutOfMemoryError 异常。内存溢出也就是OutOfMemoryError 。</p>
<h3 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h3><h4 id="1、静态集合类引起内存泄漏"><a href="#1、静态集合类引起内存泄漏" class="headerlink" title="1、静态集合类引起内存泄漏"></a>1、静态集合类引起内存泄漏</h4><p>这些静态变量的生命周期和应用程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。集合类储存的对象是短生命周期对象，但是因为容器对象是长生命周期对象，它有一个对短生命周期对象的引用，导致短生命周期对象不能被释放。</p>
<h4 id="2、资源未关闭或释放导致内存泄露"><a href="#2、资源未关闭或释放导致内存泄露" class="headerlink" title="2、资源未关闭或释放导致内存泄露"></a>2、资源未关闭或释放导致内存泄露</h4><p>当我们在程序中创建或者打开一个流或者是新建一个网络连接的时候，JVM 都会为这些资源类分配内存做缓存，常见的资源类有网络连接，数据库连接以及 IO 流。如果忘记关闭这些资源，会阻塞内存，从而导致 GC 无法进行清理。特别是当程序发生异常时，没有在finally 中进行资源关闭的情况。</p>
<h4 id="3、不正确的-equals-和-hashCode"><a href="#3、不正确的-equals-和-hashCode" class="headerlink" title="3、不正确的 equals() 和 hashCode()"></a>3、不正确的 equals() 和 hashCode()</h4><p>在HashMap和HashSet这种集合中，常常用到equal()和hashCode()来比较对象，如果重写不合理，将会成为潜在的内存泄露问题。类没有重写 equals 和 hashCode 方法，那 Map 的 put 方法就会调用 Object 默认的 hashCode 方法。因此在执行 put 操作时，Map会认为每次创建的对象都是新的对象，从而导致内存不断的增长，会导致内存泄漏的可能。</p>
<h4 id="4、重写了-finalize-的类"><a href="#4、重写了-finalize-的类" class="headerlink" title="4、重写了 finalize() 的类"></a>4、重写了 finalize() 的类</h4><h4 id="5、使用-ThreadLocal-造成内存泄露"><a href="#5、使用-ThreadLocal-造成内存泄露" class="headerlink" title="5、使用 ThreadLocal 造成内存泄露"></a>5、使用 ThreadLocal 造成内存泄露</h4><h3 id="线上CPU爆满如何排查"><a href="#线上CPU爆满如何排查" class="headerlink" title="线上CPU爆满如何排查"></a>线上CPU爆满如何排查</h3><p>1.<code>top</code>指令观察进程资源占用情况，只能指出是java程序</p>
<p>2.如果一台服务器上部署了多个java程序的，可以通过<code>ps</code>或者<code>jps</code>指令确认进程ID对应的进程名</p>
<p>3.jstack + 进程id ，可以查看该线程下的堆栈日志信息</p>
<h3 id="内存爆满如何排查"><a href="#内存爆满如何排查" class="headerlink" title="内存爆满如何排查"></a>内存爆满如何排查</h3><p>理论上内存过高可以使用top查看是哪些进程内存使用过高，如果是java程序，jmap生成heap dump文件，利用heap dump文件可以分析哪些对象占用过高的内存，从而定位到具体的代码和业务。</p>
<h3 id="如何理解java是跨平台"><a href="#如何理解java是跨平台" class="headerlink" title="如何理解java是跨平台"></a>如何理解java是跨平台</h3><p>一边编译，到处运行。java文件编译成class文件后，class文件可以不同的操作系统中运行，不同的操作需要安装对应系统的jvm。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-06-20-Java多线程(JUC)</title>
    <url>/posts/7cd2.html</url>
    <content><![CDATA[<h2 id="一-JMM内存模型"><a href="#一-JMM内存模型" class="headerlink" title="一.JMM内存模型"></a>一.JMM内存模型</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&mid=2247533850&idx=4&sn=7477c8346a738e9a234c3b85f1cd0bc4&chksm=fbb1cce4ccc645f238e66ee5d45c9aa85c51f47987a8719e035b51ec8d49c75457b18a1dfae3&scene=27">https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&amp;mid=2247533850&amp;idx=4&amp;sn=7477c8346a738e9a234c3b85f1cd0bc4&amp;chksm=fbb1cce4ccc645f238e66ee5d45c9aa85c51f47987a8719e035b51ec8d49c75457b18a1dfae3&amp;scene=27</a></p>
<p><a href="https://javaguide.cn/java/concurrent/jmm.html">https://javaguide.cn/java/concurrent/jmm.html</a></p>
<h4 id="JMM模型中多线程编程的两个问题"><a href="#JMM模型中多线程编程的两个问题" class="headerlink" title="JMM模型中多线程编程的两个问题"></a>JMM模型中多线程编程的两个问题</h4><p>1.共享内存</p>
<p>在JMM中，规定了共享变量是存放在<code>主内存</code>中，然后每个线程都有自己的<code>工作内存</code>，至于什么时候写回到主内存是不可预知的，这就导致每个线程之间对共享变量的操作是封闭的，其他线程不可见的。</p>
<p>2.指令重排序</p>
<p>为了性能优化，JVM会在不改变<code>数据依赖性</code>的情况下，允许<code>编译器和处理器对指令序列进行重排序</code>，而有序性问题指的就是程序代码执行的顺序与程序员编写程序的顺序不一致，导致程序结果不正确的问题。</p>
 <span id="more"></span>

<h4 id="Java内存模型（JMM）-和-JVM-内存模型区别"><a href="#Java内存模型（JMM）-和-JVM-内存模型区别" class="headerlink" title="Java内存模型（JMM） 和 JVM 内存模型区别"></a>Java内存模型（JMM） 和 JVM 内存模型区别</h4><p>Java内存模型是Java语言在多线程并发情况下对于共享变量读写(实际是共享变量对应的内存操作)的规范，保证多线程下程序的可见性，原子性和有序性。</p>
<p>Java虚拟机在运行时对该Java进程占用的内存进行的一种逻辑上的划分，包括方法区、堆内存、虚拟机栈、本地方法栈、程序计数器。</p>
<h4 id="并发编程三个概念"><a href="#并发编程三个概念" class="headerlink" title="并发编程三个概念"></a>并发编程三个概念</h4><p>原子性：一个或多个操作，要么全部执行且在执行过程中不被任何因素打断,要么全部不执行。在java中当我们讨论一个操作具有原子性问题一般是指这个操作会被线程的随机调度打断。</p>
<p>保证：自带原子性保证，synchronized，Lock锁，原子类操作</p>
<p>可见性：一个线程对共享变量的修改，另一个线程可以感知到，我们称其为可见性。cpu -&gt; cache -&gt;内存</p>
<p>保证：volatile，synchronized，Lock锁，原子操作类</p>
<p>有序性：Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>保证：happens-before原则，synchronized机制，volatile机制</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>volatile关键字</th>
<th>synchronized关键字</th>
<th>Lock接口</th>
<th>Atomic变量</th>
</tr>
</thead>
<tbody><tr>
<td>原子性</td>
<td>无法保障</td>
<td>可以保障</td>
<td>可以保障</td>
<td>可以保障</td>
</tr>
<tr>
<td>可见性</td>
<td>可以保障</td>
<td>可以保障</td>
<td>可以保障</td>
<td>可以保障</td>
</tr>
<tr>
<td>有序性</td>
<td>一定程度</td>
<td>可以保障</td>
<td>可以保障</td>
<td>无法保障</td>
</tr>
</tbody></table>
<h4 id="happens-before原则保证有序性"><a href="#happens-before原则保证有序性" class="headerlink" title="happens-before原则保证有序性"></a><strong>happens-before原则保证有序性</strong></h4><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20220731155332375.png" alt="img" style="zoom:80%;" />

<ul>
<li><p>如果程序员基于happen-before原则编写程序时，对于那些会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序。</p>
</li>
<li><p><strong>happens-before 原则表达的意义其实并不是一个操作发生在另外一个操作的前面，</strong>时间先后顺序与先行发生原则之间基本没有太大关系，所以我们衡量并发安全问题的时候不要收到时间顺序的干扰，<strong>一切必须以先行发生原则为准</strong>。更准确地来说，<strong>它更想表达的意义是前一个操作的结果对于后一个操作是可见的，无论这两个操作是否在同一个线程里</strong>。</p>
<p>举个例子：操作 1 happens-before 操作 2，即使操作 1 和操作 2 不在同一个线程内，JMM 也会保证操作 1 的结果对操作 2 是可见的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）程序次序规则：一个单线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。<br>（2）锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作。<br>（3）volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作。<br>（4）传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C。<br>（5）线程启动规则：如果线程A调用线程B的start()方法来启动线程B，则start()操作Happens-Before于线程B中的任意操作。<br>（6）join()规则：如果线程A调用线程B.join()并成功返回，线程B中的任意操作happens-before于线程A的后续操作（一共8个，重点理解6个）</p>
</li>
</ul>
<p>如何理解？<a href="https://zhuanlan.zhihu.com/p/433467241">https://zhuanlan.zhihu.com/p/433467241</a></p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="volatile保证可见性和有序性的原理"><a href="#volatile保证可见性和有序性的原理" class="headerlink" title="volatile保证可见性和有序性的原理"></a>volatile保证可见性和有序性的原理</h4><p>加了volatile修饰的共享变量，会通过<code>内存屏障</code>解决多线程下可见性和有序性问题。</p>
<p>内存屏障(Memory Barrier，是一个CPU指令，它的作用有两个，一是保证特定操作的执行顺序，二是保证某些变量的内存可见性。由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。Memory Barrier的另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。</p>
<h4 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h4><p><strong>volatile写-读的内存语义</strong></p>
<ul>
<li>当写一个volatile变量时，JMM会把该线程对应的本地内存中的变量值刷新到主内存。</li>
<li>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程将从主内存中读取共享变量。</li>
</ul>
<p><strong>volatile内存语义的实现</strong></p>
<p>java中定义了4中内存屏障</p>
<ul>
<li><p>在每个volatile写操作的前面插入一个StoreStore屏障（禁止volatile写与前面普通读写重排序）。</p>
</li>
<li><p>在每个volatile写操作的后面插入一个StoreLoad屏障（禁止volatile写与后面volatile读写重排序）。</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/640.png" alt="图片"><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/640-16788475594608.png" alt="图片"></p>
</li>
<li><p>在每个volatile读操作的后面插入一个LoadLoad屏障（禁止volatile读与后面的普通读操作重排序）。</p>
</li>
<li><p>在每个volatile读操作的后面插入一个LoadStore屏障（禁止volatile读与后面的普通写操作重排序）。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>更多操作是否能重排序</td>
<td>第二个操作</td>
<td></td>
<td></td>
</tr>
<tr>
<td>第一个操作</td>
<td>普通读&#x2F;写</td>
<td>volatile读</td>
<td>volatile写</td>
</tr>
<tr>
<td>普通读&#x2F;写</td>
<td></td>
<td></td>
<td>NO</td>
</tr>
<tr>
<td>volatile读</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>volatile写</td>
<td></td>
<td>NO</td>
<td>NO</td>
</tr>
</tbody></table>
<p><strong>总结：</strong></p>
<ul>
<li>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</li>
<li>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前</li>
<li>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</li>
</ul>
<h3 id="volatile不保证原子性"><a href="#volatile不保证原子性" class="headerlink" title="volatile不保证原子性"></a>volatile不保证原子性</h3><p>只是保证了本线程内相关代码不被重排序，无法保证其他线程的读写指令交错</p>
<p>例如经典的n++操作，它可以分成3步，读，+1，写。首先n是volatile变量只能保证读写不会重排序而且读到的是最新值，但是多线程下，有可能是多个线程先进行读操作，然后在统一进行+1操作，最后就会写入同一个值。</p>
<p>volatile + synchronize</p>
<p>单例模式创建对象语句：new一个对象可以分成3步，1. 在堆内存开辟内存空间 2. 调⽤构造⽅法，初始化对象 3. 引⽤变量指向这个对象，如果仅使用synchronize是会造成指令重排序的，也就是先引⽤变量指向这个对象，再调⽤构造⽅法，这样另一个线程读取对象就有可能是空对象。</p>
<p>使用volatile禁止读写重排序。可以保证无锁状态下访问对象的有序性</p>
<p>注：synchronize只能保证锁住代码的有序性，原子性。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html</a></p>
<h3 id="1-线程池是什么"><a href="#1-线程池是什么" class="headerlink" title="1. 线程池是什么"></a>1. 线程池是什么</h3><p>线程池是一种多线程处理方式</p>
<p>好处：</p>
<ul>
<li>节省系统资源：线程池可以重用已经创建好的线程，避免了线程的创建和销毁带来的开销，从而节省了系统资源。</li>
<li>提高系统响应速度：通过线程池，任务可以在已经创建好的线程中执行，避免了线程的创建和销毁所带来的延迟，从而提高了系统的响应速度。</li>
<li>提高系统稳定性：线程池可以控制线程的数量，防止线程数量过多导致系统资源被耗尽，从而提高了系统的稳定性。</li>
<li>方便管理：通过线程池管理器，可以方便地管理线程池，包括初始化线程池、销毁线程池、添加任务、移除任务等操作。</li>
</ul>
<h3 id="2-线程池核心设计与实现"><a href="#2-线程池核心设计与实现" class="headerlink" title="2.线程池核心设计与实现"></a>2.线程池核心设计与实现</h3><p><strong>线程池通常由以下几个部分组成：</strong></p>
<ol>
<li>线程池管理器(ThreadPool Manager)：负责创建和管理线程池，包括初始化线程池、销毁线程池、添加任务、移除任务等操作。</li>
<li>工作线程(Worker Thread)：线程池中执行任务的线程。</li>
<li>任务队列(Task Queue)：用于存放需要执行的任务</li>
</ol>
<h4 id="2-1-总体设计"><a href="#2-1-总体设计" class="headerlink" title="2.1 总体设计"></a>2.1 总体设计</h4><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/912883e51327e0c7a9d753d11896326511272.png" alt="图1 ThreadPoolExecutor UML类图" style="zoom:67%;" />

<p>重点关注每个类的作用是什么，提供了哪些接口以及这些接口的作用</p>
<p>最下层的实现类ThreadPoolExecutor实现最复杂的运行部分，它的运行机制如下：</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/v2-1c6ce358830df9eef44f96c74317cfcb_720w.webp" alt="img"></p>
<ol>
<li>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</li>
<li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</li>
<li>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</li>
<li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法</li>
</ol>
<h4 id="2-2-生命周期管理"><a href="#2-2-生命周期管理" class="headerlink" title="2.2 生命周期管理"></a>2.2 生命周期管理</h4><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/62853fa44bfa47d63143babe3b5a4c6e82532.png" alt="img" style="zoom: 67%;" />

<p>线程池内部AtomicInteger类型的变量来储存状态，高3位保存runState，低29位保存workerCount，这样做的好处是用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。因为AtomicInteger的修改值是原子操作，如果是两个变量就不能保证原子性了。</p>
<p>其生命周期转换如下入所示：</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/582d1606d57ff99aa0e5f8fc59c7819329028.png" alt="图3 线程池生命周期" style="zoom: 80%;" />

<ul>
<li><strong><code>shutdown（）</code></strong> :关闭线程池，线程池的状态变为 <code>SHUTDOWN</code>。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li>
<li><strong><code>shutdownNow（）</code></strong> :关闭线程池，线程的状态变为 <code>STOP</code>。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</li>
</ul>
<h4 id="线程池的构造方法的参数"><a href="#线程池的构造方法的参数" class="headerlink" title="线程池的构造方法的参数"></a>线程池的构造方法的参数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,//任务队列未达到队列容量时，最大可以同时运行的线程数量。 (最多保留的线程数)</span> </span><br><span class="line">                          <span class="type">int</span> maximumPoolSize,<span class="comment">//任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</span></span><br><span class="line">                          <span class="type">long</span> keepAliveTime,<span class="comment">//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span><br><span class="line">                          TimeUnit unit,<span class="comment">//时间单位（针对救急线程）</span></span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,<span class="comment">//阻塞队列</span></span><br><span class="line">                          ThreadFactory threadFactory,<span class="comment">//线程工厂 - 可以为线程创建时起个好名字 </span></span><br><span class="line">                          RejectedExecutionHandler handler)<span class="comment">//拒绝策略</span></span><br></pre></td></tr></table></figure>

<p>注：救急线程的创建时机是，队列满时。</p>
<p>下面2.3，2.4理解着看，不需要记。原理重点记上面的流程图。不过缓存队列和拒绝类型需要记。</p>
<h4 id="2-3-任务执行机制"><a href="#2-3-任务执行机制" class="headerlink" title="2.3 任务执行机制"></a>2.3 任务执行机制</h4><p><strong>2.3.1 任务调度</strong></p>
<p>当用户提交了一个任务，接下来这个任务将如何执行都是由这个阶段决定的。</p>
<p>首先，所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接<strong>申请线程执行</strong>，或是<strong>缓冲到队列中执行</strong>，亦或是<strong>直接拒绝该任务</strong>。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/31bad766983e212431077ca8da92762050214.png" alt="图4 任务调度流程" style="zoom:80%;" />

<p><strong>2.3.2 任务缓冲</strong></p>
<p>线程池中是以生产者消费者模式，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。</p>
<p>阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230316184117859.png" alt="image-20230316184117859" style="zoom:80%;" />

<p>注：<code>DelayQueue</code> 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。<code>DelayedWorkQueue</code> 添加元素满了之后会自动扩容原来容量的 1&#x2F;2，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。</p>
<p>SynchronousQueue：不需要存储线程间交换的数据，它的作用更像是一个匹配器，使生产者和消费者一一匹配。一个线程调用了put方法时，发现队列中没有take线程，那么put线程就会阻塞，当take线程进来时发现有阻塞的put线程，那么他们两个就会匹配上，然后take线程获取到put线程的数据，两个线程都不阻塞。</p>
<p>反之一个线程调用take方法也会阻塞线程，当一个调用put方法的线程进来后也会与之匹配。</p>
<p>如果一个take或者put线程进来发现有同类的take或者put线程在阻塞中，那么线程会排到后面，直到有不同类的线程进来然后匹配其中一个线程。</p>
<p><strong>2.3.3 任务申请</strong></p>
<p>由上文的任务分配部分可知，任务的执行有两种可能：一种是任务直接由新创建的线程执行。另一种是线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。</p>
<p>这部分策略由getTask方法实现，getTask主要做两件事情：一.从任务队列中获取任务(主要)，二.控制线程的数量，如果现阶段运行的线程数过多也会申请失败，然后返回任务给工作线程。工作线程Worker会不断接收新任务去执行，而当工作线程Worker接收不到任务的时候，就会开始被回收。</p>
<p><strong>2.3.4 任务拒绝</strong></p>
<p>线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，采取任务拒绝策略。</p>
<p>jdk提供四种拒绝服务，默认的是AbortPolicy，丢弃任务并抛出RejectedExecutionException异常。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/9ffb64cc4c64c0cb8d38dac01c89c905178456.png" alt="img" style="zoom: 80%;" />

<h4 id="2-4-Worker线程管理"><a href="#2-4-Worker线程管理" class="headerlink" title="2.4 Worker线程管理"></a>2.4 Worker线程管理</h4><h5 id="2-4-1-Worker线程"><a href="#2-4-1-Worker线程" class="headerlink" title="2.4.1 Worker线程"></a>2.4.1 Worker线程</h5><p>Worker执行任务的模型如下图所示：</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/03268b9dc49bd30bb63064421bb036bf90315.png" alt="图7 Worker执行任务"></p>
<p>注：图中上面的fristTask对应核心线程创建时的情况，下面的对应非核心线程的创建</p>
<p>线程池需要管理线程的生命周期，需要在线程长时间不运行的时候进行回收。线程池使用一张Hash表去持有线程的引用，这样可以通过添加引用、移除引用这样的操作来控制线程的生命周期。这个时候重要的就是如何判断线程是否在运行。</p>
<p>Worker是通过继承AQS，使用AQS来实现独占锁这个功能去反应线程现在的执行状态。Worker在执行任务时会进行加锁，如果获取锁失败说明该线程正在执行任务。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/9d8dc9cebe59122127460f81a98894bb34085-167896698778521.png" alt="图8 线程池回收过程" style="zoom:80%;" />

<p><strong>2.4.2 Worker线程执行任务</strong></p>
<p>Worker线程的run方法</p>
<p>while循环不断地通过getTask()方法获取任务，执行任务，如果getTask结果为null则跳出循环，执行processWorkerExit()方法，销毁线程。</p>
<p><strong>2.4.3 Worker线程增加</strong></p>
<p>增加线程是通过线程池中的addWorker方法</p>
<ul>
<li><p>如果当前运行的线程数小于核心线程数，那么就会新建一个核心线程来执行任务。</p>
</li>
<li><p>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个非核心线程来执行任务。</p>
</li>
</ul>
<p>非核心任务在空闲时会被回收，核心任务不会。</p>
<p><strong>2.4.4 Worker线程回收</strong></p>
<p>线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。</p>
<p>Worker被创建出来后，就会不断地进行轮询，然后获取任务去执行，<strong>核心线程可以无限等待获取任务，非核心线程要限时获取任务</strong>。</p>
<p>当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，Worker会主动消除自身在线程池内的引用。</p>
<h3 id="补充（对上面的总结）"><a href="#补充（对上面的总结）" class="headerlink" title="补充（对上面的总结）"></a>补充（对上面的总结）</h3><h4 id="线程池如何实现线程复用？"><a href="#线程池如何实现线程复用？" class="headerlink" title="线程池如何实现线程复用？"></a>线程池如何实现线程复用？</h4><p>线程池中的线程复用依靠阻塞队列实现，正常情况线程不断从，只有调用了shutdown方法才会关闭线程池。但是由于是阻塞队列，当队列为空时线程池会被阻塞，当阻塞队列中有任务时，就会唤醒线程获取任务执行，（阻塞队列内部使用等待&#x2F;唤醒的机制实现），这样就保证了线程是一直存活的</p>
<h4 id="核心线程怎么实现一直存活？"><a href="#核心线程怎么实现一直存活？" class="headerlink" title="核心线程怎么实现一直存活？"></a>核心线程怎么实现一直存活？</h4><p>核心线程在获取任务时，通过阻塞队列的 take() 方法实现的一直阻塞（存活）。</p>
<h4 id="非核心线程如何实现在-keepAliveTime-后死亡？"><a href="#非核心线程如何实现在-keepAliveTime-后死亡？" class="headerlink" title="非核心线程如何实现在 keepAliveTime 后死亡？"></a>非核心线程如何实现在 keepAliveTime 后死亡？</h4><p>也是利用阻塞队列的方法，在获取任务时通过阻塞队列的 poll(time,unit) 方法实现的在延迟死亡。</p>
<p>即核心线程可以无限等待获取任务，非核心线程要限时获取任务。</p>
<h4 id="非核心线程能成为核心线程吗？"><a href="#非核心线程能成为核心线程吗？" class="headerlink" title="非核心线程能成为核心线程吗？"></a>非核心线程能成为核心线程吗？</h4><p>其实线程池内部是不区分核心线程和非核心线程的，他们的作用都是在空闲时调用getTask从任务队列中获取任务执行，只不过一开始创建的是核心线程，队列满后才会创建非核心线程。</p>
<h4 id="线程只能在任务到达时才启动吗？"><a href="#线程只能在任务到达时才启动吗？" class="headerlink" title="线程只能在任务到达时才启动吗？"></a>线程只能在任务到达时才启动吗？</h4><p>默认情况下，即使是核心线程也只能在新任务到达时才创建和启动。但是我们可以使用 prestartCoreThread（启动一个核心线程）或 prestartAllCoreThreads（启动全部核心线程）方法来提前启动核心线程。</p>
<h4 id="线程池里有个-ctl，你知道它是如何设计的吗？"><a href="#线程池里有个-ctl，你知道它是如何设计的吗？" class="headerlink" title="线程池里有个 ctl，你知道它是如何设计的吗？"></a>线程池里有个 ctl，你知道它是如何设计的吗？</h4><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/v2-e03eb308a5bfe1aae697cba2be8a6f7b_720w.webp" alt="img" style="zoom:80%;" />

<p>1）workerCount：指示线程的有效数量；</p>
<p>2）runState：指示线程池的运行状态，有 RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED 等状态。</p>
<p>ctl 这么设计的主要好处是将对 runState 和 workerCount 的操作封装成了一个原子操作。如果我们使用2个变量来分别存储，要保证原子性则需要额外进行加锁操作，这显然会带来额外的开销</p>
<h4 id="线程池中如何知道的一个线程任务执行完成"><a href="#线程池中如何知道的一个线程任务执行完成" class="headerlink" title="线程池中如何知道的一个线程任务执行完成"></a>线程池中如何知道的一个线程任务执行完成</h4><h3 id="3-线程池创建两种方式"><a href="#3-线程池创建两种方式" class="headerlink" title="3.线程池创建两种方式"></a>3.线程池创建两种方式</h3><p><strong>1.通过<code>ThreadPoolExecutor</code>构造函数来创建（推荐）。</strong></p>
<p>需要合理设置构造函数的参数。</p>
<p><strong>2.通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来创建。几种典型的线程池</strong></p>
<p><code>FixedThreadPool</code>，<code>SingleThreadExecutor</code>，<code>CachedThreadPool</code>，<code>ScheduledThreadPool</code>这四个方法内部其实都调用了ThreadPoolExecutor&#96;构造函数来创建，只是参数不同。</p>
<p><strong>SingleThreadExecutor:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建单个线程。它适用于需要保证顺序地执行各个任务;并且在任意时间点，不会有多个线程是活动的应用场景。</p>
<p><strong>FixedThreadPool:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FixedThreadPool是一种线程数量固定的线程池，当线程处于空闲状态时，他们并不会被回收，除非线程池被关闭。当所有的线程都处于活动状态时，新的任务都会处于等待状态，直到有线程空闲出来。</p>
<p>适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程</p>
<p><strong>CachedThreadPool</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>核心线程数为0，总线程数量阈值为Integer.MAX_VALUE,即可以创建无限的非核心线程。适用于执行大量短生命周期任务。</p>
<p><strong>ScheduledThreadPool</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程总数阈值为Integer.MAX_VALUE,工作队列使用DelayedWorkQueue，非核心线程存活时间为0，所以线程池仅仅包含固定数目的核心线程。</p>
<p>ScheduledExecutorService提供两种提交任务的方法</p>
<ul>
<li>scheduleAtFixedRate: 按照固定速率周期执行</li>
<li>scheduleWithFixedDelay：上个任务延迟固定时间后执行</li>
</ul>
<h3 id="为什么不推荐使用内置线程池？"><a href="#为什么不推荐使用内置线程池？" class="headerlink" title="为什么不推荐使用内置线程池？"></a>为什么不推荐使用内置线程池？</h3><p>主要的原因是不够灵活：内置线程池通常只提供了一些简单的参数配置，如线程池的大小、任务队列的大小等，而在某些特定的场景下，可能需要更加灵活的线程池配置。</p>
<p>其实内置线程池无非就是java自己设置好了一些线程池，比如SingleThreadExecutor，核心线程和最大线程都是1，FixedThreadPool核心线程等于最大线程，即线程数是固定的等等，这些其实通过自定义线程池参数也能实现，所以一般情况下会自己设置会更灵活一点。</p>
<h2 id="Synchonize原理"><a href="#Synchonize原理" class="headerlink" title="Synchonize原理"></a>Synchonize原理</h2><h3 id="synchronize实现互斥锁的原理："><a href="#synchronize实现互斥锁的原理：" class="headerlink" title="synchronize实现互斥锁的原理："></a>synchronize实现互斥锁的原理：</h3><p>synchronized是JVM内置锁，通过内部对象Monitor（监视器锁）来实现。每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针 </p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20220317181913745.png" alt="image-20220317181913745" style="zoom:80%;" />

<ol>
<li>Monitor监视器包含三个总要的数据结构：WaitSet，EntryList，Owner，count</li>
<li>在线程1中执行synchronized(obj)时，会找到obj中的Monitor对象，将Monitor中的Owner置为线程1，代表对线程1加锁，count+1，代表该锁已经被占用</li>
<li>在线程2执行synchronized(obj)时，找到obj中的Monitor对象，count不为0，说明已经上锁，就会进被加入到EntryList，即阻塞队列中。</li>
<li>当线程1执行完成后，Owner置为空，count-1，如果count&#x3D;0，会唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的 </li>
<li>对于持有锁的线程，也就是Owner指向的线程，如果调用wait方法后，就会进入WaitSet等待队列中，此时Owner也会置为空，相当于释放了锁，唤醒 EntryList 中等待的线程来竞争锁。（注，这里不谈论重入的情况，但是实验证实了wait方法是会释放count&gt;1的对象锁的，并加入到等待队列中去）</li>
</ol>
<h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><ul>
<li><p>无锁，如果支持偏向锁（没有计算 hashCode），创建对象默认分配一个可偏向而未偏向的对象</p>
</li>
<li><p>偏向锁：</p>
<p>含义：偏向锁是针对于一个线程而言的，线程获得锁之后就不会再有解锁等操作，这个锁对象就归该线程所有 ，可以省略很多开销。</p>
<p>实现：</p>
<p>偏向锁标志是未偏向状态，使用 CAS 将 MarkWord 中的线程ID设置为自己的线程ID</p>
<p>偏向锁标志是已偏向状态，是自己的线程 ID，成功获取锁；不是自己的线程 ID，需要进行锁升级</p>
<p>升级：</p>
<p>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁；</p>
</li>
<li><p>轻量级锁：</p>
<p>含义：</p>
<p>轻量级锁之所以轻量，是因为它只使用CAS来获取锁。</p>
<p>轻量级锁适用于同一个线程自己竞争锁或多个线程加锁时间错开的情况（也就是没有竞争的情况）</p>
<p>实现：</p>
<p>每个线程都的栈帧都会包含一个锁记录的结构，包括Displaced Mark Word和owner。</p>
<p>加锁过程：在栈中建立一个锁记录，将<code>Mark Word</code>拷贝到锁记录的<code>Displaced Mark Word</code>中，<code>owner</code>指向锁对象。然后使用CAS操作尝试将锁对象的Mark Word更新为指向当前线程栈帧的指针，如果此时Mark Word是无锁状态，则cas成功则代表获取锁成功。</p>
<p>根据cas操作的失败可以分为两种情况：</p>
<ul>
<li>如果对象Mark Word指向当前线程的栈帧，说明是同一个线程，那么再添加一条锁记录作为重入的计数，重入的锁记录中的<code>Displaced Mark Word</code>设置为<code>null</code>,<code>owner</code>指向锁对象。</li>
<li>如果对象Mark Word不是当前线程的栈帧也不是无锁状态，说明有多个线程竞争锁，轻量级锁会先通过自旋竞争锁，失败一定次数后，轻量级锁就要膨胀为重量级锁</li>
</ul>
<p>解锁过程：</p>
<p>检索当前线程栈中的锁记录空间，解锁时如果<code>Displaced Mark Word</code>为 <code>null</code>，则说明是锁重入解锁，移除<code>onwer</code>的指向，不做替换操作；如果不为null，<em>CAS</em>把当前线程栈帧<code>Lock Record</code>中的<code>Displaced Mark Word</code>替换到对象头的<code>Mark Word</code>中去，如果替换成功，则轻量级解锁成功；如果替换失败，则说明发生了锁膨胀</p>
<p>升级：</p>
<p>有多线程竞争的情况</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20220317183112363.png" alt="image-20220317183112363" style="zoom:80%;" />
</li>
<li><p>重量级锁:</p>
<p>重量级锁内部对象Monitor（监视器锁）来实现。依赖于底层的操作系统的Mutex Lock来实现的。</p>
<p>重量级锁之所以重量的原因：它与轻量级锁不同，竞争的线程不再通过自旋来竞争线程，监视器锁（monitor）依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p>
<p>实现：在cas失败后，锁对象申请 Monitor 锁，然后竞争线程进入 Monitor 的 EntryList 阻塞队列中</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20220317183453057.png" alt="image-20220317183453057" style="zoom:80%;" />

<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20220317183547387.png" alt="image-20220317183547387" style="zoom:80%;" /></li>
</ul>
<p>注：锁可以升级，可以跨级，但不能降级。即：无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁是单向的。</p>
<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><p>锁膨胀</p>
<p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁来减少锁操作的开销。即，使用synchronize时，不会直接使用监视器锁。</p>
<p>自旋优化</p>
<p>重量级锁竞争的时候，还可以使用自旋来进行优化。即获取锁对象失败，不会马上进入EntryList阻塞队列，而是通过自旋重试，避免阻塞。可以在一定程度上避免阻塞</p>
<h2 id="reentrantlock原理"><a href="#reentrantlock原理" class="headerlink" title="reentrantlock原理"></a>reentrantlock原理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    LockSupport.park();</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line">LockSupport.unpark(t1);</span><br></pre></td></tr></table></figure>

<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS是一种提供了原子式管理状态、提供阻塞和唤醒线程功能以及队列模型的框架。JUC中的同步工具都是基于AQS实现的。</p>
<ul>
<li><p>用 state 属性来表示资源的状态，使用 cas 机制设置 state 状态。state有三种状态值</p>
<p><code>state</code>状态值为<code>0</code>表示当前没有被任何线程持有</p>
<p><code>state</code>状态值为<code>1</code>表示被其他线程持有，</p>
<p><code>state</code>状态值大于<code>1</code>，不同的锁中有不同的含义，在reentrantlock表示重入同一个线程的数量；在CountDownLatch表示允许多 个子线程是并行执行。</p>
</li>
<li><p>对于获取锁失败的线程，AQS使用<code>CLH</code>队列来将暂时获取不到锁的线程加入到队列中。</p>
</li>
<li><p>AQS中需要子类实现tryAcquire来定义获取资源的方法，tryRelease 来定义释放资源的方法</p>
</li>
</ul>
<p>线程同步互斥，是直接通过ReentrantLock类对象 lock() unlock()实现的</p>
<p><code>ReentrantLock</code> 里面有一个内部类 <code>Sync</code>，<code>Sync</code> 继承 AQS（<code>AbstractQueuedSynchronizer</code>），lock() unlock()的操作实际上就是调用 <code>Sync</code>的tryAcquire 和tryRelease方法</p>
<p>注：Sync中也有两个实现类，fairSync和NofairSync，可以通过构造方法指定</p>
<p>非公平锁实现原理(普通加锁原理)</p>
<ul>
<li>当线程调用 tryAcquire 方法尝试获取锁时，如果state为0，获取锁成功。如果state不为0，分为两种情况：如果是同一个线程表示重入，则获得锁成功，然后state+1；如果不是同一个线程，会加入到CLH队列中，并调用park使线程阻塞。</li>
<li>当占用锁的线程调用tryRelease释放锁时，会把state-1，如果state的值为0，调用unpark唤醒CLH队列的第一个线程。</li>
<li>非公平体现在如果这时候有其它线程来竞争，队列中刚刚唤醒的线程还需要跟这些线程竞争，如果获取锁失败，仍然重新进入阻塞</li>
</ul>
<p>公平锁实现原理</p>
<ul>
<li>公平锁中的tryAcquire方法被重写了，新来的线程即便得知了锁的state为0，也要先判断当前线程是不是<code>CLH</code>队列被唤醒的线程，如果是就获取锁，否则就被加入CLH队列队尾。</li>
<li>(注)为了保证公平，一定会让<code>CLH</code>队列线程竞争成功，如果一直有非<code>CLH</code>队列的线程参与竞争，那就一直执行插入队尾操作，所以公平策略的性能会更差。</li>
</ul>
<p>可重入原理</p>
<ul>
<li>当持有锁的线程再次尝试获取锁时，会将state的值加1，state表示锁的重入量。</li>
</ul>
<p>可打断原理</p>
<ul>
<li>不可打断模式：在此模式下，即使它被打断，仍会驻留在 AQS 队列中，并将打断信号存储在一个interrupt变量中。一直要等到获得锁后方能得知自己被打断了,并且调用<code>selfInterrupt</code>方法打断自己。</li>
<li>可打断模式：此模式下即使线程在等待队列中等待，一旦被打断，就会立刻抛出打断异常。</li>
</ul>
<p>条件变量实现原理</p>
<p>线程阻塞和唤醒，是通过ReentrantLock类对象lock.newCondition()得到一个等待队列，condition引用指向这个对象，然后condition.await() condition.signal()实现的。Lock和Condition 是一对多的关系</p>
<p>每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObject，ConditionObject是AQS中定义的内部类</p>
<p>调用ConditionObject的await方法前，需要获得锁，然后调用await方法把当前线程加入到ConditionObject队列中去，并释放锁资源。唤醒reentrantlock中AQS队列的第一个线程。</p>
<p>调用ConditionObject的signal方法前，也需要获得锁，然后调用signal方法去ConditionObject队列中获取第一个线程并把它加入到reentrantlock中AQS队列的尾部，不会释放锁资源继续执行当前线程。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20220314171543622.png" alt="image-20220314171543622" style="zoom:80%;" />



<h4 id="AQS-的常见同步工具类"><a href="#AQS-的常见同步工具类" class="headerlink" title="AQS 的常见同步工具类"></a>AQS 的常见同步工具类</h4><h5 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h5><p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，而<code>Semaphore</code>(信号量)可以用来控制同时访问特定资源的线程数量。用于那些资源有明确访问数量限制的场景。</p>
<h5 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h5><p><code>CountDownLatch</code> 允许 <code>count</code> 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。适用于主线程需要等待多个子线程都执行完成的场景。</p>
<p><code>CountDownLatch</code> 是共享锁的一种实现,它默认构造 AQS 的 <code>state</code> 值为 <code>count</code>。当线程使用 <code>countDown()</code> 方法时,其实使用了<code>tryReleaseShared</code>方法以 CAS 的操作来减少 <code>state</code>,直至 <code>state</code> 为 0 。当调用 <code>await()</code> 方法的时候，如果 <code>state</code> 不为 0，那就证明任务还没有执行完毕，<code>await()</code> 方法就会一直阻塞，也就是说 <code>await()</code> 方法之后的语句不会被执行。</p>
<p><code>CountDownLatch</code> 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 <code>CountDownLatch</code> 使用完毕后，它不能再次被使用</p>
<h5 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h5><p><code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，区别在于<code>CyclicBarrier</code> 可以重用，重用的意思是每次到达“计数条件”时，执行相应方法并<strong>重新恢复到初始值</strong></p>
<h2 id="二-面试题上"><a href="#二-面试题上" class="headerlink" title="二.面试题上"></a>二.面试题上</h2><h3 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h3><h4 id="1-线程跟进程的区别"><a href="#1-线程跟进程的区别" class="headerlink" title="1.线程跟进程的区别"></a>1.线程跟进程的区别</h4><p>线程是进程的子集，进程可以创建多个线程。</p>
<p>进程之间基本是独立的，通过管道，共享内存，socket来实现进程间的通信。同一进程中的线程是相互影响的，会涉及访问共享变量问题。</p>
<p>进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。</p>
<p>进程中可以运行多个线程，同进程里的线程可以共享进程的部分资源的，比如文件描述符列表、进程空间、代码、<a href="https://www.zhihu.com/search?q=%E5%85%A8%E5%B1%80%E6%95%B0%E6%8D%AE&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1802684879%7D">全局数据</a>、堆、共享库等，这些共享些资源在上下文切换时是不需要切换，而只需要切换线程的私有数据、寄存器等不共享的数据，因此同一个进程下的线程上下文切换的开销要比进程小得多。</p>
<p><strong>进程之间的通信方式</strong></p>
<p>同一个主机：管道，共享内存</p>
<p>管道：linux中的|和&gt;,就可以实现把一个进程的输出作为另一个进程的输入</p>
<p>共享内存：共享内存的机制，两个进程都用一个地址指向到相同的物理内存。这样这个进程写入的东西，另外一个进程马上就能看到了</p>
<p>不同主机：socket</p>
<p>socket：可以实现网络中不同主机上的进程之间通信，socket使用套接字来标识一个链接，套接字中的端口号就指向主机中的某个进程。</p>
<h4 id="2-对线程安全的理解"><a href="#2-对线程安全的理解" class="headerlink" title="2.对线程安全的理解"></a>2.对线程安全的理解</h4><p>当多个线程的指令交叉执行时，如果每次都能得到正确的结果就是线程安全的。共享内存和指令重排序会破坏线程安全</p>
<h4 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3.死锁"></a>3.死锁</h4><p>死锁的四个必要条件：</p>
<ol>
<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>
<li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<p>如何预防死锁？ 破坏死锁的产生的必要条件即可：</p>
<ol>
<li>破坏请求与保持条件 ：一次性申请所有的资源。</li>
<li>破坏不剥夺条件 ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li>破坏循环等待条件 ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
</ol>
<p>如何避免死锁？</p>
<p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，确保系统不会进入不安全状态。如果仔细分配资源，就有可能避免死锁。</p>
<p>死锁检测？</p>
<p>对资源的分配加以限制可以预防和避免死锁的发生，但是都不利于各进程对系统资源的充分共享。解决死锁问题的另一条途径是 死锁检测和解除 (这里突然联想到了乐观锁和悲观锁，感觉死锁的检测和解除就像是 乐观锁 ，分配资源时不去提前管会不会发生死锁了，等到真的死锁出现了再来解决嘛，而 死锁的预防和避免 更像是悲观锁，总是觉得死锁会出现，所以在分配资源的时候就很谨慎)。</p>
<p>这种方法对资源的分配不加以任何限制，也不采取死锁避免措施，但系统 定时地运行一个 “死锁检测”的程序，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它。</p>
<h4 id="4-创建线程的四种方式"><a href="#4-创建线程的四种方式" class="headerlink" title="4.创建线程的四种方式"></a>4.创建线程的四种方式</h4><p>注：只有Thread才是真正创建线程，开启线程的类</p>
<p>1）继承Thread类创建线程(MyThread自定义线程类继承Thread类重写run方法)</p>
<p>2）实现Runnable接口创建线程(Thread(Runnable r)匿名内部类，重写run方法)</p>
<p>3）使用Callable和FutureTask创建线程</p>
<p>Callable的call()方法可以有返回值，需要借助Future接口来获取Callable接口里call()方法的返回值</p>
<p>Future接口提供了一个实现类FutureTask，这个实现类既实现了Future接口，还实现了Runnable接口，因此可以作为Thread类的target。</p>
<p>把封装了Callable的FutureTask交由Thread创建线程，最后可以通过FutureTask的get方法获取线程的执行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; future=<span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(</span><br><span class="line">　　(Callable&lt;Integer&gt;)()-&gt;&#123;</span><br><span class="line">　　　　　<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">　　&#125;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task,<span class="string">&quot;有返回值的线程&quot;</span>).start();<span class="comment">//实质上还是以Callable对象来创建并启动线程</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">　　System.out.println(<span class="string">&quot;子线程的返回值：&quot;</span>+future.get());<span class="comment">//get()方法会阻塞，直到子线程执行结束才返回</span></span><br><span class="line"> 　 &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">　　　ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）使用线程池创建线程</p>
<p>可以直接调用 Thread 类的 run 方法吗？</p>
<p>不能，不会开启多线程执行run方法，相当于一个类调用另一个类的方法，此时的run就是普通方法。必须使用start方法才能开启线程调用run方法</p>
<h4 id="5-sleep，wait，join，yield"><a href="#5-sleep，wait，join，yield" class="headerlink" title="5.sleep，wait，join，yield"></a>5.sleep，wait，join，yield</h4><p>sleep() 方法和 wait() 方法对比</p>
<p>相同点：两者都可以暂停线程的执行。</p>
<p>区别：</p>
<ul>
<li><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法会释放锁，并加入等待队列 。</li>
<li><code>wait()</code> 通常被用于线程间交互&#x2F;通信，<code>sleep()</code>通常被用于暂停执行。</li>
<li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li>
<li>sleep方法不依赖于同步器synchronized,但是wait需要依赖synchronized关键字。</li>
<li><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。</li>
</ul>
<p>为什么 wait() 方法不定义在 Thread 中？为什么 <code>sleep()</code> 方法定义在 <code>Thread</code> 中？</p>
<p><code>wait()</code> 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（<code>Object</code>）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（<code>Object</code>）而非当前的线程（<code>Thread</code>）。</p>
<p>什么是上下文切换?</p>
<p>线程在执行过程中会有自己的运行条件和状态，这就是线程的上下文。在线程切换时需要保存当前线程的上下文，并加载下一个将要占用 CPU 的线程上下文。这就是所谓的上下文切换。</p>
<p>yield()</p>
<p>执行后线程直接进入就绪状态，马上释放了cpu的执行权，但是依然保留了cpu的执行资格，所以有可能<br>cpu下次进行线程调度还会让这个线程继续执行</p>
<p>join()</p>
<p>join()执行后线程进入阻塞状态，例如在线程A中调用线程B的join()，那线程A执行到join()方法时会进入到等待队列，直到线程<br>B结束或中断线程</p>
<ol>
<li>实际上<code>join</code>方法就是调用了<code>wait</code>方法来使得线程阻塞</li>
<li>唤醒进程的方法位于<code>jvm</code>中，在线程（调用<code>join</code>方法的线程）结束后主线程被调用。</li>
</ol>
<h4 id="6-线程的生命周期及状态"><a href="#6-线程的生命周期及状态" class="headerlink" title="6.线程的生命周期及状态"></a>6.线程的生命周期及状态</h4><p><strong>当前线程</strong>调用 <code>t.join()</code> 方法时，<strong>当前线程</strong>从 <code>RUNNABLE --&gt; WAITING</code> </p>
<p>注意是<strong>当前线程</strong>在<strong>t 线程对象</strong>的监视器上等待 </p>
<p><strong>当前线程</strong>调用 <code>LockSupport.park()</code> 方法会让<strong>当前线程</strong>从 <code>RUNNABLE --&gt; WAITING</code> </p>
<p><strong>当前线程</strong>调用 <code>Thread.sleep(long n)</code> ，<strong>当前线程</strong>从 <code>RUNNABLE --&gt; TIMED_WAITING</code></p>
<p>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。</p>
<p>RUNNABLE: 运行状态，线程被调用了 <code>start()</code>等待运行的状态。</p>
<p>BLOCKED ：阻塞状态，需要等待锁释放。</p>
<p>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</p>
<p>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</p>
<p>TERMINATED：终止状态，表示该线程已经运行完毕。</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230314172216411.png" alt="image-20230314172216411"></p>
<p>注意：java中是没有ready状态的，这是操作系统的概念。</p>
<h4 id="7-守护线程"><a href="#7-守护线程" class="headerlink" title="7.守护线程"></a>7.守护线程</h4><p>在 Java 语言中线程分为两类：用户线程和守护线程，默认情况下我们创建的线程或线程池都是用户线程，守护线程是为用户线程服务的，需要特殊声明；当一个程序中的所有用户线程都执行完成之后程序就会结束运行，也就是说程序结束运行时不会管守护线程是否正在运行</p>
<p>守护线程的设置 setDaemon(true) 必须要放在线程的 start() 之前，否则程序会报错。</p>
<p>应用场景：GC垃圾回收线程就是守护线程，</p>
<h3 id="如何解决多线程并发问题"><a href="#如何解决多线程并发问题" class="headerlink" title="如何解决多线程并发问题"></a>如何解决多线程并发问题</h3><ol>
<li>加锁，如使用synchronized,ReentrantLock，加锁可以限制资源只能被一个线程访问；悲观锁</li>
<li>CAS机制，如AtomicInterger,AtomicBoolean等原子类，通过自旋的方式来尝试修改资源；乐观锁</li>
<li>ThreadLocal类，通过为每个线程维护一个变量副本，每个线程都有自己的资源了，自然没有并发问题。多线程并发问题说到底就是共享变量问题</li>
</ol>
<h3 id="如何优雅的停止一个线程"><a href="#如何优雅的停止一个线程" class="headerlink" title="如何优雅的停止一个线程"></a>如何优雅的停止一个线程</h3><p>原因：因为stop0方法太粗暴了，一旦调用了stop0,就会直接停掉线程，这样就可能造成严重的问题，比如任务执行到哪一步了？该释放的锁释放了没有？建议通过中断来停止线程</p>
<p>两阶段终止模式（只针对于无限循环的线程的终止，正常的线程执行完了就自动退出了）：第一阶段，在外部通过interrupt打断线程；第二阶段，在线程内部的打断异常中，重新打断线程，目的是为了都能执行线程中的善后逻辑</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20220317193331864.png" alt="image-20220317193331864" style="zoom:80%;" />

<p>注：stop（）会释放线程占用的synchronized锁，而不会自动释放ReentrantLock锁</p>
<p>sleep过程中打断会清空打断标记，所以需要设置打断标记</p>
<p>interrupt 可以打断正在执行的线程，无论这个线程是在 sleep，wait，还是正常运行</p>
<p>打断线程不等于中断线程，有以下两种情况：</p>
<ul>
<li>打断正在运行中的线程并不会影响线程的运行，但如果线程监测到了打断标记为true，可以自行决定后续处理。</li>
<li>打断阻塞，sleep，wait中的线程会让此线程产生一个<code>InterruptedException</code>异常，<strong>结束线程的运行</strong>，打断标记为false。但如果该异常被线程捕获住，该线程依然可以自行决定后续处理（终止运行，继续运行，做一些善后工作等等）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TPTInterrupt</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Thread thread;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span>(current.isInterrupted()) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;料理后事&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;将结果保存&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    current.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 执行监控操作 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;监控线程&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三-面试题中"><a href="#三-面试题中" class="headerlink" title="三.面试题中"></a>三.面试题中</h2><h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h3><h5 id="如何保证变量的可见性？JMMvolatile"><a href="#如何保证变量的可见性？JMMvolatile" class="headerlink" title="如何保证变量的可见性？JMMvolatile"></a>如何保证变量的可见性？JMMvolatile</h5><h5 id="如何禁止指令重排序？JMM内存屏障"><a href="#如何禁止指令重排序？JMM内存屏障" class="headerlink" title="如何禁止指令重排序？JMM内存屏障"></a>如何禁止指令重排序？JMM<strong>内存屏障</strong></h5><h5 id="volatile-可以保证原子性么？"><a href="#volatile-可以保证原子性么？" class="headerlink" title="volatile 可以保证原子性么？"></a>volatile 可以保证原子性么？</h5><p><code>volatile</code> 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。<br>例如经典的n++操作，它可以分成3步，读，+1，写。首先n是volatile变量只能保证读写不会重排序而且读到的是最新值，但是多线程下，有可能是多个线程先进行读操作，然后在统一进行+1操作，最后就会写入同一个值。使用 <code>synchronized</code> 改进，使用 <code>AtomicInteger</code> 改进，使用 <code>ReentrantLock</code> 改进</p>
<h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><h5 id="什么是悲观锁？使用场景是什么？synchronized和ReentrantLock"><a href="#什么是悲观锁？使用场景是什么？synchronized和ReentrantLock" class="headerlink" title="什么是悲观锁？使用场景是什么？synchronized和ReentrantLock"></a>什么是悲观锁？使用场景是什么？synchronized<code>和</code>ReentrantLock</h5><p>假设最坏的情况，认为共享资源每次被访问的时候就会出现问题。共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。通常多用于写多比较多的情况下（多写场景），避免频繁失败和重试影响性能</p>
<h5 id="什么是乐观锁？使用场景是什么？java-util-concurrent-atomic和cas"><a href="#什么是乐观锁？使用场景是什么？java-util-concurrent-atomic和cas" class="headerlink" title="什么是乐观锁？使用场景是什么？java.util.concurrent.atomic和cas"></a>什么是乐观锁？使用场景是什么？java.util.concurrent.atomic和cas</h5><p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了。乐观锁通常多于写比较少的情况下（多读场景）</p>
<h5 id="如何实现乐观锁？"><a href="#如何实现乐观锁？" class="headerlink" title="如何实现乐观锁？"></a>如何实现乐观锁？</h5><p>版本号机制：数据库的update语句是有个原子操作</p>
<p>一般是在数据表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。当数据被修改时，<code>version</code> 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 <code>version</code> 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 <code>version</code> 值相等时才更新，否则重试更新操作，直到更新成功。</p>
<p>CAS 算法：java中的cas是一个原子操作</p>
<p>CAS 涉及到三个操作数：<strong>V</strong> ：要更新的变量值(Var)，<strong>E</strong> ：预期值(Expected)，<strong>N</strong> ：拟写入的新值(New)</p>
<p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。</p>
<p>CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。Java 语言并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的</p>
<p><code>Unsafe</code>类提供了<code>compareAndSwapObject</code>、<code>compareAndSwapInt</code>、<code>compareAndSwapLong</code>方法</p>
<h5 id="乐观锁存在哪些问题？ABA-问题，CAS经常使用自旋操作导致循环时间长开销大"><a href="#乐观锁存在哪些问题？ABA-问题，CAS经常使用自旋操作导致循环时间长开销大" class="headerlink" title="乐观锁存在哪些问题？ABA 问题，CAS经常使用自旋操作导致循环时间长开销大"></a>乐观锁存在哪些问题？ABA 问题，CAS经常使用自旋操作导致循环时间长开销大</h5><p>ABA问题是那些变量会恢复条件下才会发生的，解决思路也很简单，使用添加一个版本号来标识，因为版本号是递增的，它本身是不会出现ABA问题的。专门的juc类AtomicStampedReference</p>
<h3 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h3><h5 id="synchronized-是什么？有什么用？"><a href="#synchronized-是什么？有什么用？" class="headerlink" title="synchronized 是什么？有什么用？"></a>synchronized 是什么？有什么用？</h5><p><code>synchronized</code> 是 Java 中的一个关键字，通过JVM内部对象Monitor（监视器锁）来实现互斥锁的功能。可以实现线程之间互斥的访问资源，通过加锁的方式，保证同一时间只有一个线程访问资源。解决了多线程下的可见性，原子性和有序性问题</p>
<p>在 Java 早期版本中，<code>synchronized</code> 使用重量级锁，在 Java 6 之后，<code>synchronized</code> 引入了偏向锁、轻量级锁等技术来减少锁操作的开销</p>
<h5 id="如何使用-synchronized？修饰实例方法，修饰静态方法，修饰代码块"><a href="#如何使用-synchronized？修饰实例方法，修饰静态方法，修饰代码块" class="headerlink" title="如何使用 synchronized？修饰实例方法，修饰静态方法，修饰代码块"></a>如何使用 synchronized？修饰实例方法，修饰静态方法，修饰代码块</h5><ul>
<li><code>synchronized(object)</code> 表示进入同步代码库前要获得 <strong>给定对象的锁</strong>。</li>
<li><code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>给定 Class 的锁</strong></li>
</ul>
<p><code>synchronized</code> 关键字加到 <code>static</code> 静态方法和 <code>synchronized(class)</code> 代码块上都是是给 Class 类上锁；</p>
<p><code>synchronized</code> 关键字加到实例方法上是给对象实例上锁；</p>
<p>尽量不要使用 <code>synchronized(String a)</code> 因为 JVM 中，一个值相同字符串对象可能在堆中，也可能在常量池中</p>
<h5 id="构造方法可以用-synchronized-修饰么？"><a href="#构造方法可以用-synchronized-修饰么？" class="headerlink" title="构造方法可以用 synchronized 修饰么？"></a>构造方法可以用 synchronized 修饰么？</h5><p>构造方法本身就属于线程安全的，不存在同步的构造方法一说。</p>
<h5 id="synchronized-底层原理了解吗？"><a href="#synchronized-底层原理了解吗？" class="headerlink" title="synchronized 底层原理了解吗？"></a>synchronized 底层原理了解吗？</h5><h5 id="JDK1-6-之后的-synchronized-底层做了哪些优化？"><a href="#JDK1-6-之后的-synchronized-底层做了哪些优化？" class="headerlink" title="JDK1.6 之后的 synchronized 底层做了哪些优化？"></a>JDK1.6 之后的 synchronized 底层做了哪些优化？</h5><h5 id="synchronized-和-volatile-有什么区别？"><a href="#synchronized-和-volatile-有什么区别？" class="headerlink" title="synchronized 和 volatile 有什么区别？"></a>synchronized 和 volatile 有什么区别？</h5><p>synchronized可以保证可见性，原子性和有序性。volatile只能保证可见性和部分有序性。</p>
<p><code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code>性能肯定比<code>synchronized</code>关键字要好 。</p>
<p>volatile<code>关键字只能用于变量而</code>synchronized&#96; 关键字可以修饰方法以及代码块 。</p>
<p>注：除了synchronize，其他例如Locks，Executors,ThreadPoolExecutor,阻塞队列,Future，CountDownLatch，Atomic都是java.util.concurrent包下的接口或类</p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><h5 id="ReentrantLock概念"><a href="#ReentrantLock概念" class="headerlink" title="ReentrantLock概念"></a>ReentrantLock概念</h5><p><code>ReentrantLock</code> 是java中的一个类，是基于 AQS 实现的 ，功能和 <code>synchronized</code> 关键字类似，也是通过加锁实现线程之间互斥的访问资源。不过，<code>ReentrantLock</code> 更灵活、更强大，增加了等待可中断，可实现公平锁，可实现选择性通知等高级功能。</p>
<h5 id="trylock和lock的区别"><a href="#trylock和lock的区别" class="headerlink" title="trylock和lock的区别"></a>trylock和lock的区别</h5><p>lock是阻塞加锁，trylock是非阻塞尝试获取锁</p>
<p>trylock会返回一个boolean值来判断是否获取锁成功，一般会通过自旋的方式使用trylock获取锁。</p>
<h5 id="公平锁和非公平锁有什么区别？"><a href="#公平锁和非公平锁有什么区别？" class="headerlink" title="公平锁和非公平锁有什么区别？"></a>公平锁和非公平锁有什么区别？</h5><p>公平锁 : 锁被释放之后，先申请的线程先得到锁。性能较差一些</p>
<p>非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</p>
<h5 id="synchronized-和-ReentrantLock-有什么区别？"><a href="#synchronized-和-ReentrantLock-有什么区别？" class="headerlink" title="synchronized 和 ReentrantLock 有什么区别？"></a>synchronized 和 ReentrantLock 有什么区别？</h5><p>两者都是可重入锁</p>
<p>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</p>
<p>synchronized会自动加锁和释放锁， ReentrantLock需要手动加锁lock和手动释放锁unlock</p>
<p>ReentrantLock 比 synchronized 增加了一些高级功能（可中断锁，公平锁，选择性通知）</p>
<h5 id="可中断锁和不可中断锁有什么区别？"><a href="#可中断锁和不可中断锁有什么区别？" class="headerlink" title="可中断锁和不可中断锁有什么区别？"></a>可中断锁和不可中断锁有什么区别？</h5><p>可中断锁 ：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。<code>ReentrantLock</code> 就属于是可中断锁。 lockInterruptibly 方法</p>
<p>不可中断锁：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 就属于是不可中断锁。</p>
<p>中断操作只是给线程的一个建议，最终怎么执行看线程本身的状态</p>
<h5 id="什么是选择性通知"><a href="#什么是选择性通知" class="headerlink" title="什么是选择性通知"></a>什么是选择性通知</h5><p>reentranlock允许创建不同的等待队列，获得锁的线程可以选择进入不同的等待队列进行等待，可以选择唤醒哪个等待队列中的线程。对比synchronize锁的话，synchronize锁的monitor只有一个等待队列，任何唤醒操作都会唤醒这个等待队列。</p>
<h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><h3 id="Atomic-原子类"><a href="#Atomic-原子类" class="headerlink" title="Atomic 原子类"></a>Atomic 原子类</h3><p>常用方法</p>
<p>自增，自减，compareAndSet常常配合while使用</p>
<h5 id="AtomicInteger-线程安全原理简单分析"><a href="#AtomicInteger-线程安全原理简单分析" class="headerlink" title="AtomicInteger 线程安全原理简单分析"></a>AtomicInteger 线程安全原理简单分析</h5><p><code>AtomicInteger</code> 类主要利用 CAS (compare and swap) + volatile 来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<p>CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 <code>objectFieldOffset()</code> 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p>
<h5 id="引用类型原子类"><a href="#引用类型原子类" class="headerlink" title="引用类型原子类"></a>引用类型原子类</h5><p><code>AtomicReference</code>：引用类型原子类</p>
<p><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</p>
<p>引用原子类包含一个compareAndSet(a,b)，用于比较a原来引用是否相等，相等则引用替换为b值，因此需要重写对象的equal方法。</p>
<h2 id="线程安全集合类"><a href="#线程安全集合类" class="headerlink" title="线程安全集合类"></a>线程安全集合类</h2><p>线程安全集合类可以分为三大类： </p>
<ul>
<li><p>遗留的线程安全集合如<code>Hashtable</code>，<code>Vector</code></p>
<p>缺点：1.历史遗留，不能删除，有更好的替代 2.使用synchronize修饰方法，并发性能低。</p>
</li>
<li><p>使用<code>Collections</code>装饰的线程安全集合，如： </p>
<ul>
<li>Collections.synchronizedCollection Collections.synchronizedList Collections.synchronizedMap Collections.synchronizedSet Collections.synchronizedNavigableMap Collections.synchronizedNavigableSet  Collections.synchronizedSortedMap Collections.synchronizedSortedSet </li>
<li>说明：以上集合均采用修饰模式设计，将非线程安全的集合包装后，在调用方法时包裹了一层synchronized代码块。其并发性并不比遗留的安全集合好。</li>
</ul>
</li>
<li><p>juc(java.util.concurrent.*)包下的集合类</p>
</li>
</ul>
<p>juc(java.util.concurrent.*)包下线程安全集合类</p>
<ul>
<li><p>带Blocking阻塞队列 ArrayBlockingQueue LinkedBlockingQueue </p>
</li>
<li><p>带Concurrent的容器 ConcurrentHashMap ConcurrentHashSet</p>
<p><a href="https://juejin.cn/post/6844903813892014087#heading-1">https://juejin.cn/post/6844903813892014087#heading-1</a></p>
</li>
</ul>
<h2 id="四-面试题下"><a href="#四-面试题下" class="headerlink" title="四.面试题下"></a>四.面试题下</h2><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><h4 id="ThreadLocal-有什么用？"><a href="#ThreadLocal-有什么用？" class="headerlink" title="ThreadLocal 有什么用？"></a>ThreadLocal 有什么用？</h4><p>threadlocal为每个线程提供一个保存数据的变量副本，同一个线程下是共享的，多个线程之间是独立的，可以用来定义线程安全角度下的全局变量</p>
<p>set(T) ，T get()，remove() 一个Thread可以有多个ThreadLocal，它们储存在Thread的ThreadLocalMap中，每个ThreadLocal只能存一个对象。</p>
<h4 id="ThreadLocal-原理了解吗？"><a href="#ThreadLocal-原理了解吗？" class="headerlink" title="ThreadLocal 原理了解吗？"></a>ThreadLocal 原理了解吗？</h4><p>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，这个而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>对象为 key ，Object 对象为 value 的键值对，这就为线程保存数据提供了可能。</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230506004245853.png" alt="image-20230506004245853"></p>
<h4 id="ThreadLocal-内存泄漏"><a href="#ThreadLocal-内存泄漏" class="headerlink" title="ThreadLocal 内存泄漏"></a>ThreadLocal 内存泄漏</h4><p>在ThreadLocalMap中key弱引用<code>ThreadLocal</code>对象，也就是说如果外部没有强引用指向这个<code>ThreadLocal</code>对象，那么它就会被GC回收，导致key为null；而ThreadLocalMap中的value是强引用，只要这个ThreadLocalMap还在value就不会被GC回收，因为key为null，这个value永远都不会被访问到，那么就发生的内存泄漏</p>
<p>ThreadLocalMap属于Thread，只要线程被销毁，Value也会随之被回收。</p>
<p>问题是，线程本身是非常珍贵的计算机资源，很少会去频繁的创建和销毁，尤其是通过线程池来使用，这就将线程的生命周期大大拉长，「内存泄漏」的影响也会越来越大。</p>
<p>解决方法：每次使用完ThreadLocal都要去调用remove()方法清除数据</p>
<h4 id="ThreadLocal的使用场景"><a href="#ThreadLocal的使用场景" class="headerlink" title="ThreadLocal的使用场景"></a>ThreadLocal的使用场景</h4><p>用 ThreadLocal 保存一请求的内容（用户权限信息、从用户系统获取到的用户名、用户ID 等），这些信息在同一个线程内相同，但是不同的线程使用的业务内容是不相同的。</p>
<h3 id="线程池-1"><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h3><h4 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h4><h4 id="如何创建线程池？"><a href="#如何创建线程池？" class="headerlink" title="如何创建线程池？"></a>如何创建线程池？</h4><p>方式一：通过<code>ThreadPoolExecutor</code>构造函数来创建（推荐）</p>
<p>方式二：通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来创建。</p>
<h4 id="为什么不推荐使用内置线程池？-1"><a href="#为什么不推荐使用内置线程池？-1" class="headerlink" title="为什么不推荐使用内置线程池？"></a>为什么不推荐使用内置线程池？</h4><p>内置线程池包括<code>FixedThreadPool</code>，<code>CachedThreadPool</code>，<code>ScheduledThreadPool</code>会导致OOM</p>
<h4 id="线程池常见参数有哪些？如何解释？"><a href="#线程池常见参数有哪些？如何解释？" class="headerlink" title="线程池常见参数有哪些？如何解释？"></a>线程池常见参数有哪些？如何解释？</h4><h4 id="线程池的饱和策略有哪些？"><a href="#线程池的饱和策略有哪些？" class="headerlink" title="线程池的饱和策略有哪些？"></a>线程池的饱和策略有哪些？</h4><h4 id="线程池常用的阻塞队列有哪些？"><a href="#线程池常用的阻塞队列有哪些？" class="headerlink" title="线程池常用的阻塞队列有哪些？"></a>线程池常用的阻塞队列有哪些？</h4><h4 id="线程池处理任务的流程了解吗？"><a href="#线程池处理任务的流程了解吗？" class="headerlink" title="线程池处理任务的流程了解吗？"></a>线程池处理任务的流程了解吗？</h4><p>下面的部分建议看java guide</p>
<h4 id="如何设定线程池的大小？"><a href="#如何设定线程池的大小？" class="headerlink" title="如何设定线程池的大小？*"></a>如何设定线程池的大小？*</h4><p>**CPU 密集型任务(N+1)**：消耗CPU 资源多的，可以避免大量线程争抢cpu资源，减少上下文切换</p>
<p>**I&#x2F;O 密集型任务(2N)**：消耗CPU 资源少的，可以避免大量任务堆积在任务队列导致 OOM。</p>
<h4 id="如何动态修改线程池的参数？"><a href="#如何动态修改线程池的参数？" class="headerlink" title="如何动态修改线程池的参数？"></a>如何动态修改线程池的参数？</h4><p>三个核心参数：**<code>corePoolSize</code><strong>，</strong><code>maximumPoolSize</code><strong>，</strong><code>workQueue</code>**它们基本决定了线程池对于任务的处理策略。</p>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p> <code>Future</code> 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。具体来说是这样的：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 <code>Future</code> 类获取到耗时任务的执行结果。</p>
<p>注：调用future的get方法是阻塞式的，一定要等future的线程执行完的结果才能继续运行</p>
<p>future.get和thread.join可以看成是主线程和线程的同步点。即，主线程在调用join前可以做任何事，但是遇到join时，就必须等待thread运行结束。</p>
<p> <code>Future</code> 类封装了callable方法和runnable方法</p>
<p>CompletableFuture</p>
<p><a href="https://baijiahao.baidu.com/s?id=1739828295604310156&wfr=spider&for=pc">https://baijiahao.baidu.com/s?id=1739828295604310156&amp;wfr=spider&amp;for=pc</a></p>
<p><a href="https://www.jianshu.com/p/48b5b7c319ca">https://www.jianshu.com/p/48b5b7c319ca</a></p>
<p>Runnable+Thread虽然提供了多线程的能力但是没有返回值。</p>
<p>Callable+Thread的方法提供多线程和返回值的能力但是在获取返回值的时候会阻塞主线程。无法将回调函数附加到 Future 并在 Future 的结果可用时自动调用它。</p>
<p>CompletableFuture相当于一个Task编排工具。</p>
<h3 id="使用多线程需要注意的一下事情"><a href="#使用多线程需要注意的一下事情" class="headerlink" title="使用多线程需要注意的一下事情"></a>使用多线程需要注意的一下事情</h3><p>在java中使用最多还是线程池。所以如果在类中使用Threadlocal时，为了避免内存泄漏，需要及时的进行remove操作</p>
<p>多线程中的synchronize锁会自动加锁和解锁，而如果使用reentrantlock需要手动加锁和释放锁</p>
<p>多线程编程要预防死锁的发生</p>
<p>cpu计算型：线程数等于cpu核心数，减少线程间的上下文切换</p>
<p>IO密集型：线程数等于cpu核心数&#x2F;（1-阻塞因子），阻塞因子0.5 0.7左右，可以到达比较好的效率</p>
<h3 id="java线程跟操作系统线程的关系"><a href="#java线程跟操作系统线程的关系" class="headerlink" title="java线程跟操作系统线程的关系"></a>java线程跟操作系统线程的关系</h3><h4 id="1-用户态和内核态"><a href="#1-用户态和内核态" class="headerlink" title="1. 用户态和内核态"></a>1. 用户态和内核态</h4><h5 id="1-1-内核"><a href="#1-1-内核" class="headerlink" title="1.1 内核"></a>1.1 内核</h5><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230511221521699.png" alt="image-20230511221521699" style="zoom: 50%;" />

<h5 id="1-2-用户态和内核态"><a href="#1-2-用户态和内核态" class="headerlink" title="1.2 用户态和内核态"></a>1.2 用户态和内核态</h5><p>既然<strong>内核是程序，它需要运行，就必须被分配 CPU</strong>。因此，CPU 上会运行两种程序，一种是操作系统的内核程序（也称为系统程序），一种是应用程序。</p>
<p>内核态：当 CPU 处于内核态时，可以运行内核程序，访问计算机的任何资源</p>
<p>用户态：当 CPU 处于用户态时，用户态的程序只能访问当前 CPU 上执行程序所在的地址空间，这样有效地防止了操作系统程序受到应用程序的侵害。</p>
<h5 id="1-3-中断机制"><a href="#1-3-中断机制" class="headerlink" title="1.3 中断机制"></a>1.3 中断机制</h5><p>操作系统的内核会把 CPU 的使用权主动让给应用程序，也就是使 CPU 从内核态转换到用户态，而 CPU 要想从用户态回到内核态，只能通过中断机制完成。</p>
<p>中断机制主要有三种手段：</p>
<ol>
<li>程序请求操作系统服务，执行系统调用</li>
<li>程序运行时产生外中断事件，外中断与当前执行的指令无关， 中断信号来源于 CPU 外部。如 I&#x2F;O 完成中断，表示设备输入&#x2F;输出处理已经完成</li>
<li>在程序运行时发生内中断事件，内中断与当前执行的指令有关， 中断信号来源于 CPU 内部。如非法操作码、地址越界、算术溢出，除数为 0 等。</li>
</ol>
<h5 id="1-4-系统调用"><a href="#1-4-系统调用" class="headerlink" title="1.4 系统调用"></a>1.4 系统调用</h5><p>系统调用也是中断机制的一种，因为<strong>「系统调用是通过陷入指令完成的」</strong>，该指令会引发内中断。<strong>应用程序可以通过系统调用来请求获得操作系统内核的服务</strong>。</p>
<ul>
<li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li>
<li>文件管理。完成文件的读、写、创建及删除等功能。</li>
<li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li>进程通信。完成进程之间的消息传递或信号传递等功能。</li>
<li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li>
</ul>
<h4 id="2-操作系统线程"><a href="#2-操作系统线程" class="headerlink" title="2. 操作系统线程"></a>2. 操作系统线程</h4><p><strong>程序员直接使用操作系统中已经实现的线程，而线程的创建、销毁、调度和维护，都是靠操作系统（准确的说是内核）来实现，程序员只需要使用系统调用，而不需要自己设计线程的调度算法和线程对CPU资源的抢占使用。</strong></p>
<p><strong>所谓线程模型，也就是用户线程和内核线程之间的关联方式</strong>，有多对一，一对一和多对多等。</p>
<p>在多对一模型中，多个用户级线程映射到某一个内核线程上；在一对一模型中，每个用户线程被映射或绑定到一个内核线程；多对多模型将任意数量的用户线程复用到相同或更少数量的内核线程上</p>
<h4 id="3-Java线程"><a href="#3-Java线程" class="headerlink" title="3. Java线程"></a>3. Java线程</h4><p><strong>在 JDK 1.2 及以后，JVM 选择了更加稳定且方便使用的操作系统原生的内核级线程，通过系统调用，将线程的调度交给了操作系统内核。</strong>而对于不同的操作系统来说，它们本身的设计思路基本上是完全不一样的，因此它们各自对于线程的设计也存在种种差异，所以 JVM 中明确声明了：虚拟机中的线程状态，不反应任何操作系统中的线程状态。</p>
<p><strong>也就是说 Java 中线程的本质，其实就是操作系统中的线程，其线程库和线程模型很大程度上依赖于操作系统（宿主系统）的具体实现，也就是说在 Win 系统上，Java 线程 API 通常采用 Win API 来实现，在 UNIX 类系统上，采用 Pthread 来实现，这些操作系统都实现了一对一的线程模型，也就是说大部分环境中一个java线程对应一个操作系统线程</strong></p>
<h3 id="线程和协程的区别"><a href="#线程和协程的区别" class="headerlink" title="线程和协程的区别"></a>线程和协程的区别</h3><p><a href="https://zhuanlan.zhihu.com/p/169426477">https://zhuanlan.zhihu.com/p/169426477</a></p>
<h3 id="多线编程题"><a href="#多线编程题" class="headerlink" title="多线编程题"></a>多线编程题</h3><p><strong>多线程并发，不能用if，必须用循环测试等待条件，避免虚假唤醒,因为if只会执行一次</strong></p>
<p>交替打印AB</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//flag用于标识下一次应该阻塞哪个线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(flag)&#123;<span class="comment">//如果flag为真，应该打印B</span></span><br><span class="line">                        LOCK.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;A&quot;</span>):</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    LOCK.notify();</span><br><span class="line">            	&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(!flag)&#123;<span class="comment">//如果flag为真，应该打印B</span></span><br><span class="line">                        LOCK.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;B&quot;</span>):</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    LOCK.notify();</span><br><span class="line">            	&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>交替打印ABC</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ABC_Condition</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">A</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">B</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">C</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (count % <span class="number">3</span> != <span class="number">0</span>)<span class="comment">//注意这里是不等于0，也就是说在count % 3为0之前，当前线程一直阻塞状态</span></span><br><span class="line">                        A.await(); <span class="comment">// A释放lock锁</span></span><br><span class="line">                    System.out.print(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">                    count++;</span><br><span class="line">                    B.signal(); <span class="comment">// A执行完唤醒B线程</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadB</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (count % <span class="number">3</span> != <span class="number">1</span>)</span><br><span class="line">                        B.await();<span class="comment">// B释放lock锁，当前面A线程执行后会通过B.signal()唤醒该线程</span></span><br><span class="line">                    System.out.print(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">                    count++;</span><br><span class="line">                    C.signal();<span class="comment">// B执行完唤醒C线程</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadC</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (count % <span class="number">3</span> != <span class="number">2</span>)</span><br><span class="line">                        C.await();<span class="comment">// C释放lock锁，当前面B线程执行后会通过C.signal()唤醒该线程</span></span><br><span class="line">                    System.out.print(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">                    count++;</span><br><span class="line">                    A.signal();<span class="comment">// C执行完唤醒A线程</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadA</span>().start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadB</span>().start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadC</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>死锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">		<span class="type">Object</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				<span class="keyword">synchronized</span> (a) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(<span class="string">&quot;t1获得锁a&quot;</span>);</span><br><span class="line">					<span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;t1获得锁b&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(<span class="string">&quot;t1释放锁b&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(<span class="string">&quot;t1释放锁a&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				<span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(<span class="string">&quot;t2获得锁b&quot;</span>);</span><br><span class="line">					<span class="keyword">synchronized</span> (a) &#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;t2获得锁a&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(<span class="string">&quot;t2释放锁a&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(<span class="string">&quot;t2释放锁b&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock 是悲观锁。ReentrantLock 一上来调用 lock 方法，就直接锁住了，其他获取不到锁的线程都会被加入到 AQS 的同步等待队列中，这还能叫乐观锁？CAS 是乐观的，不代表基于 CAS 实现的 ReentrantLock 是乐观的。</p>
<p>ReentrantLock 也会涉及到 mutex 调用的。就像上面说的，获取锁失败的线程会进入到同步等待队列中，在设置好了前驱节点的 SIGNAL 状态后，会将自身线程挂起进入阻塞。这里的线程调度是基于 Unsafe.park 实现的，其底层实现也是使用了 mutex 加锁阻塞的。</p>
<p>在 synchronized 各种优化之后，锁竞争激烈的情况下，ReentrantLock 和 synchronized 谁优势更大真不好说，跟太多条件有关了，环境，竞争情况，锁等待时间等等。现在也没有必要从性能的角度出发来选择了，更多要看方便性，以及是否能满足你的需求出发。ReentrantLock 相对于 synchronized，还能够响应中断、设置超时、非阻塞的尝试获取锁（tryLock）。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-06-30-设计模式</title>
    <url>/posts/8197.html</url>
    <content><![CDATA[<h2 id="什么是设计模式？"><a href="#什么是设计模式？" class="headerlink" title="什么是设计模式？"></a>什么是设计模式？</h2><p> 设计模式（Design pattern）代表了最佳的实践，通常被有经验的⾯向对象 的软件开发⼈员所采⽤。设计模式是软件开发⼈员在软件开发过程中⾯临 的⼀般问题的解决⽅案。这些解决⽅案是众多软件开发⼈员经过相当⻓的 ⼀段时间的试验和错误总结出来的</p>
<p>设计模式是⼀套被反复使⽤的、多数⼈知晓的、经过分类编⽬的、代码设 计经验的总结。使⽤设计模式是为了重⽤代码、让代码更容易被他⼈理解、保证代码可靠性。 毫⽆疑问，设计模式于⼰于他⼈于系统都是多赢 的，设计模式使代码编制真正⼯程化，设计模式是软件⼯程的基⽯，如同 ⼤厦的⼀块块砖⽯⼀样。项⽬中合理地运⽤设计模式可以完美地解决很多 问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了 ⼀个在我们周围不断重复发⽣的问题，以及该问题的核⼼解决⽅案，这也 是设计模式能被⼴泛应⽤的原因。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230418102009936.png" alt="image-20230418102009936" style="zoom:80%;" />

 <span id="more"></span>

<p>里氏代换原则：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p>
<p>依赖倒置原则：简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230730165214301.png" alt="image-20230730165214301" style="zoom:80%;" />

<p>依赖关系：</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230730165344597.png" alt="image-20230730165344597" style="zoom:80%;" />

<p>组合和聚合的区别：</p>
<p>合成(Composition,也有翻译成‘组合’的)是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。</p>
<p>聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230617211301816.png" alt="image-20230617211301816" style="zoom:50%;" /><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230617211252473.png" alt="image-20230617211252473" style="zoom:50%;" /></p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>⼀个单例类在任何情况下都只存在⼀个实例， 私有化构造⽅法、由⾃⼰创建⼀个静态变量存储实例，对外提供⼀个静态公有⽅法获取实例。</p>
<p>注：五种单例模式，最重要，最好的，用的最多的就是第三种双检锁懒汉式和第四种静态内部类式。面试常问，需能够手写这两种，并了解其余三种。</p>
<h3 id="单例模式的常见写法"><a href="#单例模式的常见写法" class="headerlink" title="单例模式的常见写法"></a>单例模式的常见写法</h3><h4 id="饿汉式，线程安全"><a href="#饿汉式，线程安全" class="headerlink" title="饿汉式，线程安全"></a>饿汉式，线程安全</h4><p>类⼀加载就创建对象，这种⽅式⽐较常⽤，线程安全，没有加锁，执⾏效率较⾼，但容易产⽣垃圾对象，浪费内存空间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1、私有化构造⽅法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 2、定义⼀个静态变量指向⾃⼰类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">// 3、对外提供⼀个公共的⽅法获取实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="懒汉式，线程不安全"><a href="#懒汉式，线程不安全" class="headerlink" title="懒汉式，线程不安全"></a>懒汉式，线程不安全</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1、私有化构造⽅法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123; &#125;</span><br><span class="line">    <span class="comment">// 2、定义⼀个静态变量指向⾃⼰类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">// 3、对外提供⼀个公共的⽅法获取实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 判断为 null 的时候再创建对象</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="懒汉式，线程安全"><a href="#懒汉式，线程安全" class="headerlink" title="懒汉式，线程安全"></a>懒汉式，线程安全</h4><p>存在的问题是 每⼀次调⽤ getInstance 获取实例时 都需要加锁和释放锁，这样是⾮常影响性能的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1、私有化构造⽅法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123; &#125;</span><br><span class="line">    <span class="comment">// 2、定义⼀个静态变量指向⾃⼰类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">// 3、对外提供⼀个公共的⽅法获取实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双重检查锁（DCL，-即-double-checked-locking）"><a href="#双重检查锁（DCL，-即-double-checked-locking）" class="headerlink" title="双重检查锁（DCL， 即 double-checked locking）"></a>双重检查锁（DCL， 即 double-checked locking）</h4><p>懒加载，线程安全，效率较⾼</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1、私有化构造⽅法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、定义⼀个静态变量指向⾃⼰类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">// 3、对外提供⼀个公共的⽅法获取实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第⼀重检查是否为 null</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 使⽤ synchronized 加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 第⼆重检查是否为 null</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// new 关键字创建对象不是原⼦操作</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.为什么需要两重检查。</p>
<p>第一重检查是在加锁之前：为了避免单例已经创建时，线程还去争抢锁的情况。</p>
<p>第二重检查是在加锁之后：单例未创建时，会有多个线程争抢锁创建单例，如果某个线程创建成功了，其他线程获得锁就不应该再去创建单例了。</p>
<p>2.为什么要使用volatile修饰对象。</p>
<p>主要利用volatile禁⽌指令重排序的特点。</p>
<p>因为 new 关键字创建对象不是原⼦操作，创建⼀个对象会经历下⾯的步骤：02</p>
<ol>
<li>在堆内存开辟内存空间 2. 调⽤构造⽅法，初始化对象 3. 引⽤变量指向这个对象</li>
</ol>
<p>单线程下123,132都能创建对象，但是多线程下。，行到13时，其他线程判断instance不为空，认为该对象已经创建好了，实际上是没有初始化的⾮ null 实例。</p>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>懒加载，线程安全，效率较⾼</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1、私有化构造⽅法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、对外提供获取实例的公共⽅法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒加载：首先，Java程序在加载一个类时，它的静态内部类也会被加载，是不会被立即初始化。</p>
<p>线程安全：类的初始化会使用&lt; clinit &gt;() ⽅法，jvm会保证如果多个线程同时去初始化⼀个类，那么只会有⼀个线程去执⾏这个 类的&lt; clinit &gt; () ⽅法，其他线程都需要阻塞等待，而且当其他线程被唤醒后也不会再次进⼊&lt; clinit &gt; () ⽅法。</p>
<h4 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h4><p>简单，⾼效，线程安全，但不是懒加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Spring 通过 <code>ConcurrentHashMap</code> 实现单例注册表的特殊方式实现单例模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果实例对象在不存在，我们注册到单例注册表中。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="built_in">this</span>.singletonObjects.put(beanName, (singletonObject != <span class="literal">null</span> ? singletonObject : NULL_OBJECT));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="简单⼯⼚模式"><a href="#简单⼯⼚模式" class="headerlink" title="简单⼯⼚模式"></a>简单⼯⼚模式</h3><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230617212234839.png" alt="image-20230617212234839" style="zoom: 80%;" />

<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230617212144969.png" alt="image-20230617212144969" style="zoom:67%;" /><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230617212151618.png" alt="image-20230617212151618" style="zoom:67%;" /></p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230617212202766.png" alt="image-20230617212202766" style="zoom: 50%;" /><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230617212209418.png" alt="image-20230617212209418" style="zoom: 50%;" /></p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230730170619018.png" alt="image-20230730170619018" style="zoom:80%;" />

<p>⼯⼚⽅法模式</p>
<p>抽象⼯⼚模式</p>
<p>Spring 使用工厂模式可以通过 <code>BeanFactory</code> 或 <code>ApplicationContext</code> 创建 bean 对象。</p>
<p>BeanFactory：延迟注入(使用到某个 bean 的时候才会注入)。</p>
<p>ApplicationContext：容器启动的时候，一次性创建所有 bean 。</p>
<p>ApplicationContext拓展了BeanFactory的功能，一般开发人员使用ApplicationContext获取bean。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>所谓适配器模式就是将⼀个类的接⼝，转换成客户期望的接⼝， 使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。适配器作为中间件将⽬标类和适配者解耦，避免子类化。适配器分为类适配器和对象适配器，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</p>
<p>比如：客户端需要用到某个接口的某个方法，而目前该接口的实现类都不能很好的匹配功能，另外一个不相关的类却可以，为了不修改客户端的代码，这时候有两种方法可以让客户端使用这个不相关类的方法，一种是让这个不相关类去实现接口方法，另一种就是使用适配器模式。</p>
<h4 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h4><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230327165422396.png" alt="image-20230327165422396" style="zoom:80%;" />

<p>解释：Client只支持Target接口中的方法，Adapter实现Target接口并继承Adaptee类。</p>
<ul>
<li>Target: 定义 Client 真正需要使⽤的接⼝</li>
<li>Adaptee: 其中定义了⼀个已经存在的接⼝，也是我们需要进⾏适配的 接⼝。</li>
<li>Adapter: 对 Adaptee 和 Target 的接⼝进⾏适配，保证对 target 中接⼝ 的调⽤可以间接转换为对 Adaptee 中接⼝进⾏调⽤。</li>
</ul>
<h4 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h4><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230327165948598.png" alt="image-20230327165948598" style="zoom:80%;" />

<p>Adapter实现Target接口并依赖一个Adaptee对象。</p>
<h4 id="IO流中的适配器模式"><a href="#IO流中的适配器模式" class="headerlink" title="IO流中的适配器模式"></a>IO流中的适配器模式</h4><p><code>InputStreamReader</code> 和 <code>OutputStreamWriter</code> 就是两个适配器(Adapter)。IO 流中的字符流和字节流的接口不同，它们之间可以协调工作就是基于适配器模式来做的，更准确点来说是对象适配器。通过适配器(在适配器中对字节流进行解码)，我们可以将字节流对象适配成一个字符流对象，这样我们可以直接通过字节流对象来读取或者写入字符数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// InputStreamReader 是适配器，FileInputStream 是被适配的类</span></span><br><span class="line"><span class="type">Reader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">// BufferedReader 增强 InputStreamReader 的功能（装饰器模式）</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReader</span> <span class="keyword">extends</span> <span class="title class_">Reader</span> &#123;</span><br><span class="line">	<span class="comment">//用于解码的对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> StreamDecoder sd;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InputStreamReader</span><span class="params">(InputStream in)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(in);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 StreamDecoder 对象</span></span><br><span class="line">            sd = StreamDecoder.forInputStreamReader(in, <span class="built_in">this</span>, (String)<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用 StreamDecoder 对象做具体的读取工作</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> sd.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230405163357031.png" alt="image-20230405163357031" style="zoom:80%;" />

<h4 id="Spring-MVC-中的适配器模式"><a href="#Spring-MVC-中的适配器模式" class="headerlink" title="Spring MVC 中的适配器模式"></a>Spring MVC 中的适配器模式</h4><p>见框架部分</p>
<p>HandlerAdapter是适配器期望接口，它的子类才是具体的适配器，专门适配某一类Handler，Handler是适配者。这样的好处是，DispatchServlet获得Handler对象之后直接丢给HandlerAdapter去处理，不需要自己操作handler对象，因为不同handler对象有不同的handle方法。DispatchServlet只需要根据handler对象获取具体的HandlerAdapter对象，然后调用HandlerAdapter.handle(handler)方法就可以了</p>
<p><a href="https://blog.csdn.net/guorui_java/article/details/106584559">https://blog.csdn.net/guorui_java/article/details/106584559</a></p>
<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>装饰器模式主要对现有的类对象进⾏包裹和封装，以期望在不改变类对象及其类定义的情况下，为对象添加额外功能。</p>
<p>装饰模式降低系统的耦合度，可以动态的增加对象的功能，并使得需要装饰的具体构建类和具体装饰类可以独立变化，以便增加新的具体构建类和具体装饰类。</p>
<p>可以对一个对象进行多次装饰，创造出不同行为的组合，得到功能更加强大的对象。</p>
<p>这样讲有点抽象，以io流为例，FilterInputStream就是一个抽象装饰器，用于增强 InputStream子类对象的功能。BufferedInputStream是FilterInputStream 的子类，可以用BufferedInputStream增强FileInputSteam的功能，这样原本的FileInputStream对象就拥有了缓冲读取字节流的功能，否则就需要使用一个BufferedAndFileInputStream来同时实现文件读取和缓冲读取的功能。</p>
<p>BufferedInputStream(new FileInputSteam)</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230327193838603.png" alt="image-20230327193838603" style="zoom:80%;" />

<ul>
<li>Component抽象构件角色：真实对象和装饰对象有相同的接口。这样，客户端对象就能够以与真实对象相同的方式同装饰对象交互。</li>
<li>ConcreteCompoent具体构件角色(真实对象)：定义一个将要接收附加责任的类。</li>
<li>Decorator装饰角色：持有一个抽象构件的引用。装饰对象接受所有客户端的请求，并把这些请求转发给真实的对象。这样，就能在真实对象调用前后增加新的功能。</li>
<li>ConcreteDecorate具体装饰角色：负责给构件对象增加新的功能。</li>
</ul>
<h4 id="IO流中的装饰器模式"><a href="#IO流中的装饰器模式" class="headerlink" title="IO流中的装饰器模式"></a>IO流中的装饰器模式</h4><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230327194531584.png" alt="image-20230327194531584" style="zoom:80%;" />

<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>既然用了继承，并且肯定这个继承有意义，就应该要成为子类的模板，所有重复的代码都应该要上升到父类去，而不是让每个子类都去重复</p>
<p><strong>我们要完成在某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，我们通常考虑用模板方法模式来处理。</strong></p>
<p><strong>模板方法模式是通过把不变行为搬移到超类，去除子类中的重复代码来体现它的优势</strong></p>
<p>当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现。我们通过模板方法模式把这些行为搬移到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠。</p>
<p><strong>模板方法模式，定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</strong></p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230616164028352.png" alt="image-20230616164028352" style="zoom: 67%;" />

<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230616164115277.png" alt="image-20230616164115277" style="zoom:80%;" />

<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230616164122259.png" alt="image-20230616164122259" style="zoom:80%;" />

<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230616164158371.png" alt="image-20230616164158371"></p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>面向对象的编程，并不是类越多越好，类的划分是为了封装，但<strong>分类的基础是抽象</strong>，具有相同属性和功能的对象的抽象集合才是类</p>
<p><del><strong>简单工厂模式虽然也能解决这个问题，但这个模式只是解决对象的创建问题</strong>，而且由于工厂本身包括了所有的收费方式，商场是可能经常性地更改打折额度和返利额度，每次维护或扩展收费方式都要改动这个工厂，<strong>以致代码需重新编译部署</strong>，这真的是很糟糕的处理方式，所以用它不是最好的办法。面对算法的时常变动，应该有更好的办法。好好去研究一下其他的设计模式，你会找到答案的</del></p>
<p>策略模式(Strategy):它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。具体来说策略模式的核心是context类，它使用构造函数传入策略对象</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230730111209439.png" alt="image-20230730111209439"></p>
<p>策略模式就是用来封装算法的，但在实践中，我们发现可以用它来封装几乎任何类型的规则，<strong>只要在分析过程中听到需要在不同时间应用不同的业务规则</strong>，就可以考虑使用策略模式处理这种变化的可能性</p>
<p>策略模式和简单工厂常常一起使用</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230730112258402.png" alt="image-20230730112258402" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//策略类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IIdGenerator</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">nextId</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体策略类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomNumeric</span> <span class="keyword">implements</span> <span class="title class_">IIdGenerator</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShortCode</span> <span class="keyword">implements</span> <span class="title class_">IIdGenerator</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SnowFlake</span> <span class="keyword">implements</span> <span class="title class_">IIdGenerator</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//上下文类，结合的简单工厂的思想</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdContext</span> &#123;</span><br><span class="line">	Map&lt;Constants.Ids,IIdGenerator&gt; idGeneratorMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">8</span>);</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;Constants.Ids,IIdGenerator&gt; idGenerator(SnowFlake snowFlake, ShortCode shortCode, RandomNumeric randomNumeric)&#123;</span><br><span class="line">        idGeneratorMap.put(Constants.Ids.SnowFlake,snowFlake);</span><br><span class="line">        idGeneratorMap.put(Constants.Ids.ShortCode,shortCode);</span><br><span class="line">        idGeneratorMap.put(Constants.Ids.RandomNumeric,randomNumeric);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> idGeneratorMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">(Constants.Ids idStrategy)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> idGeneratorMap.get(idStrategy).nextId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> IdContext idContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_ids</span><span class="params">()</span> &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;雪花算法策略，生成ID：&#123;&#125;&quot;</span>, idContext.getId(Constants.Ids.SnowFlake));</span><br><span class="line">    logger.info(<span class="string">&quot;日期算法策略，生成ID：&#123;&#125;&quot;</span>, idContext.getId(Constants.Ids.ShortCode));</span><br><span class="line">    logger.info(<span class="string">&quot;随机算法策略，生成ID：&#123;&#125;&quot;</span>, idContext.getId(Constants.Ids.RandomNumeric));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230730114108030.png" alt="image-20230730114108030" style="zoom:80%;" />

<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>状态模式(State),当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230730174936387.png" alt="image-20230730174936387" style="zoom: 80%;" />

<p>状态模式的好处</p>
<p>是将与特定状态相关的行为局部化，并且将不同状态的行为分割开来</p>
<p>将特定的状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在于某个ConcreteState中，所以通过定义新的子类可以很容易地增加新的状态和转换</p>
<p>说白了，这样做的目的就是为了消除庞大的条件分支语句，大的分支判断会使得它们难以修改和<br>扩展，就像我们最早说的刻版印刷一样，任何改动和变化都是致命的。状态模式通过把各种状态转移逻辑分布到State的子类之间，来减少相互间的依赖，好比把整个版面改成了一个又一个的活字，此时就容易维护和扩展了。</p>
<p><strong>当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式了。</strong>另外如果业务需求某项业务有多个状态，通常都是一些枚举常量，状态的变化都是依靠大量的多分支判断语句来实现，此时应该考虑将每一种业务状态定义为一个State的子类。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230730175645237.png" alt="image-20230730175645237" style="zoom:80%;" />

<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230730175657790.png" alt="image-20230730175657790" style="zoom:80%;" />

<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230730180201629.png" alt="image-20230730180201629"></p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230730180223832.png" alt="image-20230730180223832" style="zoom:80%;" />

<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230730180303795.png" alt="image-20230730180303795"></p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230730180315469.png" alt="image-20230730180315469"></p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230730180323057.png" alt="image-20230730180323057" style="zoom: 60%;" /><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230730180427043.png" alt="image-20230730180427043" style="zoom:50%;" /></p>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式(Composite),将对象组合成树形结构以表示‘部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230803232735176.png" alt="image-20230803232735176" style="zoom:80%;" />





<p>透明方式，也就是说在Component中声明所有用来管理子对象的方法，其中包括Add、Remove等。这样实现Component接口的所有子类都具备了Add和Remove。这样做的好处就是叶节点和枝节点对于外界没有区别，它们具备完全一致的行为接口。但问题也很明显，因为Leaf类本身不具备Add()、Remove()方法的功能，所以实现它是没有意义的。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230803233537255.png" alt="image-20230803233537255" style="zoom:80%;" />

<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230803233551434.png" alt="image-20230803233551434" style="zoom:80%;" />

<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230803233558794.png" alt="image-20230803233558794" style="zoom:80%;" /><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230803233633400.png" alt="image-20230803233633400" style="zoom: 67%;" /></p>
<p>好处：</p>
<p>“<strong>组合模式这样就定义了包含人力资源部和财务部这些基本对象和分公司、办事处等组合对象的类层次结构。基本对象可以被组合成更复杂的组合对象，而这个组合对象又可以被组合，这样不断地递归下去，客户代码中，任何用到基本对象的地方都可以使用组合对象</strong>了。”<br>“非常好，还有没有？”<br>“<strong>我感觉用户是不用关心到底是处理一个叶节点还是处理一个组合组件，也就用不着为定义组合而写一些选择判断语句了</strong>。”<br>“简单点说，就是<strong>组合模式让客户可以一致地使用组合结构和单个对象</strong>。”</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-07-04-计算机网络1</title>
    <url>/posts/88c0.html</url>
    <content><![CDATA[<h2 id="TCP-三次握手与四次挥手面试题"><a href="#TCP-三次握手与四次挥手面试题" class="headerlink" title="TCP 三次握手与四次挥手面试题"></a>TCP 三次握手与四次挥手面试题</h2><h3 id="TCP-UDP-基础知识"><a href="#TCP-UDP-基础知识" class="headerlink" title="TCP&#x2F;UDP 基础知识"></a>TCP&#x2F;UDP 基础知识</h3><h4 id="TCP-头格式"><a href="#TCP-头格式" class="headerlink" title="TCP 头格式"></a>TCP 头格式</h4><p>原端口号,目标端口号,<strong>序列号(seq)，确认应答号，窗口大小，控制位</strong>(ACK,RST,SYN,FIN)，首部长度，校验和</p>
<p>序列号：在建立连接时由计算机生成的<strong>随机数</strong>作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></p>
<p>确认应答号：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></p>
<ul>
<li><em>ACK</em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li>
<li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li>
<li><em>SYN</em>：该位为 <code>1</code> 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li>
<li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位为 1 的 TCP 段。</li>
</ul>
 <span id="more"></span>

<h4 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h4><p><code>IP</code> 层是不可靠的,无连接的，如果需要保障网络数据包的可靠性，那么就需要由上层（<strong>传输层</strong>）的 <code>TCP</code> 协议来负责。</p>
<p>TCP 是<strong>面向连接</strong>的(一对一)、<strong>可靠的</strong>(保证每一个报文一定送到)、<strong>基于字节流</strong>的传输层通信协议。</p>
<ul>
<li><strong>字节流</strong>：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「<strong>消息的边界</strong>」，是无法读出一个有效的用户消息的。并且 TCP 报文是「<strong>有序的</strong>」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</li>
</ul>
<p>连接的定义：</p>
<ul>
<li>源地址，源端口，目的地址，目的端口TCP 四元组可以唯一的确定一个连接。</li>
<li>建立一个 TCP 连接是需要客户端与服务端达成三个信息的共识。<ul>
<li><strong>Socket</strong>：由 IP 地址和端口号组成</li>
<li><strong>序列号</strong>：用来解决乱序问题等</li>
<li><strong>窗口大小</strong>：用来做流量控制</li>
</ul>
</li>
</ul>
<h4 id="粘包问题与解决方法"><a href="#粘包问题与解决方法" class="headerlink" title="粘包问题与解决方法"></a>粘包问题与解决方法</h4><p>TCP传输协议是面向流的，就是没有界限的一串数据。它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆分成多个包就行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP拆包和粘包问题。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230411095601676.png" alt="image-20230411095601676" style="zoom: 50%;" />



<p><strong>消息定长</strong>：例如每个报文的大小为固定长度200字节，如果不够，空位补空格。</p>
<p><strong>在包尾添加特定分隔符</strong>：对于分隔符的选择一定要避免和消息体中字符相同，以免冲突。</p>
<p><strong>将消息分为消息头和消息体，消息头中包含表示消息总长度</strong></p>
<h4 id="UDP-和-TCP-有什么区别呢？"><a href="#UDP-和-TCP-有什么区别呢？" class="headerlink" title="UDP 和 TCP 有什么区别呢？"></a>UDP 和 TCP 有什么区别呢？</h4><p>UDP头格式：目标和源端口，包长度，校验和</p>
<p>UDP协议：UDP协议就是没有协议，完全依靠无连接，不可靠ip协议发送数据</p>
<p>TCP 和 UDP 区别：</p>
<ol>
<li><p>连接：面向连接,传输数据前先要建立连接；不需要连接，即刻传输数据。</p>
</li>
<li><p>服务对象：TCP 是一对一；UDP 支持一对一、一对多、多对多的交互通信</p>
</li>
<li><p>可靠性:可靠交付，无差错、不丢失、不重复、按序到达；尽最大努力交付</p>
</li>
<li><p>拥塞控制、流量控制：UDP 没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</p>
</li>
<li><p>首部开销：TCP 首部长度较长，而且是变长的；UDP 首部只有 8 个字节，并且是固定不变的</p>
</li>
<li><p>传输方式：TCP 是流式传输，没有边界，但保证顺序和可靠；UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</p>
</li>
<li><p>分片不同:</p>
<ul>
<li>TCP是按MSS 大小分片的，在传输层进行分片，在传输层组装</li>
<li>UDP是按MTU大小分片的，在 IP 层进行分片，在 IP 层组装完数据，接着再传给传输层。</li>
</ul>
<p>注：IP协议除了具有路由寻址功能外，另一个重要的功能就是IP数据包的分片处理。路由器时会被拒绝转发MTU过大的包。</p>
<p>TCP协议在建立连接的时候通常要协商双方的MSS值，这个值TCP协议在实现的时候往往用MTU值代替（需要减去IP数据包包头的大小20Bytes和TCP数据段的包头20Bytes）所以往往MSS为1460。</p>
</li>
</ol>
<p>TCP 和 UDP 应用场景：</p>
<ul>
<li>TCP：<code>FTP</code> 文件传输；HTTP &#x2F; HTTPS；</li>
<li>UDP：包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等；视频、音频等多媒体通信；广播通信；</li>
</ul>
<h4 id="TCP-和-UDP-可以使用同一个端口吗？"><a href="#TCP-和-UDP-可以使用同一个端口吗？" class="headerlink" title="TCP 和 UDP 可以使用同一个端口吗？"></a>TCP 和 UDP 可以使用同一个端口吗？</h4><p>可以。TCP 和 UDP可以看成内核中是两个完全独立的软件模块，IP 包头的「协议号」字段知道该数据包是 TCP&#x2F;UDP，所以可以根据这个信息确定送给哪个模块。在应用程序中需要定义从协议栈的哪个协议哪个端口获取数据。</p>
<h3 id="TCP-连接建立"><a href="#TCP-连接建立" class="headerlink" title="TCP 连接建立"></a>TCP 连接建立</h3><p>注意每次“握手时”状态的变化</p>
<h4 id="TCP-三次握手过程"><a href="#TCP-三次握手过程" class="headerlink" title="TCP 三次握手过程"></a>TCP 三次握手过程</h4><p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230322160617686.png" alt="image-20230322160617686"></p>
<p>注：<strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong></p>
<p>客户端收到ACK后就说明服务端已经同步了客户端的序列号，客户开启连接状态，可以开始发送数据，在这之前需要发送确认服务端SYN报文的确认报文。当服务端收到ACK报文后，表示连接已经建立，双方都可以发送数据</p>
<h4 id="为什么是三次握手？不是两次、四次？"><a href="#为什么是三次握手？不是两次、四次？" class="headerlink" title="为什么是三次握手？不是两次、四次？"></a>为什么是三次握手？不是两次、四次？</h4><p>三次握手的原因（主要与两次连接对比）</p>
<p>首先三次握手就能搞定的事情，使用四次握手就会增加通信负担。然后两次握手指。。。。</p>
<p>两次握手：客户端发送SYN，服务端收到后建立连接发送数据，并发送ack</p>
<ul>
<li><p>主要原因：<strong>三次握手可以防止「历史连接」初始化了连接。</strong></p>
<p>假设场景：客户端先发送了一个SYN报文请求连接，然后由于网络阻塞触发超时重传，新发送了一个SYN报文，但是旧的SYN报文比新的SYN报文先到了，此时应该抛弃旧的。</p>
<p>三次握手的情况如下所示</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230322191814903.png" alt="image-20230322191814903" style="zoom:67%;" />

<p>二次握手下：服务端获得旧的SYN就会创建连接并发送数据，但是等客户端发送RST报文时，已经发送了一部分数据了。</p>
</li>
<li><p>次要原因</p>
<ul>
<li><p><em>同步双方初始序列号</em></p>
<p>二次握手下，只保证了一方的初始序列号能被对方成功接收</p>
<p>三次握手下，相当于双方都给对方一个初始化序号，并得到了对方的确认，保证了同步</p>
</li>
<li><p><em>避免资源浪费</em></p>
<p>二次握手下，服务端收到客户端的SYN报文后，就可以建立连接了，但是如果客户端收不到服务端的ack报文，就会触发超时重传机制，发送多个SYN报文，这意味着服务端会创建多个连接</p>
<p>三次握手下，需要收到客户端的ack报文才能建立连接</p>
</li>
</ul>
</li>
</ul>
<p>结论：</p>
<ul>
<li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li>
<li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li>
</ul>
<h4 id="为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？"><a href="#为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？" class="headerlink" title="为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？"></a>为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</h4><ul>
<li><p>为了防止历史报文被下一个连接接收（主要方面）；</p>
<p>如果上一次发出的SYN序列号和下一次发出的SYN序列号相同，那么上一次连接中发送的数据可以会因为阻塞的原因，在下一次的连接中被服务端收到。</p>
</li>
<li><p>为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；</p>
</li>
</ul>
<h4 id="既然-IP-层会分片（MTU），为什么-TCP-层还需要-MSS-呢？"><a href="#既然-IP-层会分片（MTU），为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="既然 IP 层会分片（MTU），为什么 TCP 层还需要 MSS 呢？"></a>既然 IP 层会分片（MTU），为什么 TCP 层还需要 MSS 呢？</h4><p>首先TCP是传输层协议，IP层对TCP报文分片TCP协议是不知道的，即使IP层把一整个TCP报文分片成多个数据包发送，当其中某个数据包丢失时，也相当于整个报文都丢了，需要再重传整个报文，降低了效率。如果使用TCP先使用MSS分片，那么就只需要重传丢失的包即可</p>
<p>一般来说，TCP为了避免报文在IP层被分片，MSS的大小会小于MTU</p>
<h4 id="连接丢失的处理原则"><a href="#连接丢失的处理原则" class="headerlink" title="连接丢失的处理原则*"></a>连接丢失的处理原则*</h4><ul>
<li>这里我们假设重传机制为超时重传</li>
<li>重传的 SYN 报文的序列号都是一样的。</li>
<li>每次超时的时间是上一次的 2 倍,重传有次数上限，如果超过次数，则关闭连接。</li>
<li>达到最大重传次数就会断开连接，给断开连接的端发送报文都会收到RST</li>
<li><strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的SYN 报文。</strong></li>
</ul>
<h4 id="第一次握手丢失了，会发生什么？"><a href="#第一次握手丢失了，会发生什么？" class="headerlink" title="第一次握手丢失了，会发生什么？"></a>第一次握手丢失了，会发生什么？</h4><p>客户端：SYN_SEND -SYN 报文-&gt; CLOSE		服务端：LISTEN</p>
<h4 id="第二次握手丢失了，会发生什么？"><a href="#第二次握手丢失了，会发生什么？" class="headerlink" title="第二次握手丢失了，会发生什么？"></a>第二次握手丢失了，会发生什么？</h4><p>客户端：SYN_SEND -SYN 报文&gt;CLOSE 		服务端：SYN_RECIVE -SYN-ACK 报文&gt; CLOSE</p>
<h4 id="第三次握手丢失了，会发生什么？"><a href="#第三次握手丢失了，会发生什么？" class="headerlink" title="第三次握手丢失了，会发生什么？"></a>第三次握手丢失了，会发生什么？</h4><p>客户端：ESTABLISHED		服务端：SYN_RECIVE -SYN-ACK 报文&gt; CLOSE</p>
<h2 id="TCP-连接断开"><a href="#TCP-连接断开" class="headerlink" title="TCP 连接断开"></a>TCP 连接断开</h2><p>注意每次“挥手时”状态的变化</p>
<h4 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h4><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230411110031393.png" alt="image-20230411110031393" style="zoom:80%;" />

<p>注：<strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p>
<h4 id="为什么挥手需要四次"><a href="#为什么挥手需要四次" class="headerlink" title="为什么挥手需要四次"></a>为什么挥手需要四次</h4><ul>
<li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li>
<li>服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li>
</ul>
<h4 id="为什么TCP创建连接是三次握手，释放连接是四次握手？"><a href="#为什么TCP创建连接是三次握手，释放连接是四次握手？" class="headerlink" title="为什么TCP创建连接是三次握手，释放连接是四次握手？"></a>为什么TCP创建连接是三次握手，释放连接是四次握手？</h4><p>事实上，创建的第二次握手把SYN和ACK一起发送了才少了一次握手；而释放的第二和第三次握手之间是可以发送数据的，所以需要分开发送。因此，当释放的时候，在close_wait阶段没有数据发送并且开启了 TCP 延迟确认机制是可以将第二和第三次握手合并的，所以<strong>在一些情况下， TCP 四次挥手是可以变成 TCP 三次挥手的</strong>。</p>
<h4 id="连接丢失的处理原则-见上"><a href="#连接丢失的处理原则-见上" class="headerlink" title="连接丢失的处理原则(见上)"></a>连接丢失的处理原则(见上)</h4><ul>
<li><p>在挥手时，客户端发送FIN只是说明客户端不在发送数据了，但是可以接受数据</p>
</li>
<li><p>当客户端收到服务端的FIN时才表明不需要接受数据了，进入TIME_WAIT阶段</p>
</li>
<li><p>对于调用 close 关闭的连接，如果<strong>在 60 秒后还没有收到 FIN 报文，客户端（主动关闭方）的连接就会直接关闭</strong></p>
<p>如果主动关闭方使用 shutdown 函数关闭连接，指定了只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的。</p>
<p>下面假设都是close()关闭</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230322195004982.png" alt="image-20230322195004982" style="zoom:80%;" /></li>
</ul>
<h4 id="第一次挥手丢失了，会发生什么？"><a href="#第一次挥手丢失了，会发生什么？" class="headerlink" title="第一次挥手丢失了，会发生什么？"></a>第一次挥手丢失了，会发生什么？</h4><p>FIN_WAIT_1-FIN报文&gt; CLOSE(次数)		ESTABLISH  </p>
<h4 id="第二次挥手丢失了，会发生什么？"><a href="#第二次挥手丢失了，会发生什么？" class="headerlink" title="第二次挥手丢失了，会发生什么？"></a>第二次挥手丢失了，会发生什么？</h4><p>FIN_WAIT_1-FIN报文&gt; CLOSE(次数)		CLOSE_WAIT</p>
<h4 id="第三次挥手丢失了，会发生什么？"><a href="#第三次挥手丢失了，会发生什么？" class="headerlink" title="第三次挥手丢失了，会发生什么？"></a>第三次挥手丢失了，会发生什么？</h4><p>FIN_WAIT_2-&gt;CLOSE(60s)		LAST_ACK-FIN报文&gt;CLOSE(次数)</p>
<h4 id="第四次挥手丢失了，会发生什么？"><a href="#第四次挥手丢失了，会发生什么？" class="headerlink" title="第四次挥手丢失了，会发生什么？"></a>第四次挥手丢失了，会发生什么？</h4><p>TIME_WAIT(2MSL)		LAST_ACK-&gt;CLOSE(次数)</p>
<ul>
<li>客户端在收到第三次挥手后，就会进入 TIME_WAIT 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（FIN 报文）后，就会重置定时器，当等待 2MSL 时长后，客户端就会断开连接。</li>
</ul>
<h4 id="为什么需要-TIME-WAIT-状态"><a href="#为什么需要-TIME-WAIT-状态" class="headerlink" title="为什么需要 TIME_WAIT 状态"></a>为什么需要 TIME_WAIT 状态</h4><ul>
<li><p>客户端需要等待2MSL后才能建立新的连接，主要是防止历史连接中的数据，被后面相同四元组的连接错误的接收；</p>
<p>序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据。</p>
<p><code>2MSL</code> 时长，这个时间足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，此时再建立连接就不会收到旧连接的数据了</p>
</li>
<li><p>保证「被动关闭连接」的一方，能被正确的关闭；</p>
<p>就是确保客户端的ACK可以到达服务端。当ACK丢失时，留给服务端充足的时长重传FIN</p>
</li>
</ul>
<h4 id="为什么-TIME-WAIT-等待的时间是-2MSL"><a href="#为什么-TIME-WAIT-等待的时间是-2MSL" class="headerlink" title="为什么 TIME_WAIT 等待的时间是 2MSL"></a>为什么 TIME_WAIT 等待的时间是 2MSL</h4><p><code>MSL</code> 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p>
<p>2MSL时长 这其实是相当于至少允许报文丢失一次。TIME_WAIT在收到FIN起开始发送ACK，并开始计时，ACK应该在一个 MSL 内到达服务端。如果此时ACK丢失了，最多只花费了一个 MSL，重传的FIN报文也可以在第2个MSL内到达。</p>
<h4 id="TIME-WAIT-状态的危害。服务器出现大量-TIME-WAIT-状态的原因有哪些"><a href="#TIME-WAIT-状态的危害。服务器出现大量-TIME-WAIT-状态的原因有哪些" class="headerlink" title="TIME_WAIT 状态的危害。服务器出现大量 TIME_WAIT 状态的原因有哪些"></a>TIME_WAIT 状态的危害。服务器出现大量 TIME_WAIT 状态的原因有哪些</h4><p>危害：占用系统资源，占用端口资源</p>
<p>如果服务端要避免过多的 TIME_WAIT 状态的连接，就永远不要主动断开连接，让客户端去断开，由分布在各处的客户端去承受 TIME_WAIT。</p>
<p>原因：HTTP 没有使用长连接</p>
<p>无论是客户端还是服务端哪一方没有开启长链接，都是服务端主动断开连接</p>
<h4 id="如果已经建立了连接，但是主机突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是主机突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是主机突然出现故障了怎么办？"></a>如果已经建立了连接，但是主机突然出现故障了怎么办？</h4><p>TCP保活机制：定义一个时间段，在这个时间段(2小时)内，如果没有任何连接相关的活动，每隔一个时间间隔(75秒)，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文（9）都没有得到响应，则认为当前的 TCP 连接已经死亡。</p>
<ul>
<li>第一种，对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 TCP 保活时间会被重置，等待下一个 TCP 保活时间的到来。</li>
<li>第二种，对端主机宕机并重启。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，<strong>会产生一个 RST 报文</strong>，这样很快就会发现 TCP 连接已经被重置。</li>
<li>第三种，是对端主机宕机（<em>注意不是进程崩溃</em>），或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</li>
</ul>
<p>缺陷：检测的时间有点长，可以自己在应用层实现一个心跳机制。</p>
<h4 id="如果已经建立了连接，但是进程崩溃会发生什么？"><a href="#如果已经建立了连接，但是进程崩溃会发生什么？" class="headerlink" title="如果已经建立了连接，但是进程崩溃会发生什么？"></a>如果已经建立了连接，但是进程崩溃会发生什么？</h4><p>TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。kill同理。</p>
<h2 id="TCP-重传、滑动窗口、流量控制、拥塞控制"><a href="#TCP-重传、滑动窗口、流量控制、拥塞控制" class="headerlink" title="TCP 重传、滑动窗口、流量控制、拥塞控制*"></a>TCP 重传、滑动窗口、流量控制、拥塞控制*</h2><h3 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h3><h4 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h4><p><code>RTT</code> 指的是数据发送时刻到接收到确认的时刻的差值，也就是包的往返时间。</p>
<p>发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据，也就是我们常说的超时重传。</p>
<p>注意ACK报文(不携带数据的那种)丢失是不会触发超时重传的</p>
<h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>快速重传（Fast Retransmit）机制，它不以时间为驱动，而是以数据驱动重传。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230322212803400.png" alt="image-20230322212803400" style="zoom:80%;" />

<ul>
<li>因为每次ACK会发送这个丢失数据的序列号，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</li>
</ul>
<h4 id="SACK-方法"><a href="#SACK-方法" class="headerlink" title="SACK 方法"></a>SACK 方法</h4><p>快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，是重传一个，还是重传所有的问题。</p>
<p><code>SACK</code>（ Selective Acknowledgment）， 选择性确认。</p>
<p>这种方式需要在 TCP 头部「选项」字段里加一个 <code>SACK</code> 的东西，它可以将已收到的数据的信息发送给「发送方」，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。</p>
<p><strong>注：这三个重传机制互补的，不是选择关系。</strong></p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230323101253162.png" alt="image-20230323101253162" style="zoom:80%;" />

<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230323101258804.png" alt="image-20230323101258804" style="zoom:80%;" />

<p>注：</p>
<ol>
<li><strong>一个 TCP 连接的双端（客户端和服务端）都有各自的接收方和发送方窗口。</strong></li>
<li>发送窗口的大小由接收窗口决定（相等），接收窗口变化时会通过window告诉发送方</li>
<li>发送窗口比接受窗口复杂，发送窗口会包含已发送部分和未发送(可用窗口)部分，只有得到确认时才会整体移动窗口，发送数据只会移动SND.NXT内部指针；接收窗口只有未接收部分，因为接收窗口接收数据时就会移动整个窗口RCV.NXT。</li>
<li>修正：当服务器不能及时处理读取的数据时，就不会移动整个窗口了，但是会移动RCV.NXT，表现为接受窗口缩小了。</li>
</ol>
<h4 id="滑动窗口的作用："><a href="#滑动窗口的作用：" class="headerlink" title="滑动窗口的作用："></a>滑动窗口的作用：</h4><ul>
<li>同时发送多个数据，然后一起应答，提高通信效率</li>
<li>流量控制（见下）</li>
</ul>
<p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p>
<p>使用滑动窗口后，只需要ACK返回最后一个序号的报文就说明前面的报文已经收到了。这个模式就叫累计确认或者累计应答。</p>
<h4 id="窗口大小由哪一方决定？"><a href="#窗口大小由哪一方决定？" class="headerlink" title="窗口大小由哪一方决定？"></a>窗口大小由哪一方决定？</h4><p>通常窗口的大小是由接收方的窗口大小来决定的。</p>
<p>发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。</p>
<h4 id="接收窗口和发送窗口的大小是相等的吗？"><a href="#接收窗口和发送窗口的大小是相等的吗？" class="headerlink" title="接收窗口和发送窗口的大小是相等的吗？"></a>接收窗口和发送窗口的大小是相等的吗？</h4><p>一端的接收窗口是约等于另一端的发送窗口的。因为滑动窗口并不是一成不变的，接受窗口的大小会被操作系统调整，通过发送 TCP 报文的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><h4 id="如何实现流量控制"><a href="#如何实现流量控制" class="headerlink" title="如何实现流量控制"></a>如何实现流量控制</h4><ul>
<li>发送方的发送数据受发送窗口限制，不能发送比发送窗口中可用窗口大的数据</li>
<li>接受窗口决定发送窗口的大小，接受方时刻告诉发送方自己的窗口大小，保持约等于状态</li>
</ul>
<h4 id="操作系统缓冲区与滑动窗口的关系"><a href="#操作系统缓冲区与滑动窗口的关系" class="headerlink" title="操作系统缓冲区与滑动窗口的关系"></a>操作系统缓冲区与滑动窗口的关系</h4><ul>
<li><p>当服务端非常的繁忙，应用层不能及时读取数据时，服务端会缩小窗口，只移动RCV.NXT指针，并通过TCP报文的window字段告诉发送方，导致发送方窗口变小。</p>
</li>
<li><p>当服务端系统资源非常紧张的时候，操作系统可能会直接减少了接收缓冲区大小，此时接受窗口变小了，但是没有来得及告诉发送方，发送方发送了超出接受范围的数据过来就会出现丢包。</p>
<p>因此，<strong>TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。</strong></p>
</li>
</ul>
<h3 id="窗口关闭"><a href="#窗口关闭" class="headerlink" title="窗口关闭"></a>窗口关闭</h3><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230323110234948.png" alt="image-20230323110234948" style="zoom:80%;" />

<p>如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。</p>
<p>问题：假设接受方的向发送方通告一个窗口非 0 的 ACK 报文，它只是一个ACK报文不携带数据，那么当这个包丢失时，不会触发重传机制，此时发送方一直等待接受方的非0通知，而接受方也一直等待发送方的数据，导致死锁。</p>
<p>解决方法：只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。如果持续计时器超时，就会发送窗口探测 ( Window probe ) 报文，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><h4 id="拥塞控制的定义和流量控制的区别："><a href="#拥塞控制的定义和流量控制的区别：" class="headerlink" title="拥塞控制的定义和流量控制的区别："></a>拥塞控制的定义和流量控制的区别：</h4><ul>
<li><p>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….</p>
</li>
<li><p>拥塞控制的目的是避免「发送方」的数据填满整个网络。</p>
</li>
<li><p>流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。</p>
</li>
</ul>
<h4 id="什么是拥塞窗口"><a href="#什么是拥塞窗口" class="headerlink" title="什么是拥塞窗口"></a>什么是拥塞窗口</h4><ul>
<li>拥塞窗口 cwnd是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的。</li>
<li>加入了拥塞窗口后，发送窗口的值是swnd &#x3D; min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。</li>
</ul>
<h4 id="怎么知道当前网络是否出现了拥塞"><a href="#怎么知道当前网络是否出现了拥塞" class="headerlink" title="怎么知道当前网络是否出现了拥塞"></a>怎么知道当前网络是否出现了拥塞</h4><p>只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是发生了超时重传，就会认为网络出现了拥塞。</p>
<h4 id="拥塞控制的算法："><a href="#拥塞控制的算法：" class="headerlink" title="拥塞控制的算法："></a>拥塞控制的算法：</h4><p>拥塞窗口 <code>cwnd</code> 变化的规则：只要网络中没有出现拥塞，<code>cwnd</code> 就会增大；但网络中出现了拥塞，<code>cwnd</code> 就减少；</p>
<ul>
<li><p>慢启动</p>
<p>规则：当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。指数级增长。</p>
</li>
</ul>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230323114300340.png" alt="image-20230323114300340" style="zoom:80%;" />

<p>​		有一个叫慢启动门限 <code>ssthresh</code> （slow start threshold）状态变量。</p>
<p>​		当 <code>cwnd</code> &lt; <code>ssthresh</code> 时，使用慢启动算法。</p>
<p>​		当 <code>cwnd</code> &gt;&#x3D; <code>ssthresh</code> 时，就会使用「拥塞避免算法」。</p>
<h4 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h4><ul>
<li><p>拥塞避免算法</p>
<p>规则：每当收到一个 ACK 时，cwnd 增加 1&#x2F;cwnd。线性增长</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230323114336256.png" alt="image-20230323114336256" style="zoom:80%;" />

<p>一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</p>
<p>当触发了重传机制，也就进入了「拥塞发生算法」。</p>
</li>
<li><p>拥塞发生</p>
<p>拥塞发生算法会根据重传机制的不同而不同：</p>
<ul>
<li><p>当重传机制为<strong>超时重传</strong>时：</p>
<ul>
<li><code>ssthresh</code> 设为 <code>cwnd/2</code>，</li>
<li><code>cwnd</code> 重置为 <code>1</code> （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）</li>
<li>继续慢启动算法</li>
</ul>
</li>
<li><p>当重传机制为<strong>快速重传</strong>时：</p>
<ul>
<li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li>
<li><code>ssthresh = cwnd</code>;</li>
<li>进入快速恢复算法</li>
</ul>
</li>
<li><p>区别：</p>
<p>超时重传会一下子突然减少数据流，会造成网络卡顿。适合拥塞比较严重的情况</p>
<p>快速重传的机制为当接收方发现丢了一个中间包的时候（通过发送三个后面的包确认），发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。</p>
<p>快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 <code>RTO</code> 超时那么强烈。</p>
</li>
</ul>
</li>
<li><p>快速恢复（面试时往简单的将）</p>
<p>快速重传和快速恢复算法一般同时使用</p>
<p>快速恢复算法如下：</p>
<ol>
<li>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3 个数据包被收到了）；</li>
<li>重传丢失的数据包；</li>
<li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li>
<li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li>
<li>如果收不到新数据的 ACK，那么就会触发超时重传了。</li>
</ol>
</li>
</ul>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230323120316069.png" alt="image-20230323120316069" style="zoom:80%;" />

<p>过程3为了尽快将丢失的数据包发给目标，从而解决拥塞的根本问题（三次相同的 ACK 导致的快速重传，能收到ACK说明不是很拥塞，可能是别的原因造成丢失），所以这一过程中 cwnd 反而是逐渐增大的。</p>
<p>快速恢复是拥塞发生后慢启动的优化，其首要目的仍然是降低 cwnd 来减缓拥塞，所以必然会出现 cwnd 从大到小的改变。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-07-04-计算机网络2</title>
    <url>/posts/8980.html</url>
    <content><![CDATA[<h1 id="计网（小林coding）"><a href="#计网（小林coding）" class="headerlink" title="计网（小林coding）"></a>计网（小林coding）</h1><h2 id="1-当键入网址后，到网页显示，其间发生了什么"><a href="#1-当键入网址后，到网页显示，其间发生了什么" class="headerlink" title="1.当键入网址后，到网页显示，其间发生了什么"></a>1.当键入网址后，到网页显示，其间发生了什么</h2><p>http</p>
<p>首先浏览器做的第一步工作就是要对 <code>URL</code> 进行解析，从而生成发送给 <code>Web</code> 服务器的请求信息。</p>
<p>dns</p>
<p>由于大多数网址都使用的是域名，因此在发送之前需要查询服务器域名对应的 IP 地址。</p>
<p>协议栈</p>
<p>通过 DNS 获取到 IP 后，浏览器委托协议栈进行http请求消息的传输工作。</p>
<p>tcp</p>
<p>HTTP是基于TCP的，所以在协议栈会使用TCP协议，在HTTP请求中添加TCP报文头部。TCP是面向连接的，所以在开始发送数据之前，需要通过三次握手来建立连接，然后才能发送数据。</p>
<p>ip</p>
<p>TCP报文中在添加IP头部，用于在网络层中寻找目的地址的网络。</p>
<p>mac</p>
<p>然后在IP报文中添加MAC头部，用于在以太网中传输数据。</p>
<p>最后将这个封装了TCP头部，IP头部，和MAC头部的HTTPx消息交由</p>
<p>网卡发送出去，中间会使用路由器通过ip地址转发，使用交换机通过mac地址转发，最后到达服务器设备。</p>
<p>服务器的网卡收到数据包后，通过层层拆包，最后在TCP 头部端口号中发现某个HTTP 的服务器正在监听这个端口号</p>
<p>于是交由这个HTTP进程处理，发现这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里。</p>
<p>http套上tcp，ip，mac头部，然后发送出去。客户端收到该报文后，解析出http响应报文后，浏览器渲染页面并显示。</p>
 <span id="more"></span>

<p>mac地址和ip地址的作用区别</p>
<ul>
<li>mac地址是以太网中使用的，在网络传输过程中ip地址是不会该改变的，但是mac地址会不断变化</li>
<li>路由器与路由器之间可能存在交换机，而交换机值工作在mac层，只能识别mac地址。</li>
<li>mac地址表示发送的下一个设备的地址，ip地址表示的是目的地址，即最终地址，通过路由器的路由表确定ip数据包的下一跳。</li>
<li>MAC 的作用则是实现「直连」的两个设备之间通信，而 IP 则负责在「没有直连」的两个网络之间进行通信传输。</li>
</ul>
<h2 id="HTTP常见面试题"><a href="#HTTP常见面试题" class="headerlink" title="HTTP常见面试题"></a>HTTP常见面试题</h2><h3 id="一-HTTP-基本概念"><a href="#一-HTTP-基本概念" class="headerlink" title="一. HTTP 基本概念"></a>一. HTTP 基本概念</h3><h4 id="HTTP是什么"><a href="#HTTP是什么" class="headerlink" title="HTTP是什么"></a>HTTP是什么</h4><p>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</p>
<h4 id="HTTP报文的格式"><a href="#HTTP报文的格式" class="headerlink" title="HTTP报文的格式"></a>HTTP报文的格式</h4><p>请求报文：请求行，请求头，请求体</p>
<p>请求行：请求方法，URL，HTTP协议版本</p>
<p>响应报文：响应行，响应头，响应体</p>
<p>响应行：状态码，状态消息(ok，redirect)，HTTP协议版本</p>
<h4 id="HTTP常见的状态码有哪些？"><a href="#HTTP常见的状态码有哪些？" class="headerlink" title="HTTP常见的状态码有哪些？"></a>HTTP常见的状态码有哪些？</h4><p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/6-%E4%BA%94%E5%A4%A7%E7%B1%BBHTTP%E7%8A%B6%E6%80%81%E7%A0%81.png" alt=" 五大类 HTTP 状态码 "></p>
<p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p>
<p>304 Not Modified不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</p>
<h4 id="HTTP常见字段有哪些？"><a href="#HTTP常见字段有哪些？" class="headerlink" title="HTTP常见字段有哪些？"></a>HTTP常见字段有哪些？</h4><p><em>Host</em> 字段：客户端发送请求时，用来指定服务器的域名。</p>
<p><em>Content-Length 字段</em>：</p>
<ul>
<li>表明本次回应的数据长度，后面的字节就属于下一个回应了。</li>
<li>HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题。</li>
</ul>
<p><em>Connection 字段</em>：Keep-Alive</p>
<ul>
<li>用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。</li>
<li>开启了 HTTP Keep-Alive 机制后， 连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接，一直持续到客户端或服务器端提出断开连接。</li>
<li>HTTP&#x2F;1.1 版本的默认连接都是长连接</li>
</ul>
<p><em>Content-Type 字段</em>：text&#x2F;html; Charset&#x3D;utf-8</p>
<ul>
<li><code>Content-Type</code> 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</li>
</ul>
<p><code>Accept</code> 字段：声明自己可以接受哪些数据格式。</p>
<p><em>Content-Encoding 字段</em>：说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</p>
<h3 id="二-Get-与-Post"><a href="#二-Get-与-Post" class="headerlink" title="二. Get 与 Post"></a>二. Get 与 Post</h3><h5 id="GET-和-POST-有什么区别？"><a href="#GET-和-POST-有什么区别？" class="headerlink" title="GET 和 POST 有什么区别？"></a>GET 和 POST 有什么区别？</h5><ul>
<li><strong>GET 的语义是从服务器获取指定的资源</strong>，这个资源可以是静态的文本、页面、图片视频等。<strong>GET 请求的参数位置一般是写在 URL 中</strong>，URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符 ，而且<strong>浏览器会对 URL 的长度有限制</strong></li>
<li><strong>POST 的语义是根据请求负荷（报文body）对指定的资源做出处理</strong>，具体的处理方式视资源类型而不同。POST 请求<strong>携带数据的位置一般是写在报文 body</strong> 中，body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且<strong>浏览器不会对 body 大小做限制</strong>。</li>
</ul>
<h5 id="GET-和-POST-方法都是安全和幂等的吗？"><a href="#GET-和-POST-方法都是安全和幂等的吗？" class="headerlink" title="GET 和 POST 方法都是安全和幂等的吗？"></a>GET 和 POST 方法都是安全和幂等的吗？</h5><p>安全：指请求方法不会「破坏」服务器上的资源。</p>
<p>幂等：意思是多次执行相同的操作，结果都是「相同」的。</p>
<p>GET 方法是安全、幂等、可被缓存的。</p>
<p>POST 不安全，不幂等，（大部分实现）不可缓存。</p>
<p>事实上，上面的结论是在遵守规范的前提下的，get和post是否安全，幂等主要看程序员如何使用，如果程序员使用get来删除数据那就是不安全，不幂等的。</p>
<h5 id="GET-请求可以带-body-吗？"><a href="#GET-请求可以带-body-吗？" class="headerlink" title="GET 请求可以带 body 吗？"></a>GET 请求可以带 body 吗？</h5><p>理论上，任何请求都可以带 body 的。只是因为 RFC 规范定义的 GET 请求是获取资源，所以根据这个语义不需要用到 body。另外，URL 中的查询&#x3D; 参数也不是 GET 所独有的，POST 请求的 URL 中也可以有参数的。</p>
<h5 id="body中的数据一定是不可见的吗？"><a href="#body中的数据一定是不可见的吗？" class="headerlink" title="body中的数据一定是不可见的吗？"></a>body中的数据一定是不可见的吗？</h5><ul>
<li>GET 用 URL 传输数据，请求会显示地址栏中；POST 用 body 传输数据</li>
<li>HTTP 传输的内容都是明文的，虽然在浏览器地址拦看不到 POST 提交的 body 数据，但是只要抓个包就都能看到了。</li>
<li>使用HTTPS 协议，所有 HTTP 的数据都会被加密传输。</li>
</ul>
<h3 id="三-HTTP-缓存技术"><a href="#三-HTTP-缓存技术" class="headerlink" title="三. HTTP 缓存技术"></a>三. HTTP 缓存技术</h3><p>什么是缓存技术</p>
<p>对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都<strong>缓存在本地</strong>，那么下次就直接读取本地的数据</p>
<p>注：HTTP 中协商缓存与强制缓存并没有互斥性，这两套机制是并行工作的，譬如，<strong>当强制缓存存在时，直接从强制缓存中返回资源，无须进行变动检查；而当强制缓存超过时效，协商缓存仍可以正常地工作。</strong></p>
<p>强制缓存</p>
<p>强制缓存在浏览器的地址输入、页面链接跳转、新开窗口、前进和后退中均可生效，但在用户主动刷新页面时应当自动失效</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230321120004463.png" alt="image-20230321120004463" style="zoom: 50%;" />

<ul>
<li>强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。</li>
<li>实现原理：<ul>
<li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</li>
<li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li>
<li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control</li>
</ul>
</li>
</ul>
<p>协商缓存</p>
<ul>
<li><p>请求的响应码是 <code>304</code>，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用本地缓存的方式被称为协商缓存。</p>
</li>
<li><p>原理：</p>
<p>协商缓存有两种变动检查机制，分别是根据资源的修改时间进行检查，以及根据资源唯一标识是否发生变化来进行检查，它们都是靠一组成对出现的请求、响应 Header 来实现的</p>
<p><strong>Last-Modified 和 If-Modified-Since</strong>：</p>
<p>Last-Modified 是服务器的响应 Header，用于告诉客户端这个资源的最后修改时间。对于带有这个 Header 的资源，当客户端需要再次请求时，会通过 If-Modified-Since 把之前收到的资源最后修改时间发送回服务端。</p>
<p>如果此时服务端发现资源在该时间后没有被修改过，就只要返回一个 304&#x2F;Not Modified 的响应，无须附带消息体</p>
<p>如果此时服务端发现资源在该时间之后有变动，就会返回 200&#x2F;OK 的完整响应，在消息体中包含最新的资源</p>
<p><strong>Etag 和 If-None-Match</strong>：</p>
<p>Etag 是服务器的响应 Header，用于告诉客户端这个资源的唯一标识。Etag 值默认是对文件的索引节点（INode），大小和最后修改时间进行哈希计算后得到的。对于带有这个 Header 的资源，当客户端需要再次请求时，会通过 If-None-Match 把之前收到的资源唯一标识发送回服务端。</p>
<p>如果此时服务端计算后发现资源的唯一标识与上传回来的一致，说明资源没有被修改过，就只要返回一个 304&#x2F;Not Modified 的响应即可，无须附带消息体</p>
<p>如果此时服务端发现资源的唯一标识有变动，就会返回 200&#x2F;OK 的完整响应，在消息体中包含最新的资源</p>
</li>
</ul>
<p><a href="https://www.xiaolincoding.com/network/2_http/http_interview.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98">https://www.xiaolincoding.com/network/2_http/http_interview.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98</a></p>
<h3 id="四-HTTP-特性"><a href="#四-HTTP-特性" class="headerlink" title="四. HTTP 特性"></a>四. HTTP 特性</h3><h4 id="HTTP-1-1-的优点"><a href="#HTTP-1-1-的优点" class="headerlink" title="HTTP&#x2F;1.1 的优点"></a>HTTP&#x2F;1.1 的优点</h4><ol>
<li><em>简单</em>：报文格式header+body，头部信息key-value</li>
<li><em>灵活和易于扩展</em>：HTTP 协议里的各类请求方法、URI&#x2F;URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员<strong>自定义和扩充</strong>。</li>
<li>支持长链接<ul>
<li>在HTTP1.0中，每发起一个请求，都要新建一次 TCP 连接；在HTTP&#x2F;1.1 中，提出了<strong>长连接</strong>的通信方式，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</li>
<li>注：长链接只是实现了一次TCP可以发送多次请求，但是这些请求仍然是串行的。</li>
</ul>
</li>
</ol>
<h4 id="HTTP-1-1-的缺点"><a href="#HTTP-1-1-的缺点" class="headerlink" title="HTTP&#x2F;1.1 的缺点"></a>HTTP&#x2F;1.1 的缺点</h4><ol>
<li>无状态 : 既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。比较简单的方式用 <strong>Cookie</strong> 技术。但是使用Cookies如果是前后端项目会出现跨域问题</li>
<li>不安全：<ul>
<li>通信使用明文（不加密），内容可能会被窃听。</li>
<li>不验证通信方的身份，因此有可能遭遇伪装。</li>
<li>无法证明报文的完整性，所以有可能已遭篡改。</li>
<li>HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL&#x2F;TLS 层，使得在安全上达到了极致。</li>
</ul>
</li>
<li>队头阻塞：在请求 - 应答模式下，如果一个请求没有得到应答，那么下一个请求也会被阻塞。<ul>
<li>在请求 - 应答模式下，如果一个请求没有得到应答，那么下一个请求也会被阻塞。</li>
<li>因此，HTTP1中如果要实现真正的并发，只能通过增加TCP连接数</li>
</ul>
</li>
</ol>
<h4 id="HTTP-1-1-的性能"><a href="#HTTP-1-1-的性能" class="headerlink" title="HTTP&#x2F;1.1 的性能"></a>HTTP&#x2F;1.1 的性能</h4><p><em>1. 长连接</em></p>
<p>2.<em>管道网络传输</em>：</p>
<ul>
<li><p>HTTP&#x2F;1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。</p>
</li>
<li><p>使用管道可以实现只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去</p>
</li>
<li><p>服务器必须按照接收请求的顺序发送对这些管道化请求的响应。</p>
</li>
<li><p>HTTP&#x2F;1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞。</p>
</li>
<li><h5 id="HTTP-1-1-管道化技术不是默认开启，而且浏览器基本都没有支持"><a href="#HTTP-1-1-管道化技术不是默认开启，而且浏览器基本都没有支持" class="headerlink" title="HTTP&#x2F;1.1 管道化技术不是默认开启，而且浏览器基本都没有支持"></a>HTTP&#x2F;1.1 管道化技术不是默认开启，而且浏览器基本都没有支持</h5></li>
</ul>
<p>3.<em>队头阻塞</em></p>
<h3 id="五-HTTPS-与-HTTP"><a href="#五-HTTPS-与-HTTP" class="headerlink" title="五. HTTPS 与 HTTP"></a>五. HTTPS 与 HTTP</h3><h4 id="HTTP-与-HTTPS-有哪些区别"><a href="#HTTP-与-HTTPS-有哪些区别" class="headerlink" title="HTTP 与 HTTPS 有哪些区别"></a>HTTP 与 HTTPS 有哪些区别</h4><ul>
<li>HTTP明文传输；HTTPS在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。（注SSL和TLS是一个东西）</li>
<li>HTTP  TCP 三次握手；HTTPS  TCP 三次握手 + SSL&#x2F;TLS 的握手</li>
<li>HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书</li>
</ul>
<h4 id="HTTPS-解决了-HTTP-的哪些问题"><a href="#HTTPS-解决了-HTTP-的哪些问题" class="headerlink" title="HTTPS 解决了 HTTP 的哪些问题"></a>HTTPS 解决了 HTTP 的哪些问题</h4><ul>
<li><strong>信息加密</strong>：交互信息无法被窃取 -&gt;<strong>混合加密</strong></li>
<li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示 -&gt;<strong>摘要算法</strong>实现<strong>完整性</strong></li>
<li><strong>身份证书</strong>：证明淘宝是真的淘宝网 -&gt;将服务器公钥放入到<strong>数字证书</strong>中</li>
</ul>
<p>​	非对称加密的用途：</p>
<ul>
<li>公钥加密，私钥解密。这个目的是为了保证内容传输的安全，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容</li>
<li>私钥加密，公钥解密。这个目的是为了保证消息不会被冒充，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</li>
</ul>
<ol>
<li><p>混合加密</p>
<ul>
<li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。因为非对称加密可以解决密钥交换问题，公钥可以任意分发而私钥保密</li>
<li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。因为对称加密的速度快</li>
</ul>
</li>
<li><p><em>摘要算法 + 数字签名</em></p>
<ul>
<li>通过「私钥加密，公钥解密」的方式，来确认消息的身份</li>
<li>私钥加密内容不是内容本身，而是对内容的哈希值加密，哈希值是通过hash(内容)计算的。摘要算法指hash函数，数字签名指私钥加密哈希值</li>
<li>如果客户端使用hash(内容)计算出来的哈希值和通过公钥解密的哈希值不同，说明内容被修改了。</li>
</ul>
</li>
<li><p>数字证书</p>
<ul>
<li><p>防止伪造公钥的秘诀在于，将服务器公钥放在数字证书中，数字证书统一交由数字证书认证机构颁发</p>
</li>
<li><p>伪造的数字证书是不能通过CA的公钥解密的。（过程类似于数字签名，最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。）</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230321165140044.png" alt="image-20230321165140044" style="zoom:80%;" /></li>
</ul>
</li>
</ol>
<h4 id="证书信任链"><a href="#证书信任链" class="headerlink" title="证书信任链"></a><strong>证书信任链</strong></h4><p>根据信任链，可以大致将证书分为根证书，中间证书，服务器证书</p>
<p>一开始，客户端只信任根证书，根证书是内置在操作系统中的。所谓的信任链，就是根证书信任中间证书，中间证书信任服务器证书，也就是说如果操作系统中只有根证书的话，是无法直接验证服务器证书的，因为服务器证书不是它颁发的。</p>
<p>客户端会根据服务器证书中的签发者，找到该证书的颁发机构是，然后向 CA 请求该中间证书。这样信任链就完整了。</p>
<h4 id="HTTPS-是如何建立连接的？其间交互了什么？"><a href="#HTTPS-是如何建立连接的？其间交互了什么？" class="headerlink" title="HTTPS 是如何建立连接的？其间交互了什么？"></a>HTTPS 是如何建立连接的？其间交互了什么？</h4><ul>
<li>客户端获取公钥：TLS 证书部署服务端时，证书文件其实就是服务端的公钥，服务端的私钥则一直留在服务端，证书文件会在 TLS 握手阶段传递给客户端，客户端通过浏览器或者操作系统中的 CA 公钥，确认服务器的证书的真实性。如果证书没有问题，客户端会<strong>从证书中取出服务器的公钥</strong></li>
<li>协商密钥：服务端的私钥则一直留在服务端，可以用来解密公钥加密的数据。由客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端。之后发送的内容就是用同一个密钥加密解密。</li>
</ul>
<h4 id="HTTPS-的应用数据是如何保证完整性的"><a href="#HTTPS-的应用数据是如何保证完整性的" class="headerlink" title="HTTPS 的应用数据是如何保证完整性的"></a>HTTPS 的应用数据是如何保证完整性的</h4><ul>
<li><em>摘要算法 + 数字签名</em></li>
</ul>
<h4 id="HTTPS-一定安全可靠吗"><a href="#HTTPS-一定安全可靠吗" class="headerlink" title="HTTPS 一定安全可靠吗"></a>HTTPS 一定安全可靠吗</h4><ul>
<li>HTTPS 协议本身到目前为止还是没有任何漏洞的</li>
<li>不安全的原因：用户信任该网站的数字证书或者在浏览器中被恶意导入伪造的CA公钥</li>
</ul>
<h3 id="六-HTTP-1-1、HTTP-2、HTTP-3-演变"><a href="#六-HTTP-1-1、HTTP-2、HTTP-3-演变" class="headerlink" title="六. HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变"></a>六. HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变</h3><h4 id="HTTP-2-的优势"><a href="#HTTP-2-的优势" class="headerlink" title="HTTP&#x2F;2 的优势"></a>HTTP&#x2F;2 的优势</h4><ul>
<li><p>头部压缩</p>
<p>在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号</p>
</li>
<li><p>二进制格式</p>
<p>HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 里的纯文本形式的报文，而是全面采用了<strong>二进制格式</strong>，头信息和数据体都是二进制</p>
<p>比如状态码 200 ，在 HTTP&#x2F;1.1 是用 ‘2’’0’’0’ 三个字符来表示（二进制：00110010 00110000 00110000），共用了 3 个字节；在 HTTP&#x2F;2 对于状态码 200 的二进制编码是 10001000，只用了 1 字节</p>
</li>
<li><p>多路复用（HTTP&#x2F;2 Multiplexing）技术</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230924213740956.png" alt="image-20230924213740956" style="zoom:80%;" />

<p>HTTP2可以在一条TCP连接中同时创建多个stream，同一个HTTP请求与响应都是跑在同一个stream中的，将多个请求跑在多个stream就实现了并发发送请求和响应了。</p>
<p>同一个连接中的 Stream ID 是不能复用的，只能顺序递增，所以当 Stream ID 耗尽时，需要发一个控制帧 <code>GOAWAY</code>，用来关闭 TCP 连接。</p>
<p>注：在 Nginx 中，可以通过 <code>http2_max_concurrent_Streams</code> 配置来设置 Stream 的上限，默认是 128 个。浏览器对每个域名最多 6 个连接数限制</p>
</li>
<li><p>服务器主动推送资源</p>
<p>服务端不再是被动地响应，可以主动向客户端发送消息。</p>
<p>客户端和服务器双方都可以建立 Stream， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</p>
</li>
</ul>
<h4 id="HTTP-2-有什么缺陷"><a href="#HTTP-2-有什么缺陷" class="headerlink" title="HTTP&#x2F;2 有什么缺陷"></a>HTTP&#x2F;2 有什么缺陷</h4><p>HTTP&#x2F;2 通过 Stream 的并发能力，解决了 HTTP&#x2F;1 队头阻塞的问题（可以连续发送多个请求或者响应），但是 HTTP&#x2F;2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层。</p>
<p>HTTP&#x2F;2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP&#x2F;2 应用层才能从内核中拿到数据，这就是 HTTP&#x2F;2 队头阻塞问题。</p>
<p>一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230321191249314.png" alt="image-20230321191249314" style="zoom:80%;" />

<h4 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h4><ul>
<li><p>队头阻塞的问题</p>
<ul>
<li>HTTP&#x2F;1.1 中的管道（ pipeline）虽然解决了请求的队头阻塞，但是<strong>没有解决响应的队头阻塞</strong>，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应完这个请求后， 才能处理下一个请求，这属于 HTTP 层队头阻塞。</li>
<li>HTTP&#x2F;2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是<strong>一旦发生丢包，就会阻塞住所有的 HTTP 请求</strong>，这属于 TCP 层队头阻塞。</li>
<li>HTTP&#x2F;2 队头阻塞的问题是因为 TCP，所以 <strong>HTTP&#x2F;3 把 HTTP 下层的 TCP 协议改成了 UDP！</strong></li>
<li>UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP&#x2F;2 队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输。</li>
</ul>
</li>
<li><p>QUIC 协议 </p>
<ul>
<li><p><em>无队头阻塞</em>：QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230321193835214.png" alt="image-20230321193835214" style="zoom:80%;" />
</li>
<li><p>更快的连接建立：</p>
<ul>
<li>HTTP&#x2F;1 和 HTTP&#x2F;2 协议中，TCP 和 TLS 是分层的，需要分批次来握手，先 TCP 握手，再 TLS 握手。HTTP&#x2F;3 QUIC 内部包含了 TLS，可以同时建立连接。</li>
<li>QUIC 握手的目的是为确认双方的「连接 ID」所以很快</li>
</ul>
</li>
<li><p>连接迁移：</p>
<ul>
<li>在TCP协议中，源 IP、源端口、目的 IP、目的端口确定一条TCP连接，当切换网络时<strong>IP 地址变化了，那么就必须要断开连接，然后重新建立连接</strong>。</li>
<li>QUIC 协议通过<strong>连接 ID</strong> 来标记通信的两个端点，即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有连接 ID等信息，就可以“无缝”地复用原连接</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="各种ip协议"><a href="#各种ip协议" class="headerlink" title="各种ip协议"></a>各种ip协议</h2><h3 id="DNS-域名解析"><a href="#DNS-域名解析" class="headerlink" title="DNS 域名解析"></a>DNS 域名解析</h3><p>DNS服务器：用来将域名地址转化为实际ip地址</p>
<p>在查询dns服务器之前，为先看浏览器的缓存，操作系统的缓存，本地文件中的hosts文件，如果这些都没有才会去访问本地的DNS服务器。</p>
<p>DNS服务器工作流程：以<a href="http://www.baidu.com为例/">www.baidu.com为例</a></p>
<p>客户端首先会给本地 DNS 服务器发出一个 DNS 请求，查询 <a href="http://www.baidu.com/">www.baidu.com</a> 的 IP</p>
<p>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 <a href="http://www.baidu.com,则它直接返回/">www.baidu.com，则它直接返回</a> IP 地址。如果没有，本地 DNS 会去问它的根域名服务器</p>
<p>1.访问根域名服务器，获得.com域名服务器地址</p>
<p>2.访问.com域名服务器地址，获得baidu.com域名服务器地址</p>
<p>3.最后访问baidu.com域名服务器地址，获得ip地址。</p>
<h3 id="ARP-与-RARP-协议"><a href="#ARP-与-RARP-协议" class="headerlink" title="ARP 与 RARP 协议"></a>ARP 与 RARP 协议</h3><p>从主机发送一个ip数据报到目的主机的传输过程可以分为两种，直接交付和间接交付。</p>
<p>间接交付：指下一跳ip地址为路由器地址。直接交付：指下一跳ip地址为主机地址。</p>
<p>如果是间接交付，那么主机或路由器可以通过路由表查到下一跳ip地址；如果是直接交付，那么路由器中的路由表中是没有下一跳的地址，因为ip数据报的目的地址就是该网络的某个主机。</p>
<p>主机—–路由器—–路由器—–路由器—–主机。</p>
<p>ARP协议：根据ip地址查询mac地址。</p>
<p>主机或路由器会广播发送 ARP 请求，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。</p>
<p>如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致，那么这个设备就将自己的 MAC 地址塞入 ARP 响应包返回给主机。</p>
<h3 id="DHCP-动态获取-IP-地址"><a href="#DHCP-动态获取-IP-地址" class="headerlink" title="DHCP 动态获取 IP 地址"></a>DHCP 动态获取 IP 地址</h3><p>DHCP 服务器以实现统一分配和管理IP地址。</p>
<h3 id="NAT-网络地址转换"><a href="#NAT-网络地址转换" class="headerlink" title="NAT 网络地址转换"></a>NAT 网络地址转换</h3><h3 id="ICMP-互联网控制报文协议"><a href="#ICMP-互联网控制报文协议" class="headerlink" title="ICMP 互联网控制报文协议*"></a>ICMP 互联网控制报文协议*</h3><p>ping 命令就是使用ICMP协议。</p>
<h3 id="IGMP-因特网组管理协议"><a href="#IGMP-因特网组管理协议" class="headerlink" title="IGMP 因特网组管理协议*"></a>IGMP 因特网组管理协议*</h3><h3 id="ping-127-0-0-1和本机地址和localhost和0-0-0-0有区别吗？"><a href="#ping-127-0-0-1和本机地址和localhost和0-0-0-0有区别吗？" class="headerlink" title="ping 127.0.0.1和本机地址和localhost和0.0.0.0有区别吗？"></a>ping 127.0.0.1和本机地址和localhost和0.0.0.0有区别吗？</h3><p>断网时：</p>
<h5 id="ping-127-0-0-1和本机地址和localhost是可以ping的通的，可以认为是一个东西"><a href="#ping-127-0-0-1和本机地址和localhost是可以ping的通的，可以认为是一个东西" class="headerlink" title="ping 127.0.0.1和本机地址和localhost是可以ping的通的，可以认为是一个东西"></a>ping 127.0.0.1和本机地址和localhost是可以ping的通的，可以认为是一个东西</h5><p>localhost不叫ip，他是一个域名，相当于baidu.com，系统默认解析为127.0.0.1</p>
<p>以上三个地址在使用ping命令时，都是通过本地网卡发出去的，本地网卡不会把数据发出去，而是顺着数据链路层，网络层等传回给本机。ping 回环地址和通过TCP等各种协议发送数据到回环地址都是走这条路径。</p>
<h5 id="ping-0-0-0-0是不可以ping通的，因为它在IPV4中表示的是无效的目标地址。"><a href="#ping-0-0-0-0是不可以ping通的，因为它在IPV4中表示的是无效的目标地址。" class="headerlink" title="ping 0.0.0.0是不可以ping通的，因为它在IPV4中表示的是无效的目标地址。"></a>ping 0.0.0.0是不可以ping通的，因为它在<code>IPV4</code>中表示的是无效的目标地址。</h5><p>0.0.0.0一般作为监听地址使用，表示本机上的所有IPV4地址，包括127.0.0.1和本机地址。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-07-04-数据库(MySQL)</title>
    <url>/posts/71e8.html</url>
    <content><![CDATA[<h2 id="SQL语句的执行流程"><a href="#SQL语句的执行流程" class="headerlink" title="SQL语句的执行流程"></a>SQL语句的执行流程</h2><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230403143442502.png" alt="image-20230403143442502" style="zoom:80%;" />

<p>查询语句的执行流程如下：权限校验（如果命中缓存）—&gt;查询缓存—&gt;分析器—&gt;优化器—-&gt;执行器—&gt;引擎</p>
<p>更新语句执行流程如下：权限校验—-&gt;分析器—&gt;优化器—-&gt;执行器—&gt;引擎—redo log(prepare 状态)—&gt;binlog—&gt;redo log(commit状态)</p>
<p>分析器：对sql语句进行词法分析和语法分析，分析 SQL 语句是来干嘛的</p>
<p>优化器：主要对sql语句的执行方式进行优化，比如如何选择索引，多表查询选哪个作为内嵌表。经历优化器后具体的执行计划就确定下来了。</p>
<p>执行器：根据执行计划调用引擎的接口，返回接口执行的结果</p>
<p>注：执行器负责控制语句的执行流程和计算工作，对应日志为binlog；储存引擎负责数据的储存和读取，对应日志为redo log。查询语句不会写入日志文件。</p>
 <span id="more"></span>

<p>完整版（日志+磁盘）：UPDATE t_user SET name &#x3D; ‘xiaolin’ WHERE id &#x3D; 1;</p>
<ol>
<li><strong>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id &#x3D; 1 这一行记录</strong>：<ul>
<li>如果 id&#x3D;1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；</li>
<li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。</li>
</ul>
</li>
<li><strong>执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样</strong>：<ul>
<li>如果一样的话就不进行后续更新流程；</li>
<li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；</li>
</ul>
</li>
<li><strong>InnoDB 开启事务， 在更新记录前</strong>，需要记录相应的 <strong>undo log</strong>，对于更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，然后Undo 页面的修改，又会记录在 redo log中。</li>
<li><strong>InnoDB 层开始更新记录</strong>，会先更新buffer pool中的数据页（同时标记为脏页），然后将更新记录写到 <strong>redo log</strong> 里面，这个时候更新就算完成了。为了减少磁盘I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。</li>
<li><strong>通过WAL 技术</strong>，一条记录更新完了。</li>
<li><strong>在一条更新语句执行完成后</strong>，然后开始记录该语句对应的 binlog，此时记录的 <strong>binlog</strong> 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。</li>
<li><strong>事务提交</strong>，使用两阶段提交的方式写入binlog文件。</li>
<li>prepare 阶段</li>
<li>commit 阶段</li>
</ol>
<h2 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h2><p>CHAR 和 VARCHAR 是最常用到的字符串类型，两者的主要区别在于：CHAR 是定长字符串，VARCHAR 是变长字符串。</p>
<p>虽说 VARCHAR(100)和 VARCHAR(10)能存储的字符范围不同，但二者存储相同的字符串，所占用磁盘的存储空间其实是一样的，这也是很多人容易误解的一点。</p>
<p>不过，VARCHAR(100) 会消耗更多的内存。这是因为 VARCHAR 类型在内存中操作时，通常会分配固定大小的内存块来保存值，即使用字符类型中定义的长度。</p>
<p>DECIMAL 和 FLOAT 的区别是：DECIMAL 是定点数，FLOAT&#x2F;DOUBLE 是浮点数。DECIMAL 可以存储精确的小数值，FLOAT&#x2F;DOUBLE 只能存储近似的小数值。</p>
<p>DATETIME类型没有时区信息，TIMESTAMP和时区有关。<br>TIMESTAMP只需要使用4个字节的存储空间，但是DATETIME需要耗费8个字节的存储空间。但是，这样同样造成了一个问题，Timestamp表示的时间范围更小。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20231113215759928.png" alt="image-20231113215759928" style="zoom:80%;" />

<p>由于 TIMESTAMP 需要根据时区进行转换，所以从毫秒数转换到 TIMESTAMP 时，不仅要调用一个简单的函数，还要调用操作系统底层的系统函数。</p>
<p>数值时间戳，使用 int 或者 bigint 类型的数值也就是数值时间戳来表示时间。优点，进行日期排序以及对比等操作的效率会更高，占用内存小；缺点，就是数据的可读性太差了，你无法直观的看到具体时间。</p>
<p>《高性能 MySQL 》这本神书的作者就是推荐 Timestamp，原因是数值表示时间不够直观。</p>
<p>NULL 和 ‘’ 的区别</p>
<p><code>NULL</code> 更多的代表一个不确定的值</p>
<ul>
<li><code>&#39;&#39;</code>的长度是 0，是不占用空间的，而<code>NULL</code> 是需要占用空间的。</li>
<li><code>NULL</code> 会影响聚合函数的结果。例如，<code>SUM</code>、<code>AVG</code>、<code>MIN</code>、<code>MAX</code> 等聚合函数会忽略 <code>NULL</code> 值。 <code>COUNT</code> 的处理方式取决于参数的类型。如果参数是 <code>*</code>(<code>COUNT(*)</code>)，则会统计所有的记录数，包括 <code>NULL</code> 值；如果参数是某个字段名(<code>COUNT(列名)</code>)，则会忽略 <code>NULL</code> 值，只统计非空值的个数。</li>
<li>查询 <code>NULL</code> 值时，必须使用 <code>IS NULL</code> 或 <code>IS NOT NULLl</code> 来判断，而不能使用 &#x3D;、!&#x3D;、 &lt;、&gt; 之类的比较运算符。而<code>&#39;&#39;</code>是可以使用这些比较运算符的。</li>
</ul>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="小林coding"><a href="#小林coding" class="headerlink" title="小林coding"></a>小林coding</h3><h3 id="Buffer-pool"><a href="#Buffer-pool" class="headerlink" title="Buffer pool"></a>Buffer pool</h3><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p>提高数据库的读写性能。</p>
<p>读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</p>
<p>写数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页该页的内存数据和磁盘上的数据已经不一致），为了减少磁盘I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。</p>
<h4 id="储存内容："><a href="#储存内容：" class="headerlink" title="储存内容："></a>储存内容：</h4><p>在 MySQL 启动的时候，<strong>InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的<code>16KB</code>的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页</strong>。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。</p>
<p> Buffer Pool主要储存数据页，B+树中的每个结点都是一个数据页当我们查询一条记录时，InnoDB 是会把<strong>整个页的数据</strong>加载到 Buffer Pool 中，将页加载到 Buffer Pool 后，再通过页里的「页目录」去定位到某条具体的记录。</p>
<p>Buffer Pool 除了缓存<strong>「数据页」</strong>，还包括了 <strong>Undo 页</strong>，插入缓存、自适应哈希索引、锁信息等等。</p>
<h4 id="刷盘："><a href="#刷盘：" class="headerlink" title="刷盘："></a>刷盘：</h4><p>WAL （Write-Ahead Logging）技术，MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上。</p>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="MySQL程序崩溃和系统宕机是有区别的"><a href="#MySQL程序崩溃和系统宕机是有区别的" class="headerlink" title="MySQL程序崩溃和系统宕机是有区别的"></a>MySQL程序崩溃和系统宕机是有区别的</h4><p>MySQL的redo log和bin log在刷盘时都会先写入文件系统的page cache中，如果只是MySQL程序崩溃，那么已经写入page cache仍然可以刷盘，如果是系统宕机，那么缓存中的数据就没有了。</p>
<h4 id="关于MySQL服务器宕机时如何恢复数据问题"><a href="#关于MySQL服务器宕机时如何恢复数据问题" class="headerlink" title="关于MySQL服务器宕机时如何恢复数据问题"></a>关于MySQL服务器宕机时如何恢复数据问题</h4><h5 id="为什么不能使用bin-log做-crash-safe-崩溃恢复"><a href="#为什么不能使用bin-log做-crash-safe-崩溃恢复" class="headerlink" title="为什么不能使用bin log做(crash-safe)崩溃恢复"></a>为什么不能使用bin log做(crash-safe)崩溃恢复</h5><p>bin log是归档日志，它会通过追加的形式记录数据库创建以来的每一条更新操作，可以用于重新创建一个一模一样的数据库。但是bin log不能用于crash-safe，因为bin log并不知道发生宕机时，哪些数据页已经刷盘哪些没有刷盘；redo log日志是固定大小，并且采用循环写入的方式， 用 write pos 表示 redo log 当前记录写到的位置，用 checkpoint 表示当前要擦除的位置，当数据页刷盘时对应的checkpoint就会移动，也就是说redo log储存的就是未刷盘的数据页状态。所以使用redo log进行崩溃恢复。</p>
<h5 id="主要涉及两个事务日志，redo-log和undo-log"><a href="#主要涉及两个事务日志，redo-log和undo-log" class="headerlink" title="主要涉及两个事务日志，redo log和undo log"></a>主要涉及两个事务日志，redo log和undo log</h5><p>redo恢复提交完成的事务：</p>
<p>由于Buffer pool的存在，事务提交时数据不会直接刷新到磁盘上，而是记录在redo log中，在事务提交时或者后台每秒将redo log刷新到磁盘上，因此在服务器宕机时，通过redo log可以恢复未来得及刷入磁盘的数据页到内存中。   </p>
<p>undo回滚未提交的事务：</p>
<p>当服务器在事务执行过程中宕机时，redo log也会将未提交的事务保存下来，并且将undo log的记录也保存下来。宕机说明前面的事务失败了，为了保持事务的一致性和原子性，redo log恢复内存后，需要通过undo log进行事务回滚，恢复到上一次提交事务的状态。</p>
<p>redo log如何区分未提交数据和提交数据，处于prepare阶段的属于未提交数据，处于commit阶段的属于已提交数据</p>
<p>总的来说，服务器宕机时恢复数据都会恢复到最近一次提交事务的状态。</p>
<h4 id="redo-log和undo-log的区别（简略版）"><a href="#redo-log和undo-log的区别（简略版）" class="headerlink" title="redo log和undo log的区别（简略版）"></a>redo log和undo log的区别（简略版）</h4><p>redo log和undo log是MySQl中的事务日志，redo log保证事务的持久性，undo log保证事务的一致性和原子性。</p>
<p>事务的隔离性是通过锁实现的。</p>
<ul>
<li><strong>作用上</strong>：redo log主要是用于<strong>重做</strong>那些已提交的事务，但还未刷新到磁盘的数据；undo log是回滚，主要是回滚未提交的事务数据。</li>
<li><strong>内容上</strong>：redo log是<strong>物理</strong>日志；undo log是逻辑日志。redo log存储的是<strong>更新后</strong>的数据，undo log储存的是旧的数据</li>
<li><strong>储存上</strong>：undo log储存在<strong>buffer pool</strong>中相当于一个数据页，因此undo log的<strong>刷盘时机</strong>和数据页的一致，undo log上的修改也会记录在redo log中，所以可以通过redo log恢复undo log；redo log储存在<strong>redo log buffer</strong>中，后台程序每隔一秒就将redo log进行刷盘，也就是说，一个没有提交的事务的 redo log，也是可能已经持久化到磁盘的。</li>
</ul>
<h4 id="bin-log和redo-log的区别"><a href="#bin-log和redo-log的区别" class="headerlink" title="bin log和redo log的区别"></a>bin log和redo log的区别</h4><ul>
<li>作用不同：redo log用于crash恢复，保证MySQL宕机不丢失数据；bin-log用于用于数据恢复或者主备同步</li>
<li>内容不同：redo log是物理日志，记录的是数据页修改逻辑，bin-log内容可能是基于SQL语句或者是数据本身或者是两者的混合。</li>
<li>不同级别：redo log只能和InnoDB引擎一起使用，而bin-log位于MySQL服务器级别，可用于所有引擎。</li>
<li>磁盘存储形式不同：redo log循环写入，固定大小的；bin-log是累积追加的</li>
<li>写入的时间不同：bin-log通常在一个事务提交时写入，而redo log会在不同的时间点写入，如每次事务提交时，通过另一个线程事务执行，或在刷盘时写入。（注意：未提交的事务redo log也可能被刷新到磁盘）</li>
</ul>
<h3 id="undo-log："><a href="#undo-log：" class="headerlink" title="undo log："></a>undo log：</h3><p>undo log（回滚日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的原子性和一致性，主要用于事务回滚和 MVCC。</p>
<h4 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a><strong>作用：</strong></h4><p>实现事务回滚，保障事务的原子性。实现 MVCC（多版本并发控制）。</p>
<h4 id="事务的原子性和一致性"><a href="#事务的原子性和一致性" class="headerlink" title="事务的原子性和一致性"></a>事务的原子性和一致性</h4><p>事务的原子性是通过 undo log 实现的。undo log 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。除此之外，当服务器在事务执行过程中宕机时，通过redo log崩溃恢复后，需要undo log回滚事务。</p>
<p>在发生回滚时，就读取 undo log 里的数据，然后做原先相反操作。比如当 delete 一条记录时，undo log 中会把记录中的内容都记下来，然后执行回滚操作的时候，就读取 undo log 里的数据，然后进行 insert 操作。</p>
<h4 id="储存内容"><a href="#储存内容" class="headerlink" title="储存内容"></a>储存内容</h4><p>undo log储存的是旧数据，利用记录中的roll_point隐藏列将这些旧数据会形成一个版本链。</p>
<p>undo log包含两种形式的记录，一种insert undo log，另一种是update undo log（详见MVCC）</p>
<p>每次在事务执行过程中，都记录下回滚时需要的信息到一个日志里，当事务提交之后，undo log并不能立马被删除，而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。</p>
<h4 id="刷盘"><a href="#刷盘" class="headerlink" title="刷盘"></a>刷盘</h4><p>undo log 和数据页的刷盘策略是一样的</p>
<ul>
<li>写入redo log：当一个事务提交时，InnoDB会将该事务所产生的undo log先写入redo log中。</li>
<li>刷盘到磁盘：在适当的时机MySQL执行flush操作时，会将内存中的脏页（包括undo log）刷盘到磁盘中</li>
</ul>
<p>buffer pool 中有 undo 页，对 undo 页的修改也都会记录到 redo log。redo log 会每秒刷盘，提交事务时也会刷盘，数据页和 undo 页都是靠这个机制保证持久化的。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>redo log（重做日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的持久性，主要用于掉电等故障恢复；</p>
<h4 id="作用：-2"><a href="#作用：-2" class="headerlink" title="作用："></a>作用：</h4><ul>
<li><p>实现事务的持久性，让 MySQL 有 crash-safe 的能力：</p>
<p>InnoDB使用Buffer pool缓存页，数据都是在缓存页中更新的，如果服务器突然宕机，那么缓存中的数据就会丢失。因此，InnoDB使用了WAL进行持久化，先把更新写入日志中，然后在合适的时间写到磁盘上，而redo log在事务提交时会进行刷盘，能够保证崩溃重启后已提交的记录都不会丢失；</p>
</li>
<li><p>将写操作从「随机写」变成了「顺序写」，降低了IO成本</p>
<p>InnoDB的记录储存结构是B+树，如果每次更新数据都要写入磁盘，都先要在磁盘中找到记录的位置才能写入；而redo log的刷盘就轻松的多，因为直接在文件后面追加内容即可。</p>
</li>
</ul>
<h4 id="储存内容：-1"><a href="#储存内容：-1" class="headerlink" title="储存内容："></a>储存内容：</h4><ul>
<li>redo log 是物理日志，redo日志记录不是某个sql语句，而是记录内存中的某个页面的某个偏移量处修改了几个字节的值，具体被修改的内容是啥，插入和删除会导致整个树的结构发生改变，所有页面的修改都得保存到<code>redo</code>日志中</li>
<li>redo日志会记录未刷盘的所有数据页的修改信息，删除已经已经刷盘的数据页的修改信息。</li>
</ul>
<h4 id="刷盘时机："><a href="#刷盘时机：" class="headerlink" title="刷盘时机："></a>刷盘时机：</h4><p>这里的刷盘是指redo log 从redo log cache持久化到磁盘上。实际上， 执行一个事务的过程中，产生的 redo log 也不是直接写入磁盘的，因为这样会产生大量的 I&#x2F;O 操作，所以，每当产生一条 redo log 时，会先写入到 redo log buffer，后续在持久化到磁盘。</p>
<ul>
<li>MySQL 正常关闭时；</li>
<li>当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；</li>
<li>InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。</li>
<li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略可由 innodb_flush_log_at_trx_commit 参数控制</li>
</ul>
<p>innodb_flush_log_at_trx_commit参数：</p>
<ul>
<li>当设置该参数为 0 时，表示每次事务提交时 ，还是将 redo log 留在 redo log buffer 中 ，该模式下在事务提交时不会主动触发写入磁盘的操作。</li>
<li>当设置该参数为 1 时，表示每次事务提交时，都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘，这样可以保证 MySQL 异常重启之后数据不会丢失。</li>
<li>当设置该参数为 2 时，表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log 写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘，因为操作系统的文件系统中有个 Page Cache，Page Cache 是专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存。</li>
</ul>
<p>针对参数0，2，redo log的刷盘时机依靠后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。</p>
<ul>
<li>针对参数 0 ：会把缓存在 redo log buffer 中的 redo log ，通过调用 <code>write()</code> 写到操作系统的 Page Cache，然后调用 <code>fsync()</code> 持久化到磁盘。所以参数为 0 的策略，MySQL 进程的崩溃会导致上一秒钟所有事务数据的丢失;</li>
<li>针对参数 2 ：调用 fsync，将缓存在操作系统中 Page Cache 里的 redo log 持久化到磁盘。所以参数为 2 的策略，较取值为 0 情况下更安全，因为 MySQL 进程的崩溃并不会丢失数据，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失。</li>
</ul>
<h4 id="刷盘方式："><a href="#刷盘方式：" class="headerlink" title="刷盘方式："></a>刷盘方式：</h4><ul>
<li>redo log 文件是循环写，是会边写边擦除日志的， 用 write pos 表示 redo log 当前记录写到的位置，写入那些脏页数据；用 checkpoint 表示当前要擦除的位置，擦除那些已经持久化的数据页。</li>
<li>InnoDB 的 redo log 是固定大小的，默认情况下， InnoDB 存储引擎有 1 个重做日志文件组( redo log Group），「重做日志文件组」由有 2 个 redo log 文件组成，每个文件 的大小是 1GB，那么这块总共就可以记录 2GB 的操作。</li>
</ul>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230315162401783.png" alt="image-20230315162401783" style="zoom: 50%;" />



<h3 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h3><h4 id="作用：-3"><a href="#作用：-3" class="headerlink" title="作用："></a>作用：</h4><p>binlog （归档日志）：是 Server 层生成的日志，主要用于数据备份和主从复制；</p>
<h4 id="储存内容-1"><a href="#储存内容-1" class="headerlink" title="储存内容"></a>储存内容</h4><p>bin log是逻辑日志，记录了所有数据库表结构变更和表数据修改的日志，文件格式分为3种</p>
<ul>
<li>STATEMENT(逻辑日志)：记录的内容是<code>SQL</code>语句原文，但是有个问题，使用动态函数会导致数据不一致。例如，函数now()会获取当前系统时间，直接执行会导致与原库的数据不一致。</li>
<li>ROW：记录的内容是具体数据，例如使用函数now()就会记录当前的具体时间。使用row格式会比statement格式占用更多的内存。</li>
<li>MIXED：两者的混合，<code>MySQL</code>会判断这条<code>SQL</code>语句是否可能引起数据不一致，如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式。</li>
</ul>
<h4 id="刷盘时机：-1"><a href="#刷盘时机：-1" class="headerlink" title="刷盘时机："></a>刷盘时机：</h4><p>注：数据从binlog cache写入page cache不涉及磁盘 I&#x2F;O速度还是比较快的，fsync才是将数据持久化到磁盘的操作，所以频繁的 fsync 会导致磁盘的 I&#x2F;O 升高。</p>
<p><strong>事务执行过程</strong>中，先把日志写到 binlog cache（Server 层的 cache），<strong>事务提交</strong>的时候，再把 binlog cache 写到 binlog 文件中。这里的写到 binlog 文件并没有把数据持久化到磁盘中，而是写在了内核中的page cache，然后通过调用fsync函数，才是真正持久化到磁盘上。</p>
<p>MySQL提供一个 sync_binlog 参数来控制数据库的 binlog 刷到磁盘上的频率：</p>
<ul>
<li>sync_binlog &#x3D; 0 的时候，表示每次提交事务都只 write，不 fsync，后续交由操作系统决定何时将数据持久化到磁盘；</li>
<li>sync_binlog &#x3D; 1 的时候，表示每次提交事务都会 write，然后马上执行 fsync；</li>
<li>sync_binlog &#x3D;N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</li>
</ul>
<h4 id="刷盘方式：-1"><a href="#刷盘方式：-1" class="headerlink" title="刷盘方式："></a>刷盘方式：</h4><p>binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。</p>
<h4 id="主从复制是怎么实现"><a href="#主从复制是怎么实现" class="headerlink" title="主从复制是怎么实现"></a>主从复制是怎么实现</h4><p>MySQL 的主从复制依赖于 binlog ， binlog 中的数据从主库传输到从库上，从库根据binlog 中的数据更新数据。</p>
<p>具体可以分成3个步骤：</p>
<ul>
<li>写入binlog：主库提交事务，将数据更新写入 binlog 日志</li>
<li>获取binlog：从库会创建一个专门的 I&#x2F;O 线程读取主库的 binlog 日志，再把 binlog 信息写入 relay log 的中继日志里</li>
<li>回放binlog：从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。</li>
</ul>
<p>这个过程一般是异步的，也就是主库上执行事务操作的线程不会等待复制 binlog 的线程同步完成。</p>
<h5 id="主从复制的好处："><a href="#主从复制的好处：" class="headerlink" title="主从复制的好处："></a>主从复制的好处：</h5><p>一般来说，使用主库进行写操作，使用从库进行读操作实现读写分离</p>
<ul>
<li>可以分担数据库的请求，提高数据库的性能</li>
<li>写请求在锁表或者锁记录时，不会影响读请求的执行。</li>
</ul>
<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><h4 id="作用：-4"><a href="#作用：-4" class="headerlink" title="作用："></a>作用：</h4><p>保持redo log和bin log一致性；决定Mysql异常重启后是提交事务还是回滚事务</p>
<h4 id="没有两阶段提交的情况会发生什么？"><a href="#没有两阶段提交的情况会发生什么？" class="headerlink" title="没有两阶段提交的情况会发生什么？"></a>没有两阶段提交的情况会发生什么？</h4><p>第一种情况：记录写在redo日志中，binlog还没写完。redolog会在系统奔溃后，把原来的数据提交，但是binlog并没有相关的记录，导致binlog和数据库中的数据不一致，那么当使用binlog备份数据库时就会少一条记录。</p>
<p>第二种情况：记录写在binlog日志中，relog还没写完。redolog在系统奔溃后，并没有这个事务，该事务就当提交失败处理，但是binlog中有该记录，那么当使用binlog备份数据库时就会多一条记录。</p>
<h4 id="为什么使用两阶段提交就可以避免不一致？两阶段提交的流程。"><a href="#为什么使用两阶段提交就可以避免不一致？两阶段提交的流程。" class="headerlink" title="为什么使用两阶段提交就可以避免不一致？两阶段提交的流程。"></a>为什么使用两阶段提交就可以避免不一致？两阶段提交的流程。</h4><p>两阶段提交指redo log在提交过程分成两个阶段，就是将redo log 的写入拆成了两个步骤：prepare 和 commit，中间再穿插写入binlog。而且需要保证这三个操作的原子性。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230331214637741.png" alt="image-20230331214637741" style="zoom: 67%;" />



<p>对应第一种情况：<code>MySQL</code>根据<code>redo log</code>日志恢复数据时，发现<code>redo log</code>还处于<code>prepare</code>阶段，并且没有对应<code>binlog</code>日志，就会回滚事务</p>
<p>对应第二种情况：写入binlog，但是redolog处于<code>prepare</code>阶段，<code>MySQL</code>认为是完整的所以会自动提交事务，不会回滚事务。</p>
<p>注：两阶段提交是针对bin log的提交，因为redo log每隔一秒就会提交。</p>
<h4 id="两阶段提交的缺点"><a href="#两阶段提交的缺点" class="headerlink" title="两阶段提交的缺点"></a>两阶段提交的缺点</h4><ul>
<li><strong>磁盘 I&#x2F;O 次数高</strong>：对于“双1”配置，每个事务提交都会进行两次 fsync（刷盘），一次是 redo log 刷盘，另一次是 binlog 刷盘。</li>
<li><strong>锁竞争激烈</strong>：为了避免多事务下产生的并发问题，两阶段提交的过程需要加锁来保证提交的原子性，在一个事务获取到锁时才能进入 prepare 阶段，一直到 commit 阶段结束才能释放锁，下个事务才可以继续进行 prepare 操作，</li>
</ul>
<h3 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h3><h4 id="MySQL-磁盘-I-O-很高，有什么优化的方法？"><a href="#MySQL-磁盘-I-O-很高，有什么优化的方法？" class="headerlink" title="MySQL 磁盘 I&#x2F;O 很高，有什么优化的方法？"></a>MySQL 磁盘 I&#x2F;O 很高，有什么优化的方法？</h4><p>将 sync_binlog 设置为大于 1 的值,将 innodb_flush_log_at_trx_commit 设置为 2</p>
<h4 id="slow-query-log（慢查询日志）"><a href="#slow-query-log（慢查询日志）" class="headerlink" title="slow query log（慢查询日志）"></a>slow query log（慢查询日志）</h4><p>​	慢查询日志有什么用？</p>
<p>​	如何查询当前慢查询语句的个数？</p>
<h4 id="binlog（归档日志）"><a href="#binlog（归档日志）" class="headerlink" title="binlog（归档日志）"></a>binlog（归档日志）</h4><p>​	什么情况下会重新生成 binlog？<br>​		停止或重启<br>​		flush logs命令<br>​		超过阈值</p>
<p>​		</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>参考“mysql是怎样运行的”，“java guide”，”45讲基础“</p>
<h3 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h3><p>优点：加快数据的检索速度</p>
<p>缺点：时间上，创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。空间上，索引需要使用物理文件存储，也会耗费一定空间。</p>
<p>大多数情况下，索引查询都是比全表扫描要快的。全表扫描比索引查询慢的情况：</p>
<ul>
<li>表数据不多的情况。</li>
<li>查询结果的记录数量占全部记录数量90%以上</li>
</ul>
<h3 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h3><ul>
<li>hash表：缺点，只能用于等值匹配，不能用于范围匹配</li>
<li>二叉查找树：缺点：相较于B树的N叉特性，二叉的缺点在于树过高，树的高度决定访问磁盘的次数。</li>
<li>B树和B+树的区别：优点：N是 1200时，这棵树高是 4 的时候，就可以存 1200 的 3 次方个值。<ul>
<li>B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key和页号。这意味着B+树每个节点能索引的范围更大，可以减少访问磁盘的次数。</li>
<li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。对于范围匹配和顺序查找很方便</li>
</ul>
</li>
</ul>
<h3 id="InnoDB-的索引模型（B-树）"><a href="#InnoDB-的索引模型（B-树）" class="headerlink" title="InnoDB 的索引模型（B+树）"></a>InnoDB 的索引模型（B+树）</h3><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230317120057206.png" alt="image-20230317120057206" style="zoom:80%;" />

<p>以聚簇索引为例：</p>
<p>MySQL中的索引是类似B+树的结构</p>
<ol>
<li><p>页表内部的结构</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230317121019330.png" alt="image-20230317121019330" style="zoom:80%;" />

<ul>
<li>页中的所有记录串联成一个<code>单链表</code>。</li>
<li>页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个<code>槽</code>，存放在<code>页目录</code>中，页目录可以用于二分查找。</li>
</ul>
</li>
<li><p>页表外部的结构（B+树）</p>
<ul>
<li>页表的外部是一个B+树的结构。每个结点都是一个数据页，非叶子结点称为目录项记录，叶子节点称为用户记录。目录项记录存储索引列的值和页号指针；用户记录储存完整的记录。</li>
<li>同一层中，数据页中索引列必须是递增的。上下层中，数据页的索引列是子数据页的开始索引值。</li>
<li>同一层次中的页根据页中目录项记录的主键大小顺序排成一个双向链表。双向链表的目的：一是支持全表扫描的方式，二是范围查找时更加高效，找到最小值后直接遍历链表即可。</li>
</ul>
</li>
</ol>
<h5 id="查找过程："><a href="#查找过程：" class="headerlink" title="查找过程："></a>查找过程：</h5><p>以查找主键为<code>20</code>的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p>
<ol>
<li>想通过根目录找到30页(二分)，然后到存储<code>目录项记录</code>的页，也就是页<code>30</code>中通过二分法快速定位到对应目录项，因为<code>12 &lt; 20 &lt; 209</code>，所以定位到对应的记录所在的页就是<code>页9</code>。</li>
<li>再到存储用户记录的<code>页9</code>中根据二分法快速定位到主键值为<code>20</code>的用户记录。</li>
</ol>
<h5 id="插入过程："><a href="#插入过程：" class="headerlink" title="插入过程："></a>插入过程：</h5><ul>
<li>根据 B+ 树的算法，在页中间插入数据，需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。</li>
<li>所以id一般都是自增的。索引自增模式下，每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</li>
</ul>
<h5 id="删除过程："><a href="#删除过程：" class="headerlink" title="删除过程："></a>删除过程：</h5><ul>
<li>会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</li>
</ul>
<h4 id="InnoDB的B-树索引的注意事项"><a href="#InnoDB的B-树索引的注意事项" class="headerlink" title="InnoDB的B+树索引的注意事项"></a>InnoDB的B+树索引的注意事项</h4><ul>
<li>根页面万年不动窝：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的<code>根节点</code>的页号便会被记录到某个地方，然后凡是<code>InnoDB</code>存储引擎需要用到这个索引的时候，都会从那个固定的地方取出<code>根节点</code>的页号，从而来访问这个索引。</li>
<li>内节点中目录项记录的唯一性：上面提到目录项记录存储索引列和子页号，但是如果索引列不是唯一值，那么目录项会带上主键值。即，索引列的值+主键值+页号</li>
</ul>
<h4 id="MyISAM中的索引方案简单介绍"><a href="#MyISAM中的索引方案简单介绍" class="headerlink" title="MyISAM中的索引方案简单介绍"></a>MyISAM中的索引方案简单介绍</h4><ul>
<li>MyISAM的实际数据跟索引是分开储存的，也就是说MyISAM的索引都是二级索引，都需要进行回表操作</li>
<li>MyISAM的实际数据储存没有刻意按照主键大小排序不能在这些数据上使用二分法进行查找。地址+完整记录</li>
<li>索引的叶子节点中存储的不是完整的用户记录，而是主键值 + 行号（地址）的组合。</li>
</ul>
<h3 id="索引类型总结"><a href="#索引类型总结" class="headerlink" title="索引类型总结"></a>索引类型总结</h3><p>聚簇索引&#x2F;主键索引：</p>
<p>聚簇索引也叫主键索引，它的叶子节点就是表中的完整记录。对于聚簇索引来说，数据即是索引，索引即是数据</p>
<p>在 MySQL 的 InnoDB 的表中，当没有显示的指定表的<strong>主键</strong>时，InnoDB 会自动先检查表中是否有<strong>唯一索引且不允许存在 null 值</strong>的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的<strong>自增主键。</strong></p>
<p>二级索引&#x2F;辅助索引：</p>
<p>唯一索引(Unique Key) ：唯一索引也是一种约束。唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。<br>普通索引(Index) ：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。<br>前缀索引(Prefix)：前缀索引只适用于字符串类型的数据。</p>
<p>聚簇索引和二级索引的区别：缺点：聚簇索引的叶子节点存放着数据，任何列的修改都会导致索引的修改。非聚簇索引可能需要回表操作。</p>
<p>联合索引：使用表中的多个字段创建索引，就是 联合索引，也叫组合索引 或 复合索引。</p>
<p>覆盖索引：如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</p>
<h3 id="B-树索引适用的条件（会用到索引的情况-最左匹配原则）"><a href="#B-树索引适用的条件（会用到索引的情况-最左匹配原则）" class="headerlink" title="B+树索引适用的条件（会用到索引的情况&#x2F;最左匹配原则）"></a>B+树索引适用的条件（会用到索引的情况&#x2F;最左匹配原则）</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person_info(</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> auto_increment,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    birthday <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    phone_number <span class="type">CHAR</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    country <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    KEY idx_name_birthday_phone_number (name, birthday, phone_number)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>注：联合索引的顺序很重要，在上图中，B+树首先会对name进行排序，name相等的用birthday排序，name和birthday相等的用phone_number排序。</p>
<p><strong>全值匹配</strong>：搜索条件中的列和索引列一致的话，这种情况就称为全值匹配。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Ashburn&#x27;</span> <span class="keyword">AND</span> birthday <span class="operator">=</span> <span class="string">&#x27;1990-09-27&#x27;</span> <span class="keyword">AND</span> phone_number <span class="operator">=</span> <span class="string">&#x27;15123983239&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>匹配左边的列</strong>：语句中也可以不用包含全部联合索引中的列，只包含左边的就行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Ashburn&#x27;</span>;#会用到索引</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> birthday <span class="operator">=</span> <span class="string">&#x27;1990-09-27&#x27;</span>;#不会用到索引</span><br></pre></td></tr></table></figure>

<p><strong>匹配列前缀</strong>：跟字符串的排序规则有关，一般默认是字典序。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;As%&#x27;</span>;#会用到索引</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%As%&#x27;</span>;#不会用到索引</span><br></pre></td></tr></table></figure>

<p><strong>匹配范围值</strong>：所有记录都是按照索引列的值从小到大的顺序排好序的</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> name <span class="operator">&gt;</span> <span class="string">&#x27;Asa&#x27;</span> <span class="keyword">AND</span> name <span class="operator">&lt;</span> <span class="string">&#x27;Barlow&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过B+树在叶子节点中找到第一条<code>name</code>值大于<code>Asa</code>的二级索引记录，读取该记录的主键值进行回表操作，获得对应的聚簇索引记录后发送给客户端。</li>
<li>根据上一步找到的记录，沿着记录所在的链表向后查找（同一页面中的记录使用单向链表连接起来，数据页之间用双向链表连接起来）下一条二级索引记录，判断该记录是否符合name &lt; ‘Barlow’条件，如果符合，则进行回表操作后发送至客户端。</li>
<li>重复上一步骤，直到某条二级索引记录不符合name &lt;’Barlow’条件为止。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> name <span class="operator">&gt;</span> <span class="string">&#x27;Asa&#x27;</span> <span class="keyword">AND</span> name <span class="operator">&lt;</span> <span class="string">&#x27;Barlow&#x27;</span> <span class="keyword">AND</span> birthday <span class="operator">&gt;</span> <span class="string">&#x27;1980-01-01&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过条件<code>name &gt; &#39;Asa&#39; AND name &lt; &#39;Barlow&#39; </code>来对<code>name</code>进行范围，查找的结果可能有多条<code>name</code>值不同的记录。在这些记录中birthday可能是乱序的。</li>
<li>对这些<code>name</code>值不同的记录继续通过<code>birthday &gt; &#39;1980-01-01&#39;</code>条件继续过滤。</li>
</ul>
<p><strong>精确匹配某一列并范围匹配另外一列</strong></p>
<p>虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Ashburn&#x27;</span> <span class="keyword">AND</span> birthday <span class="operator">&gt;</span> <span class="string">&#x27;1980-01-01&#x27;</span> <span class="keyword">AND</span> birthday <span class="operator">&lt;</span> <span class="string">&#x27;2000-12-31&#x27;</span> <span class="keyword">AND</span> phone_number <span class="operator">&gt;</span> <span class="string">&#x27;15100000000&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>name = &#39;Ashburn&#39;</code>，对<code>name</code>列进行精确查找，当然可以使用<code>B+</code>树索引了</li>
<li><code>birthday &gt; &#39;1980-01-01&#39; AND birthday &lt; &#39;2000-12-31&#39;</code>，由于<code>name</code>列是精确查找，所以通过<code>name = &#39;Ashburn&#39;</code>条件查找后得到的结果的<code>name</code>值都是相同的，它们会再按照<code>birthday</code>的值进行排序。所以此时对<code>birthday</code>列进行范围查找是可以用到<code>B+</code>树索引的。</li>
<li><code>phone_number &gt; &#39;15100000000&#39;</code>，通过<code>birthday</code>的范围查找的记录的<code>birthday</code>的值可能不同，所以这个条件无法再利用<code>B+</code>树索引了，只能遍历上一步查询得到的记录。</li>
</ul>
<p><strong>用于排序</strong>：<code>ORDER BY</code>的子句后边的列的顺序按照索引列的顺序给出</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> birthday, phone_number LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>不可以使用索引进行排序的几种情况：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">ORDER</span> <span class="keyword">BY</span> name, birthday <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;#<span class="number">1.</span><span class="keyword">ASC</span>、<span class="keyword">DESC</span>混用</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">ORDER</span> <span class="keyword">BY</span> name, country LIMIT <span class="number">10</span>;#<span class="number">2.</span>排序列包含非同一个索引的列</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">UPPER</span>(name) LIMIT <span class="number">10</span>;#<span class="number">3.</span>排序列使用了复杂的表达式</span><br></pre></td></tr></table></figure>

<p><strong>用于分组</strong>：分组列的顺序也需要和索引列的顺序一致，也可以只使用索引列中左边的列进行分组</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, birthday, phone_number, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> person_info <span class="keyword">GROUP</span> <span class="keyword">BY</span> name, birthday, phone_number</span><br></pre></td></tr></table></figure>

<ol>
<li>先把记录按照<code>name</code>值进行分组，所有<code>name</code>值相同的记录划分为一组。</li>
<li>将每个<code>name</code>值相同的分组里的记录再按照<code>birthday</code>的值进行分组，将<code>birthday</code>值相同的记录放到一个小分组里，所以看起来就像在一个大分组里又化分了好多小分组。</li>
<li>再将上一步中产生的小分组按照<code>phone_number</code>的值分成更小的分组，所以整体上看起来就像是先把记录分成一个大分组，然后把<code>大分组</code>分成若干个<code>小分组</code>，然后把若干个<code>小分组</code>再细分成更多的<code>小小分组</code>。</li>
</ol>
<h3 id="回表的代价"><a href="#回表的代价" class="headerlink" title="回表的代价"></a>回表的代价</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> name <span class="operator">&gt;</span> <span class="string">&#x27;Asa&#x27;</span> <span class="keyword">AND</span> name <span class="operator">&lt;</span> <span class="string">&#x27;Barlow&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>会使用到两个<code>B+</code>树索引，一个二级索引，一个聚簇索引。</li>
<li>访问二级索引使用<code>顺序I/O</code>，访问聚簇索引使用<code>随机I/O</code>，因为聚簇索引是使用id进行排序的。</li>
</ul>
<p>随机IO的性能是不如顺序IO的，所以有些时候可以使用索引的sql语句不一定会使用<code>二级索引 + 回表</code>的方式，而是采用全表扫描的方式。选择用什么方式是查询优化器做的工作，一般来说，需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用<code>二级索引 + 回表</code>的方式。</p>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230317162740710.png" alt="image-20230317162740710" style="zoom:50%;" /><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230317162752729.png" alt="image-20230317162752729" style="zoom:50%;" /></p>
<p>索引下堆：在索引遍历过程中，对二级索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>
<h3 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h3><p>使用 <code>SELECT *</code> 进行查询;</p>
<p>创建了组合索引，但查询条件未遵守最左匹配原则;</p>
<p>在索引列上进行计算、函数、类型转换等操作;<code>WHERE my_col * 2 &lt; 4</code> &#x3D;》<code>WHERE my_col &lt; 4/2</code></p>
<p>以 <code>%</code> 开头的 LIKE 查询比如 <code>like &#39;%abc&#39;</code>;</p>
<p>查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230331171829788.png" alt="image-20230331171829788" style="zoom:80%;" />

<h3 id="如何挑选索引"><a href="#如何挑选索引" class="headerlink" title="如何挑选索引"></a>如何挑选索引</h3><p><strong>只为用于搜索、排序或分组的列创建索引</strong></p>
<p><strong>被频繁查询的字段，不被频繁更新的字段</strong></p>
<p><strong>被经常频繁用于连接的字段</strong></p>
<p><strong>尽可能的考虑建立联合索引而不是单列索引，不要创建冗余和重复索引</strong></p>
<p><strong>选择列的基数大的作为索引</strong></p>
<p><strong>索引列的类型尽量小</strong></p>
<p>索引字符串值的前缀，索引列前缀对排序的影响</p>
<p>让索引列在比较表达式中单独出现：如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的。<code>WHERE my_col * 2 &lt; 4</code> &#x3D;》<code>WHERE my_col &lt; 4/2</code></p>
<p>主键插入顺序，最好让插入的记录的主键值依次递增</p>
<p>不为 NULL 的字段</p>
<p>单张表索引不超过 5 个</p>
<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>MySQL是C&#x2F;S架构的软件，一般多个客户端对应一个服务端，每个客户端发送请求都是一个事务，服务端需要同时处理多个事务，就会造成并发读写问题。由于串行执行事务效率低，所以MySQL设置了4种隔离级别，通过舍弃一部分隔离性来提高性能。</p>
<h3 id="事务并发执行遇到的问题"><a href="#事务并发执行遇到的问题" class="headerlink" title="事务并发执行遇到的问题"></a>事务并发执行遇到的问题</h3><p>脏写（<code>Dirty Write</code>）</p>
<p><strong>一个事务修改了另一个未提交事务修改过的数据</strong></p>
<p>脏读（<code>Dirty Read</code>）</p>
<p><strong>一个事务读到了另一个未提交事务修改过的数据</strong></p>
<p>不可重复读（Non-Repeatable Read）</p>
<p><strong>一个事务只能读到另一个已经提交的事务修改过的数据</strong>，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值</p>
<p>幻读（Phantom）</p>
<p>一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来，那就意味着发生了<code>幻读</code></p>
<p><code>幻读</code>强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录。</p>
<h3 id="MySQL标准中的四种隔离级别"><a href="#MySQL标准中的四种隔离级别" class="headerlink" title="MySQL标准中的四种隔离级别"></a>MySQL标准中的四种隔离级别</h3><p>按照严重性来排一下序：脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</p>
<p>隔离性：设立一些隔离级别，隔离级别越低，越严重的问题就越可能发生。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230317170810237.png" alt="image-20230317170810237" style="zoom:80%;" />

<p>注：<strong>MySQL在REPEATABLE READ隔离级别下，是可以禁止幻读问题的发生的</strong>。但SQL标准中会发生幻读。不论是哪种隔离级别，都不允许脏写的情况发生。</p>
<h2 id="MVCC原理"><a href="#MVCC原理" class="headerlink" title="MVCC原理"></a>MVCC原理</h2><h3 id="版本链（undo日志）"><a href="#版本链（undo日志）" class="headerlink" title="版本链（undo日志）"></a>版本链（undo日志）</h3><p>undo日志的作用：</p>
<ul>
<li><p>当事务回滚时用于将数据恢复到修改前的样子</p>
</li>
<li><p>另一个作用是 <code>MVCC</code> ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 <code>undo log</code> 读取之前的版本数据，以此实现非锁定读</p>
</li>
</ul>
<p>undo日志的种类：</p>
<ul>
<li>**<code>insert undo log</code>**：指在 <code>insert</code> 操作中产生的 <code>undo log</code>。插入记录本身就没有旧记录一说，因此也不存在版本链，故该 <code>undo log</code> 可以在事务提交后直接删除。</li>
<li><strong><code>update undo log</code></strong> ：<code>update</code> 或 <code>delete</code> 操作中产生的 <code>undo log</code>。该 <code>undo log</code>可能需要提供旧值用于 <code>MVCC</code> 机制，因此不能在事务提交时就进行删除。提交时放入 <code>undo log</code> 链表，等待 <code>purge线程</code> 进行最后的删除</li>
</ul>
<p>聚簇索引记录中两个必要的隐藏列，一个非必要的隐藏列ROW_ID</p>
<ul>
<li><p><code>trx_id</code>：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的<code>事务id</code>赋值给<code>trx_id</code>隐藏列。</p>
<p>只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。</p>
</li>
<li><p><code>roll_pointer</code>：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到<code>undo日志</code>中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</p>
</li>
<li><p>ROW_ID：如果没有设置主键且该表没有唯一非空索引时，<code>InnoDB</code> 会使用该 id 来生成聚簇索引</p>
</li>
</ul>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230317184152053.png" alt="image-20230317184152053" style="zoom:80%;" />

<p><strong>根据上面两个数据结构，可以形成一条记录的版本链</strong></p>
<p>上图中的版本链如下：</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230317184250312.png" alt="image-20230317184250312" style="zoom:80%;" />

<p>注：undo日志会记录所有<strong>未提交事务</strong>中记录的变化情况。可以看到我们所说的版本链指的是某一条记录(number)的版本链</p>
<h3 id="四大隔离级别的实现"><a href="#四大隔离级别的实现" class="headerlink" title="四大隔离级别的实现"></a>四大隔离级别的实现</h3><p>READ UNCOMMITTED：直接读取记录的最新版本</p>
<p>SERIALIZABLE：使用加锁的方式来访问记录</p>
<p>READ COMMITTED： 每次读取数据前都生成一个ReadView</p>
<p>REPEATABLE READ ：在第一次读取数据时生成一个ReadView</p>
<h3 id="ReadView（快照读）"><a href="#ReadView（快照读）" class="headerlink" title="ReadView（快照读）"></a>ReadView（快照读）</h3><p>对于使用<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的事务来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是：需要判断一下版本链中的哪个版本是当前事务可见的。</p>
<h5 id="作用：-5"><a href="#作用：-5" class="headerlink" title="作用："></a>作用：</h5><p>所谓的MVCC（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用READ COMMITTD、REPEATABLE READ这两种隔离级别的事务在执行普通的SELECT操作时访问记录的版本链的过程，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。</p>
<p><strong>数据结构</strong>：</p>
<ul>
<li><code>m_ids</code>：表示在生成<code>ReadView</code>时当前系统中<strong>活跃的读写事务</strong>的<code>事务id</code>列表</li>
<li><code>min_trx_id</code>：表示在生成<code>ReadView</code>时当前系统中<strong>活跃的读写事务</strong>中最小的<code>事务id</code>，也就是<code>m_ids</code>中的最小值。</li>
<li><code>max_trx_id</code>：表示生成<code>ReadView</code>时系统中应该分配给下一个事务的<code>id</code>值。</li>
<li><code>creator_trx_id</code>：表示生成该<code>ReadView</code>的事务的<code>事务id</code>。</li>
</ul>
<p>注：max_trx_id并不是m_ids中的最大值，<strong>事务id是递增分配的</strong>。比方说现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，m_ids就包括1和2，min_trx_id的值就是1，max_trx_id的值就是4。只读事务中的事务id值都默认为0</p>
<p>**四个可见性原则(算法)**：</p>
<ul>
<li>前置知识：事务id是递增分配的；trx_id指的是版本链中某个版本的事务id；<code>creator_trx_id</code>一定是属于活跃中的事务中的；因此id比活跃事务id小的事务一定是已经提交的事务；id比max_trx_id大的事务一定是后开启的事务，它一定是创建快照时未提交的事务，因为如果是创建快照时已提交的事务，那么max_trx_id一定会比它大（注意max_trx_id的定义，max_trx_id是变化的）。</li>
<li>以我启动的时刻为准，如果一个数据版本是 在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上 一个版本。如果是这个事务自己更新 的数据，它自己还是要认的</li>
<li><ol>
<li>版本未提交，不可见； 2. 版本已提交，但是是在视图创建后提交的，不可见； 3. 版本已提交，而且是在视图创建前提交的，可见。</li>
</ol>
</li>
</ul>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230317185951251.png" alt="image-20230317185951251" style="zoom:80%;" />

<ul>
<li><p>trx_id &#x3D; creator_trx_id：如果被访问版本的trx_id属性值与ReadView中的creator_trx_id值相同，意味着<strong>当前事务在访问它自己修改过的记录</strong>，所以该版本可以被当前事务访问。</p>
</li>
<li><p>trx_id &lt; min_trx_id：如果被访问版本的trx_id属性值小于ReadView中的min_trx_id值，表明<strong>生成该版本的事务在当前事务生成ReadView前已经提交</strong>，所以该版本可以被当前事务访问。</p>
</li>
<li><p>trx_id &gt;&#x3D; max_trx_id：如果被访问版本的<code>trx_id</code>属性值大于或等于<code>ReadView</code>中的<code>max_trx_id</code>值，表明<strong>生成该版本的事务在当前事务生成<code>ReadView</code>后才开启</strong>，所以该版本不可以被当前事务访问。</p>
</li>
<li><p>min_trx_id &lt;&#x3D; trx_id &lt; max_trx_id：如果被访问版本的<code>trx_id</code>属性值在<code>ReadView</code>的<code>min_trx_id</code>和<code>max_trx_id</code>之间，那就需要判断一下<code>trx_id</code>属性值是不是在<code>m_ids</code>列表中，如果在，说明创建<code>ReadView</code>时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建<code>ReadView</code>时生成该版本的事务已经被提交，该版本可以被访问。</p>
<p>根据这四个可见性原则，遍历该记录的版本链信息，如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的版本可见。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。</p>
</li>
</ul>
<h5 id="READ-COMMITTED-——-每次读取数据前都生成一个ReadView，为了随时可以访问已经提交的数据"><a href="#READ-COMMITTED-——-每次读取数据前都生成一个ReadView，为了随时可以访问已经提交的数据" class="headerlink" title="READ COMMITTED —— 每次读取数据前都生成一个ReadView，为了随时可以访问已经提交的数据"></a>READ COMMITTED —— 每次读取数据前都生成一个ReadView，为了随时可以访问已经提交的数据</h5><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230318102205864.png" alt="image-20230318102205864" style="zoom:80%;" />

<p>候事务 A 查询语句返回的是 k&#x3D;2。事务 B 查询结果 k&#x3D;3。</p>
<h5 id="REPEATABLE-READ-——-在第一次读取数据时生成一个ReadView，之后的查询操作都重复使用这个ReadView"><a href="#REPEATABLE-READ-——-在第一次读取数据时生成一个ReadView，之后的查询操作都重复使用这个ReadView" class="headerlink" title="REPEATABLE READ —— 在第一次读取数据时生成一个ReadView，之后的查询操作都重复使用这个ReadView"></a>REPEATABLE READ —— 在第一次读取数据时生成一个ReadView，之后的查询操作都重复使用这个ReadView</h5><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230318102337644.png" alt="image-20230318102337644" style="zoom:80%;" />

<p>找到 (1,3) 的时候，判断出 row trx_id&#x3D;101，比高水位大，处于红色区域，不可见； 接着，找到上一个历史版本，一看 row trx_id&#x3D;102，比高水位大，处于红色区域，不可 见； 再往前找，终于找到了（1,1)，它的 row trx_id&#x3D;90，比低水位小，处于绿色区域，可 见</p>
<h5 id="一致性读、当前读的区别："><a href="#一致性读、当前读的区别：" class="headerlink" title="一致性读、当前读的区别："></a>一致性读、当前读的区别：</h5><p>一致性读只能适用于select的情况，如果是update读或者是加锁select都是读当前的最新值，这称为”当前读”，当前读也叫加锁读，它会给这行记录加行锁。所以101的值才能是 2 + 1&#x3D; 3。</p>
<p>假设事务C和事务B的提交时间如下，事务 B 的更新语句会怎么处理呢？</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230318103755646.png" alt="image-20230318103755646" style="zoom:80%;" />

<p>“两阶段锁协议”：事务 C’没提交，也就 是说 (1,2) 这个版本上的写锁还没释放。而事务 B 是当前读，必须要读最新版本，而且必须 加锁，因此就被锁住了，必须等到事务 C’释放这个锁，才能继续它的当前读。</p>
<h3 id="MVCC-Next-key-Lock-防止幻读"><a href="#MVCC-Next-key-Lock-防止幻读" class="headerlink" title="MVCC+Next-key-Lock 防止幻读"></a>MVCC+Next-key-Lock 防止幻读</h3><p><code>InnoDB</code>存储引擎在 RR 级别下通过 <code>MVCC</code>和 <code>Next-key Lock</code> 来解决幻读问题：</p>
<p>1.执行一致性读</p>
<p>生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</p>
<p>2.执行select…for update&#x2F;lock in share mode、insert、update、delete 等当前读</p>
<p>当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所谓的MVCC（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用READ COMMITTD、REPEATABLE READ这两种隔离级别的事务在执行普通的SELECT操作时访问记录的版本链的过程，这样子可以使不同事务的读-写、写-读操作并发执行过程中实现读的一致性，从而提升系统性能。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="并发事务的类型"><a href="#并发事务的类型" class="headerlink" title="并发事务的类型"></a>并发事务的类型</h3><p><code>读-读</code>情况：读取操作本身不会对记录有一毛钱影响，并不会引起什么问题，所以允许这种情况的发生。</p>
<p><code>写-写</code>情况：需要使用加锁解决否则会发生脏读，这种情况会发生死锁情况。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/16a680105e955d9atplv-t2oaga2asx-zoom-in-crop-mark3024000.webp" alt="image_1d9jvmt0n5cl4b71ahh1ki4pjner.png-77.1kB" style="zoom:50%;" />

<p><code>读-写</code>或<code>写-读</code>情况：这种情况下可能发生<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>的问题。</p>
<ul>
<li>方案一：读操作利用多版本并发控制（<code>MVCC</code>），写操作进行<code>加锁</code>。</li>
<li>方案二：读、写操作都采用<code>加锁</code>的方式。serializable下的select语句加共享锁</li>
</ul>
<h3 id="解决并发事务的两种基本思路"><a href="#解决并发事务的两种基本思路" class="headerlink" title="解决并发事务的两种基本思路"></a>解决并发事务的两种基本思路</h3><h4 id="一致性读"><a href="#一致性读" class="headerlink" title="一致性读"></a>一致性读</h4><p>事务利用<code>MVCC</code>进行的读取操作称之为<code>一致性读</code>，或者<code>一致性无锁读</code>，有的地方也称之为<code>快照读</code>。</p>
<ul>
<li>所有普通的<code>SELECT</code>语句（<code>plain SELECT</code>）在<code>READ COMMITTED</code>、<code>REPEATABLE READ</code>隔离级别下都算是<code>一致性读</code></li>
</ul>
<h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><p>结论：读操作和写操作都可以加锁。</p>
<h5 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h5><p>共享锁（S 锁） ：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</p>
<p>排他锁（X锁） ：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230318120333556.png" alt="image-20230318120333556" style="zoom: 67%;" />

<h5 id="锁定读-当前读（Locking-Reads）"><a href="#锁定读-当前读（Locking-Reads）" class="headerlink" title="锁定读&#x2F;当前读（Locking Reads）"></a>锁定读&#x2F;当前读（Locking Reads）</h5><ul>
<li>对读取的记录加<code>S锁</code>：SELECT … LOCK IN SHARE MODE*;*</li>
<li>对读取的记录加<code>X锁</code>：SELECT … FOR UPDATE;</li>
</ul>
<h5 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h5><ul>
<li><code>DELETE</code>：相当于获取<code>X锁</code>的<code>锁定读</code>。</li>
<li><code>UPDATE</code>：相当于获取<code>X锁</code>的<code>锁定读</code>。</li>
<li><code>INSERT</code>：采用隐式锁的方式，本质也是X锁</li>
</ul>
<h5 id="多粒度锁（区别）"><a href="#多粒度锁（区别）" class="headerlink" title="多粒度锁（区别）"></a>多粒度锁（区别）</h5><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230403203352670.png" alt="image-20230403203352670" style="zoom:80%;" />

<p>全局锁：全局锁就是对整个数据库实例加锁，整个数据库就处于只读状态了，全局锁的典型使用场景是，做全库逻辑备份。</p>
<p>表锁：表级别的<code>共享锁</code>（<code>S锁</code>）和<code>独占锁</code>（<code>X锁</code>），用于锁住整个表。 是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，<strong>资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低</strong>。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。</p>
<p>行锁：行级别的<code>共享锁</code>（<code>S锁</code>）和<code>独占锁</code>（<code>X锁</code>），用于锁住某一行记录。 MySQL 中锁定粒度最小的一种锁，是 针对索引字段加的锁 ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。<strong>其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁</strong>。行级锁和存储引擎有关，是在存储引擎层面实现的。</p>
<p>注：这里的X,S锁是表锁</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230318121318524.png" alt="image-20230318121318524" style="zoom:80%;" />

<h3 id="MySQL中的行锁和表锁"><a href="#MySQL中的行锁和表锁" class="headerlink" title="MySQL中的行锁和表锁"></a>MySQL中的行锁和表锁</h3><h4 id="其他存储引擎中的锁"><a href="#其他存储引擎中的锁" class="headerlink" title="其他存储引擎中的锁"></a>其他存储引擎中的锁</h4><p>对于<code>MyISAM</code>、<code>MEMORY</code>、<code>MERGE</code>这些存储引擎来说，它们只支持表级锁，而且这些引擎并不支持事务，也不支持一致性读，select语句加S锁，写操作加X锁。</p>
<h4 id="InnoDB存储引擎中的锁（重点）"><a href="#InnoDB存储引擎中的锁（重点）" class="headerlink" title="InnoDB存储引擎中的锁（重点）"></a>InnoDB存储引擎中的锁（重点）</h4><p><code>InnoDB</code>存储引擎既支持表锁，也支持行锁。</p>
<h5 id="InnoDB中的表级锁"><a href="#InnoDB中的表级锁" class="headerlink" title="InnoDB中的表级锁"></a>InnoDB中的表级锁</h5><ul>
<li><p>表级别的<code>S锁</code>、<code>X锁</code>：</p>
<p>一般来说，在对某个表执行<code>SELECT</code>、<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>语句时（走索引），<code>InnoDB</code>存储引擎是不会为这个表添加表级别的<code>S锁</code>或者<code>X锁</code>的。</p>
<ul>
<li><code>LOCK TABLES t READ</code>：<code>InnoDB</code>存储引擎会对表<code>t</code>加表级别的<code>S锁</code>。</li>
<li><code>LOCK TABLES t WRITE</code>：<code>InnoDB</code>存储引擎会对表<code>t</code>加表级别的<code>X锁</code>。</li>
</ul>
</li>
<li><p>元数据锁（metadata lock）：</p>
<p>MDL 不需要显式使用，在访问一个表的时候 会被自动加上。MDL 的作用是，保证读写的正确性。对某个表执行一些诸如<code>ALTER TABLE</code>、<code>DROP TABLE</code>这类的<code>DDL</code>语句时，其他事务对这个表并发执行诸如<code>SELECT</code>、<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>的语句会发生阻塞，同理，某个事务中对某个表执行<code>SELECT</code>、<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>语句时，在其他会话中对这个表执行<code>DDL</code>语句也会发生阻塞。</p>
<p>当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。</p>
<p>事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马 上释放，而会等到整个事务提交后再释放。</p>
</li>
<li><p>意向锁：</p>
<p>当我们在对使用<code>InnoDB</code>存储引擎的表的某些记录加<code>S锁</code>&#x2F;<code>X锁</code>之前，那就需要先在表级别加一个<code>IS锁</code>&#x2F;<code>IX锁</code>。<code>IS锁</code>和<code>IX锁</code>的使命只是为了后续在加表级别的<code>S锁</code>和<code>X锁</code>时判断表中是否有已经被加锁的记录，以避免用遍历的方式来查看表中有没有上锁的记录。</p>
</li>
<li><p><code>AUTO-INC锁</code>：</p>
<p>在执行插入语句时就在表级别加一个<code>AUTO-INC</code>锁，然后为每条待插入记录的<code>AUTO_INCREMENT</code>修饰的列分配递增的值，<strong>在该语句执行结束后，再把<code>AUTO-INC</code>锁释放掉。这样一个事务在持有<code>AUTO-INC</code>锁的过程中，其他事务的插入语句都要被阻塞</strong>，可以保证一个语句中分配的递增值是连续的。</p>
<p>这个AUTO-INC锁的作用范围只是单个插入语句，插入语句执行完成后，这个锁就被释放了，跟我们之前介绍的锁在事务结束时释放是不一样的。</p>
</li>
</ul>
<h5 id="InnoDB中的行级锁"><a href="#InnoDB中的行级锁" class="headerlink" title="InnoDB中的行级锁"></a>InnoDB中的行级锁</h5><p>记录锁(Record Locks)</p>
<ul>
<li>只针对当前操作的行记录进行加锁，分为S锁和X锁。s锁和x锁的相互排斥关系见上。</li>
</ul>
<p>间隙锁(Gap Locks)</p>
<ul>
<li>加在某一行记录上，表示锁住上一行记录和该行记录之间的间隙，阻塞其他事务对这个间隙的插入操作。</li>
<li><code>gap锁</code>的提出仅仅是为了防止插入幻影记录而提出的，虽然有<code>共享gap锁</code>和<code>独占gap锁</code>这样的说法，但是它们起到的作用都是相同的。并不会限制其他事务对这条记录的读，修改，删除操作。</li>
<li>如何给最后一个间隙加锁————<code>Supremum</code>记录</li>
</ul>
<p>Next-Key Locks</p>
<ul>
<li>既锁住某条记录（无法读写），又想阻止其他事务在该记录前边的<code>间隙</code>插入新记录。</li>
<li>Next-Key Locks &#x3D; 记录锁 + 间隙锁</li>
</ul>
<p>插入意向锁：</p>
<ul>
<li>如果一个事务在执行<code>INSERT</code>操作时，如果即将插入的<code>间隙</code>已经被其他事务加了<code>gap锁</code>，那么本次<code>INSERT</code>操作会阻塞，并且当前事务会在该间隙上加一个<code>插入意向锁</code>。</li>
<li>还没发现有什么用，插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁</li>
</ul>
<p>隐式锁*</p>
<ul>
<li>一般情况下，除了插入意向锁，<code>INSERT</code>操作是不加锁的。如果此时有其他事务访问该记录，就会发生<code>脏读</code>或<code>脏写</code></li>
<li>一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于<code>事务id</code>的存在，相当于加了一个<code>隐式锁</code>。别的事务在对这条记录加<code>S锁</code>或者<code>X锁</code>时，由于<code>隐式锁</code>的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。</li>
<li>对于聚簇索引记录来说，有一个<code>trx_id</code>隐藏列，该隐藏列记录着最后改动该记录的<code>事务id</code>。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的<code>trx_id</code>隐藏列代表的的就是当前事务的<code>事务id</code>，如果其他事务此时想对该记录添加<code>S锁</code>或者<code>X锁</code>时，首先会看一下该记录的<code>trx_id</code>隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个<code>X锁</code>（也就是为当前事务创建一个锁结构，<code>is_waiting</code>属性是<code>false</code>），然后自己进入等待状态（也就是为自己也创建一个锁结构，<code>is_waiting</code>属性是<code>true</code>）。</li>
</ul>
<h4 id="InnoDB行锁的补充"><a href="#InnoDB行锁的补充" class="headerlink" title="InnoDB行锁的补充"></a>InnoDB行锁的补充</h4><h5 id="两阶段锁协议的概念"><a href="#两阶段锁协议的概念" class="headerlink" title="两阶段锁协议的概念"></a>两阶段锁协议的概念</h5><ul>
<li>两阶段指：同一事务不同行记录加锁的时机不同但是释放锁的时机是相同的，都是在事务提交的时候释放锁</li>
<li>两阶段锁协议是行锁的加锁协议。</li>
<li>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</li>
<li>两阶段锁是造成锁冲突的原因。如果你的事务中需要锁多个行， 要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放</li>
</ul>
<h5 id="死锁和死锁处理"><a href="#死锁和死锁处理" class="headerlink" title="死锁和死锁处理"></a>死锁和死锁处理</h5><ul>
<li><p>两阶段锁协议下，如果两个事务都对同一行记录进行写操作可能会造成死锁。</p>
</li>
<li><p>死锁的例子：</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230318160153584.png" alt="image-20230318160153584" style="zoom:80%;" />
</li>
<li><p>MySQL解决死锁的两种策略：一种策略是，直接进入等待，直到超时。第二种策略，主动死锁检测，然后进行处理。</p>
</li>
</ul>
<h5 id="索引失效会使用表锁"><a href="#索引失效会使用表锁" class="headerlink" title="索引失效会使用表锁"></a>索引失效会使用表锁</h5><p><strong>如果锁定读查询语句或者update 和 delete 语句，没有使用索引列作为查询条件，或者查询语句没有走索引查询，导致扫描是全表扫描。那么，每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞</strong>。</p>
<h2 id="其他面试题"><a href="#其他面试题" class="headerlink" title="其他面试题"></a>其他面试题</h2><h3 id="mysql如何实现悲观锁和乐观锁"><a href="#mysql如何实现悲观锁和乐观锁" class="headerlink" title="mysql如何实现悲观锁和乐观锁"></a>mysql如何实现悲观锁和乐观锁</h3><p>一、乐观锁的实现方法<br>乐观锁是一种乐观的并发控制策略，它假设事务之间的冲突很少发生，因此在读取数据之后不会对数据进行加锁，而是在事务提交时检查是否有其他事务对数据进行了修改。如果没有发生冲突，事务就会成功提交，否则就会回滚并重新尝试。</p>
<p>版本号机制是一种基于数据版本的乐观锁实现方式。在数据库表中添加一个表示版本号的序段，每次更新数据时对版本号进行加1操作。在事务提交时，检查当前数据的版本号是否与事务开始时读取的版本号相同，如果相同则说明数据没有被其他事务修改，可以成功提交。如果不同，则说明数据发生了冲突，事务需要重新尝试。</p>
<p>二、悲观锁的实现方法<br>悲观锁是一种悲观的并发控制策略，它假设事务之间的冲突频繁发生，因此在读取数据之后会对数据进行加锁，阻止其他事务对该数据进行修改，直到当前事务提交或回滚。</p>
<p>悲观锁的实现方法包括主要是通过全局锁，表锁，行锁实现的。</p>
<h3 id="事务的特性（ACID）了解么"><a href="#事务的特性（ACID）了解么" class="headerlink" title="事务的特性（ACID）了解么?"></a>事务的特性（ACID）了解么?</h3><p><strong>原子性（Atomicity）：</strong> <strong>一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态</strong>，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</p>
<p><strong>一致性（Consistency）：</strong> <strong>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。</strong>这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</p>
<p><strong>隔离性（Isolation）：</strong> <strong>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。</strong>事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p>
<p><strong>持久性（Durability）:</strong> 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>
<h4 id="如何实现事务"><a href="#如何实现事务" class="headerlink" title="如何实现事务"></a>如何实现事务</h4><p>原子性：undo log</p>
<p>隔离性：事务的并发问题，MVCC和锁</p>
<p>持久性：bin log 和 redo log</p>
<p><strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</strong></p>
<h3 id="MySQL中事务的一致性如何保证"><a href="#MySQL中事务的一致性如何保证" class="headerlink" title="MySQL中事务的一致性如何保证"></a>MySQL中事务的一致性如何保证</h3><ol>
<li>锁机制：MySQL采用了多种锁机制来保证事务的一致性，如行锁、表锁、页锁等。当一个事务需要访问一条记录时，会先对该记录进行加锁，防止其他事务对其进行修改或删除。事务在执行过程中需要访问的所有数据都需要加锁，以保证事务的一致性。</li>
<li>事务日志：MySQL使用事务日志（Transaction Log）来记录事务的执行过程。当一个事务需要对数据库进行修改时，MySQL首先将修改操作记录在事务日志中，然后再进行实际的修改操作。如果修改操作成功，则会将事务提交到数据库中。如果在执行过程中出现错误，可以通过事务日志进行回滚，恢复到事务执行前的状态，以保证数据的一致性。</li>
<li>MVCC：MySQL采用了多版本并发控制（MVCC）机制，通过保存数据的多个版本来实现不同事务之间的隔离性。在read commit下，当一个事务需要访问数据时，会读取该数据的最新版本。如果在执行过程中其他事务对该数据进行了修改，该事务会读取到旧版本的数据，并等待锁释放后（事务提交）重新读取最新版本的数据。</li>
</ol>
<h3 id="连接操作的原理"><a href="#连接操作的原理" class="headerlink" title="连接操作的原理"></a>连接操作的原理</h3><h4 id="连接的原理：嵌套循环连接"><a href="#连接的原理：嵌套循环连接" class="headerlink" title="连接的原理：嵌套循环连接"></a>连接的原理：嵌套循环连接</h4><p>步骤1：选取代价最低的单表访问方法来执行对驱动表的单表查询</p>
<p>步骤2：对上一步骤中查询驱动表得到的结果集中每一条记录，都分别到被驱动表中查找匹配的记录</p>
<p>步骤3：如果涉及3个表的话，把步骤2结果集作为新的驱动表，第三个表就成为了被驱动表，重复上边过程</p>
<h4 id="驱动表与被驱动表的关系"><a href="#驱动表与被驱动表的关系" class="headerlink" title="驱动表与被驱动表的关系"></a>驱动表与被驱动表的关系</h4><p>在连接查询中，驱动表中的结果集会作为被驱动表中的匹配条件；也就是说需要根据驱动表表中的记录去找被驱动表中的记录</p>
<p>SELECT * FROM t1, t2 WHERE t1.m1 &gt; 1 AND t1.m1 &#x3D; t2.m2 AND t2.n2 &lt; ‘d’;</p>
<p>将t1.m1 &gt; 1 在t1中过滤的结果作为一个结果集，保存起来；然后根据这个结果集中的每一条记录去被驱动表(t2)查找匹配的记录，结合t2的过滤条件进行过滤，得到的结果就是最终结果<br>例如：<br>t1.m1 &#x3D; 2 -&gt; t2.m2 &#x3D; 2 AND t2.n2 &lt; ‘d’<br>t1.m1 &#x3D; 3 -&gt; t2.m2 &#x3D; 3 AND t2.n2 &lt; ‘d’<br>t1.m1 &#x3D; 4 -&gt; t2.m2 &#x3D; 4 AND t2.n2 &lt; ‘d’</p>
<h4 id="连接的类型"><a href="#连接的类型" class="headerlink" title="连接的类型"></a>连接的类型</h4><p><strong>内连接</strong></p>
<p>驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集</p>
<p><strong>外连接</strong></p>
<p>驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。也就是说连接的结果集以选取的驱动表为准</p>
<p>左外连接：左边为驱动表；右外连接：右边为驱动表</p>
<p><strong>union和join的区别</strong></p>
<p>union对两个结果集进行并集操作，筛选，被合并的结果集的字段数量、顺序和数据类型必须完全一致。字段名不一样的情况下，会将第一个结果集的字段名作为合并后的虚拟结果集的字段名。</p>
<p>join笛卡尔积操作，拼接，join需要和on搭配，on后面表示两个结果集匹配的条件，如果两条记录匹配，那么就会进行拼接</p>
<p><strong>union和union all</strong></p>
<p>union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；</p>
<p>union all：对两个结果集进行并集操作，包括重复行，不进行排序；</p>
<h4 id="关于外键"><a href="#关于外键" class="headerlink" title="关于外键"></a>关于外键</h4><p>外键是某个表中的一列，它包含在另一个表的主键中。通过一张表中的一列指向另一张表中的主键，来对两张表进行关联。外键的主要作用是保证数据的一致性和完整性</p>
<ul>
<li>从表插入新行，其外键值不是主表的主键值便阻止插入。</li>
<li>主表删除行，其主键值在从表里存在便阻止删除(要想删除，必须先删除从表的相关行)。</li>
</ul>
<h3 id="SQL-优化有哪些技巧？"><a href="#SQL-优化有哪些技巧？" class="headerlink" title="SQL 优化有哪些技巧？"></a>SQL 优化有哪些技巧？</h3><h4 id="1、创建索引"><a href="#1、创建索引" class="headerlink" title="1、创建索引"></a>1、创建索引</h4><h4 id="2、避免索引失效"><a href="#2、避免索引失效" class="headerlink" title="2、避免索引失效"></a>2、避免索引失效</h4><h4 id="3、锁粒度"><a href="#3、锁粒度" class="headerlink" title="3、锁粒度"></a>3、锁粒度</h4><p>为了提高系统的高并发能力，我们通常建议采用 <code>行锁</code>，减少<code>锁冲突</code>、<code>锁等待</code> 的时间。所以，存储引擎通常会选择 <code>InnoDB</code></p>
<p><strong>行锁可能会升级为表锁，有哪些场景呢？</strong></p>
<ul>
<li>如果一个表批量更新，大量使用行锁，可能导致其他事务长时间等待，严重影响事务的执行效率。此时，MySQL会将 <code>行锁</code> 升级为 <code>表锁</code></li>
<li>行锁是针对索引加的锁，如果 <code>条件索引失效</code>，那么 <code>行锁</code> 也会升级为 <code>表锁</code></li>
</ul>
<h4 id="4、分页查询优化"><a href="#4、分页查询优化" class="headerlink" title="4、分页查询优化"></a>4、分页查询优化</h4><h5 id="关于limit语句的注意事项："><a href="#关于limit语句的注意事项：" class="headerlink" title="关于limit语句的注意事项："></a>关于limit语句的注意事项：</h5><ul>
<li><p>limit语句中start不是初始id值，而是第几行记录的意思。</p>
</li>
<li><p>limit语句的缺陷，limit语句的真正执行流程</p>
<p>MySQL中是在实际向客户端发送记录前才会去判断LIMIT子句是否符合要求，所以如果使用二级索引执行limit查询的话(select *)，意味着要进行5001次回表操作。</p>
<p><a href="https://juejin.cn/book/6844733769996304392/section/7075313189730287654?utm_source=post_pay_page">https://juejin.cn/book/6844733769996304392/section/7075313189730287654?utm_source=post_pay_page</a></p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230328171052108.png" alt="image-20230328171052108" style="zoom:80%;" /></li>
</ul>
<h5 id="普通limit语句："><a href="#普通limit语句：" class="headerlink" title="普通limit语句："></a>普通limit语句：</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表 limit #&#123;<span class="keyword">start</span>&#125;, #&#123;pageSize&#125;;</span><br></pre></td></tr></table></figure>

<p>随着翻页的深度加大， <code>start</code> 值越来越大，比如：limit 10000 ，10</p>
<p>看似只返回了 10 条数据，但数据库引擎需要查询 10010 条记录，然后将前面的 10000 条丢弃，最终只返回最后的 10 条记录，性能可想而知</p>
<p>注： keyid 是二级索引。</p>
<h5 id="解决方法一：使用索引过滤，不需要一条一条读，但不能直梯翻页。"><a href="#解决方法一：使用索引过滤，不需要一条一条读，但不能直梯翻页。" class="headerlink" title="解决方法一：使用索引过滤，不需要一条一条读，但不能直梯翻页。"></a>解决方法一：使用索引过滤，不需要一条一条读，但不能直梯翻页。</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表 <span class="keyword">where</span>  keyid  <span class="operator">&gt;</span> #&#123;id&#125; limit #&#123;pageSize&#125;;</span><br></pre></td></tr></table></figure>

<p>先定位到上一次分页的最大 id，然后对 id 做条件索引查询。由于数据库的索引采用 B+ 树结构，这样可以一步到位</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230328160429773.png" alt="image-20230328160429773" style="zoom:80%;" />

<p>但是这种翻页方式只支持 <code>上一页</code>、<code>下一页</code> ，不支持跨越式直梯翻页</p>
<h5 id="解决方法二：采用子查询，避免回表"><a href="#解决方法二：采用子查询，避免回表" class="headerlink" title="解决方法二：采用子查询，避免回表"></a>解决方法二：采用子查询，避免回表</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表 <span class="keyword">where</span> keyid <span class="operator">&gt;</span> ( <span class="keyword">select</span> keyid <span class="keyword">from</span> 表 <span class="keyword">order</span> <span class="keyword">by</span> keyid limit <span class="number">10000</span> <span class="number">1</span>) limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先，查询出 一页数据中的最小 id（这一步还是要一条一条的读到10000，只不过每一次都不需要回表操作）</li>
<li>然后，通过 B+ 树，精确定位到 <code>最小id的索引树节点位置</code>，通过 <code>偏移量</code> 读取后面的 10条 数据</li>
</ul>
<p>or</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t, (<span class="keyword">SELECT</span>  keyid  <span class="keyword">FROM</span> t <span class="keyword">ORDER</span> <span class="keyword">BY</span>  keyid  LIMIT <span class="number">10000</span>, <span class="number">10</span>) <span class="keyword">AS</span> d</span><br><span class="line">    <span class="keyword">WHERE</span> t. keyid  <span class="operator">=</span> d. keyid ;</span><br></pre></td></tr></table></figure>



<h4 id="5、避免-select"><a href="#5、避免-select" class="headerlink" title="5、避免 select  *"></a>5、避免 select  *</h4><p>字段尽量在 <code>覆盖索引</code> 中，从而减少 <code>回表</code> 操作。</p>
<h4 id="6、尽量避免多表做join"><a href="#6、尽量避免多表做join" class="headerlink" title="6、尽量避免多表做join"></a>6、尽量避免多表做join</h4><p>在数据库中使用嵌套循环来实现关联查询，需要临时表来储存中间结果表。效率比较低</p>
<p>解决方法：</p>
<p>1.数据仅做单表查询，在程序中做关联。这样做就相当于把连接的任务交给程序做了，减轻了数据库的压力。</p>
<p>2.数据冗余：把一些重要数据在表中做冗余，避免关联查询。</p>
<h4 id="7、EXPLAIN-分析-SQL-执行计划"><a href="#7、EXPLAIN-分析-SQL-执行计划" class="headerlink" title="7、EXPLAIN 分析 SQL 执行计划"></a>7、EXPLAIN 分析 SQL 执行计划</h4><p>执行计划就是一条sql在执行器中真正执行的语句信息，</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230405193601306.png" alt="image-20230405193601306" style="zoom:80%;" />

<p>1.id：是一个有顺序的编号，是查询的顺序号，有几个select就显示几行。id的顺序是按select出现的顺序增<br>长的。id列的值越大执行优先级越高越先执行，id列的值相同则从上往下执行，id列的值为NU儿L最后执行。</p>
<p>2.selectType：表示查询中每个select子句的类型</p>
<ul>
<li>SIMPLE:表示此查询不包含UNION查询或子查询</li>
<li>PRIMARY:表示此查询是最外层的查询（包含子查询）</li>
<li>SUBQUERY:子查询中的第一个SELECT</li>
</ul>
<p>3.table：表示该语句查询的表<br>4.<strong>type</strong>：数据的方法方法，优化sq的重要字段：他的取值类型范围：</p>
<ul>
<li><p><strong>system</strong>：表中只有一行记录，相当于系统表</p>
</li>
<li><p><strong>const</strong>：表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件。</p>
</li>
<li><p><strong>eq_ref</strong>：当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 system 与 const 之外最好的 join 方式，常用于使用主键或唯一索引的所有字段作为连表条件。</p>
</li>
<li><p><strong>ref</strong>：使用普通索引作为查询条件，查询结果可能找到多个符合条件的行。</p>
</li>
<li><p><strong>range</strong>：对索引列进行范围查询，执行计划中的 key 列表示哪个索引被使用了。</p>
</li>
<li><p><strong>index</strong>：查询遍历了整棵索引树，与 ALL 类似，指覆盖索引的全表扫描。</p>
</li>
<li><p><strong>ALL</strong>：全表扫描。</p>
</li>
</ul>
<p>5.<strong>key</strong> ：表示 MySQL 实际使用到的索引。如果为 NULL，则表示未用到索引。</p>
<p>6.rows表示需要扫描读取的行数</p>
<p>7.filtered:返回结果的行占需要读到的行(rows列的值)的百分比，就是百分比越高，说明需要查询到数据越准<br>确，百分比越小，说明查询到的数据量大，而结果集很少</p>
<p>8.<strong>extra</strong>：额外信息</p>
<ul>
<li><p>using filesort:表示mysql对结果集进行外部排序，不能通过索引顺序达到排序效果。一般有using filesort都建议优化去掉，因为这样的查询cpu资源消耗大，延时大。</p>
</li>
<li><p>Using temporary：MySQL 需要创建临时表来存储查询的结果，常见于 ORDER BY 和 GROUP BY。</p>
<p><a href="https://blog.csdn.net/qq_40124555/article/details/122673993">https://blog.csdn.net/qq_40124555/article/details/122673993</a></p>
</li>
<li><p>using index:表明查询使用了覆盖索引，不用回表，查询效率非常高。</p>
</li>
<li><p>Using index condition：表示查询优化器选择使用了索引条件下推这个特性。</p>
</li>
<li><p>using where:表明查询使用了 WHERE 子句进行条件过滤。一般在没有使用到索引的时候会出现。</p>
</li>
</ul>
<h3 id="数据表在文件系统中的表示"><a href="#数据表在文件系统中的表示" class="headerlink" title="数据表在文件系统中的表示"></a>数据表在文件系统中的表示</h3><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230411201131135.png" alt="image-20230411201131135" style="zoom:80%;" />

<h4 id="某张表的数据储存"><a href="#某张表的数据储存" class="headerlink" title="某张表的数据储存"></a>某张表的数据储存</h4><p>表名.ibd（独立表空间） 储存数据</p>
<p>表名.frm 储存表结构的定义</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230411201135522.png" alt="image-20230411201135522" style="zoom:80%;" />

<h4 id="日志文件和缓存"><a href="#日志文件和缓存" class="headerlink" title="日志文件和缓存"></a>日志文件和缓存</h4><p>在关闭MySQL时，会把内存中的热数据保存在磁盘里ib_buffer_pool文件中</p>
<p>ib_logfile0,ib_logfile1就是redo日志</p>
<p>系统表空间（system tablespace）ibdata1</p>
<h3 id="MyISAMDB和InnoDB的区别"><a href="#MyISAMDB和InnoDB的区别" class="headerlink" title="MyISAMDB和InnoDB的区别"></a>MyISAMDB和InnoDB的区别</h3><p><strong>数据储存</strong></p>
<p>MyISAMDB的.frm(表结构)，.myi(索引)，.myd(数据)</p>
<p><strong>索引</strong></p>
<p>MyISAMDB的索引都是二级索引，不会储存完整用户记录</p>
<p>InnoDB的索引包括聚聚索引和二级索引</p>
<p><strong>事务</strong></p>
<p>MyISAM 不提供事务支持，没有提交(commit)和回滚(rollback)事务的能力。</p>
<p>MyISAMDB没有MVCC机制，读数据就加共享锁，写数据就加排他锁</p>
<p>MyISAMDB没有行锁，只有表锁</p>
<p><strong>崩溃恢复</strong></p>
<p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code> 。</p>
<p><strong>外键</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p>读写分离主要应对的是数据库读并发，没有解决数据库存储问题。试想一下：MySQL 一张表的数据量过大怎么办?</p>
<p>分库</p>
<p>分库就是将数据库中的数据分散到不同的数据库上，可以垂直分库，也可以水平分库。</p>
<p>垂直分库 就是把单一数据库按照业务进行划分，不同的业务使用不同的数据库，进而将一个数据库的压力分担到多个数据库。</p>
<p>水平分库 是把同一个表按一定规则拆分到不同的数据库中，每个库可以位于不同的服务器上，这样就实现了水平扩展，解决了单表的存储和性能瓶颈的问题。</p>
<p>分表</p>
<p>分表 就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。</p>
<p>垂直分表 是对数据表列的拆分，把一张列比较多的表拆分为多张表。</p>
<p>举个例子：我们可以将用户信息表中的一些列单独抽出来作为一个表。</p>
<p>水平分表 是对数据表行的拆分，把一张行比较多的表拆分为多张表，可以解决单一表数据量过大的问题。</p>
<p>举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p>
<p>（水平分表）哈希分片：求指定 key（比如 id） 的哈希，然后根据哈希值确定数据应被放置在哪个表中。哈希分片比较适合随机读写的场景，不太适合经常需要范围查询的场景。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-12-11-ChatGPT</title>
    <url>/posts/bb81.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-07-06-Lottery抽奖系统</title>
    <url>/posts/e6af.html</url>
    <content><![CDATA[<h1 id="项目2-0"><a href="#项目2-0" class="headerlink" title="项目2.0"></a>项目2.0</h1><h2 id="一-lottery"><a href="#一-lottery" class="headerlink" title="一.lottery"></a>一.lottery</h2><span id="more"></span>

<h3 id="1-状态模式"><a href="#1-状态模式" class="headerlink" title="1.状态模式"></a>1.状态模式</h3><p><strong>利用状态模式思想，实现活动审核状态流转的过程，避免代码中存在过多的分支语句，提高了系统的可读性和可拓展性</strong></p>
<p>状态模式和简单工厂模式结合的方式</p>
<p>活动审核通过后，第一次开启活动会直接进入“活动中”状态，“活动中”的状态可以“关闭”，然后再“开启”，即“通过”的活动第一次不会进入“开启”状态，也即只有“关闭”的活动才能“开启”</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230907231459300.png" alt="image-20230907231459300" style="zoom:80%;" />

<p>业务场景：</p>
<p>一个活动的状态可以流转分为未审核，审核通过，审核拒绝，活动运行中，活动关闭，对一个活动可以执行的动作包括审核，开启和关闭。不同状态下活动执行同一行为会产生不同的结果。例如，一个未审核的活动需要先进行审核，当他变成通过状态时才能进行开启。一个运行中的活动只能进行关闭，不能开启也不能审核。（注：在数据库中会有一个专门的字段来储存活动的状态信息）</p>
<p>状态模式的使用场景：</p>
<p>当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式了。对于这种多种状态流转的业务，如果直接编写代码，需要使用大量的if else语句，判断活动的状态执行对应的方法逻辑，这不仅会降低可读性而且也不利于拓展。</p>
<p>如何使用状态模式来实现这个业务场景：</p>
<p>1.创建一个接口作为活动状态的抽象类，在接口中定义活动的审核，开启，关闭方法。</p>
<p>2.将不同的状态类实现这个接口并实现这个接口的方法，例如：未审核状态的活动的审核方法会执行成功，并将活动状态置为审核通过或者审核拒绝状态（数据库字段），而它的开启方法和关闭方法则会无效。</p>
<p>3.然后根据状态获取具体的状态类对象执行对应的方法即可，这里我是借助了工厂模式的思想，使用一个map集合储存所有的状态类的对象，通过状态的字段名获取状态对象，这样可以避免直接创建状态类的对象。</p>
<h3 id="2-模板模式"><a href="#2-模板模式" class="headerlink" title="2.模板模式"></a>2.模板模式</h3><p>利用模板模式设计思想，编排抽奖流程，实现快速迭代诉求。<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230730112213382.png" alt="image-20230730112213382" style="zoom:80%;" /></p>
<p>业务场景：</p>
<p>整体抽奖流程</p>
<p>1.根据入参策略ID获取抽奖策略</p>
<p>2.初始化奖品数据，包括从数据库中获取该活动所有奖品的数量和概率信息，获取不在抽奖范围内的列表。</p>
<p>3.执行具体的抽奖策略，这里主要实现了两种，一种是单体概率，另一种总体概率；单体概率跟总体概率的区别在于，单体概率的某个奖品抽光之后还会有概率抽到空奖品，而总体概率在每次有奖品抽光后都会重新调整抽奖概率，避免抽空。</p>
<p>4.包装中奖结果。</p>
<p>模板模式：</p>
<p>模板方法模式，通过定义一个操作中的算法的骨架，而将一些不同的步骤延迟到子类中，避免在子类中编写相同步骤的代码。</p>
<p>如何使用实现：</p>
<p>因为这个抽奖过程中除了第三步抽奖策略有不同的实现外，其他步骤的实现都是相同的。</p>
<p>1.定义一个抽象父类，里面实现一个抽奖方法，在抽奖方法里面实现整个流程，而其中的第三步则作为抽象方法调用。</p>
<p>2.定义具体的抽奖策略的子类，子类继承抽象父类实现它的抽象方法。</p>
<p>3.创建子类对象，这样就能利用java多态的特性实现使用具体的抽奖策略进行抽奖了。</p>
<p>总体概率</p>
<p>单体概率</p>
<h3 id="3-雪花算法"><a href="#3-雪花算法" class="headerlink" title="3.雪花算法*"></a>3.雪花算法*</h3><p>利用雪花算法生成分布式ID,保证分布式D唯一性，分别用于订单、策略、以及活动号生成上。</p>
<h4 id="为什么需要分布式ID？"><a href="#为什么需要分布式ID？" class="headerlink" title="为什么需要分布式ID？"></a>为什么需要分布式ID？</h4><p>当ID需要作为数据库主键时就需要使用分布式ID。</p>
<p>如果是只使用一个数据库情况下，使用主键自增是没有问题的。但是在分布式系统下，由于数据量大一个数据库处理不来，需要进行分库分表建立多个数据库，那么如果仍然使用数据库主键自增来生成唯一id就会造成id重复问题。因此分布式系统需要分布式ID。</p>
<p>分布式ID需要满足的要求：</p>
<p>（这两个必须）</p>
<ul>
<li><p><strong>全局唯一</strong>：ID 的全局唯一性肯定是首先要满足的！</p>
</li>
<li><p><strong>高性能</strong>：分布式 ID 的生成速度要快，对本地资源消耗要小。</p>
</li>
<li><p><strong>安全</strong>：ID 中不包含敏感信息。</p>
</li>
<li><p><strong>有序递增</strong>：如果要把 ID 存放在数据库的话，ID 的有序性可以提升数据库写入速度。并且，很多时候 ，我们还很有可能会直接通过 ID 来进行排序。</p>
</li>
<li><p><strong>有具体的业务含义</strong>：生成的 ID 如果能有具体的业务含义，可以让定位问题以及开发更透明化（通过 ID 就能确定是哪个业务）。</p>
</li>
</ul>
<h4 id="常见的分布式ID方案"><a href="#常见的分布式ID方案" class="headerlink" title="常见的分布式ID方案"></a>常见的分布式ID方案</h4><p><strong>UUID</strong></p>
<p>其生成规则包括 MAC 地址、时间戳、随机或伪随机数等元素，所以不会重复的。</p>
<p>比如使用 UUID 作为 MySQL 数据库主键的时候就非常不合适：</p>
<ul>
<li>数据库主键要尽量越短越好，而 UUID 的消耗的存储空间比较大（32 个字符串，128 位）。</li>
<li>UUID 是无顺序的，InnoDB 引擎下，数据库主键的无序性会严重影响数据库性能。</li>
</ul>
<p>最后，我们再简单分析一下 <strong>UUID 的优缺点</strong> :</p>
<ul>
<li><strong>优点</strong>：全局唯一性，生成速度比较快、简单易用</li>
<li><strong>缺点</strong>：存储消耗空间大（32 个字符串，128 位）、 不安全（造成 MAC 地址泄露)、UUID 生成的是一个无序的字符串，对于 MySQL 推荐使用增长的数值类型值作为主键来说不适合，没有具体业务含义</li>
</ul>
<p><strong>Snowflake</strong></p>
<p><a href="https://zhuanlan.zhihu.com/p/645755361">https://zhuanlan.zhihu.com/p/645755361</a></p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230911223619498.png" alt="image-20230911223619498" style="zoom:80%;" />

 

<p>雪花算法的原理就是生成一个的 64 位比特位的 long 类型的唯一 id。</p>
<ul>
<li><p>最高 1 位固定值 0，因为生成的 id 是正整数，如果是 1 就是负数了，影响趋势递增特性。</p>
</li>
<li><p>接下来 41 位存储<strong>毫秒级时间戳，保证雪花id是毫秒时间有序的</strong>，2^41&#x2F;(1000<em>60</em>60<em>24</em>365)&#x3D;69，大概可以使用 69 年。</p>
</li>
<li><p>再接下 10 位存储<strong>机器码和服务码</strong>，包括 5 位 datacenterId 和 5 位 workerId。最多可以部署 2^10&#x3D;1024 台机器。</p>
</li>
<li><p>最后 12 位存储<strong>序列号。序列号的作用在于同一台机器中，如果上个生成 ID 的时间位与当前 ID 的时间位冲突，则会生成一个序列号进行区分，如果序列号用尽，则等待下一个时间点再生成。如果上个生成 ID 的时间位与当前 ID 的时间位不冲突，则将序列号设置成 0。</strong>。</p>
</li>
<li><p><strong>为了保证序列号是时间有序的，雪花算法最好用单例方式生成 ID，因为雪花算法会依赖上一次生成的 ID 的时间来判断是否需要对序列号进行增加的操作，如果不是单例，两个业务用两个对象同时获取 ID，则可能会生成相同的 ID。可以将雪花算法作为一个单独的服务进行部署，然后需要全局唯一 id 的系统，请求雪花算法服务获取 id 即可。</strong></p>
<p>sequence &#x3D; (sequence + 1) &amp; sequenceMask，序列号最大值 sequenceMask 为 2^12&#x3D;4096</p>
</li>
</ul>
<p>Snowflake 算法的优缺点：</p>
<ul>
<li><p><strong>优点</strong>：</p>
<p><strong>高并发分布式环境下生成不重复 id</strong>，每秒可生成百万个不重复 id。</p>
<p><strong>基于时间戳，以及同一时间戳下序列号自增，基本保证 id 有序递增。</strong></p>
<p>不依赖第三方库或者中间件。</p>
<p><strong>算法简单，在内存中进行，效率高。</strong></p>
</li>
<li><p><strong>缺点</strong>：需要解决重复 ID 问题（<strong>依赖时间，当机器时间不对的情况下，可能导致会产生重复 ID</strong>）。</p>
</li>
</ul>
<h3 id="4-组合模式"><a href="#4-组合模式" class="headerlink" title="4.组合模式*"></a>4.组合模式*</h3><p>使用组合模式搭建用于量化人群的规则引擎，解决共性功能重复开发问题，提高研发效率。</p>
<p>上面两个的rule_limit_type的值为enum表示枚举类型</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230912234548380.png" alt="image-20230912234548380" style="zoom: 80%;" />

<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/1&e=1698767999&s=vtvyvvtymvytjty&token=kIxbL07-8jAj8w1n4s9zv64FuZZNEATmlU_Vm6zDT0pANjUuPmk27lmhpJmo7h3AW4I=.png" alt="img" style="zoom:80%;" />

<p>业务需求：</p>
<p>什么是量化人群？用户在抽奖前需要先参与活动，那么量化人群就是指为不同的人群划分不同的活动。比如可以根据用户年龄和性别推荐适合活动，这部分算法可以借助决策树来实现。决策树的构建一般由专门的算法工程师使用相关的算法生成，然后将这个树结构储存在数据库中，然后在程序启动时生成决策树，遍历决策树获取结果的过程由规则引擎完成。</p>
<p>组合模式：</p>
<p>组合模式其实为这种类层次结构的组合对象提供一种解决方法。组合模式的基本对象可以组合成组合对象，而这个组合对象又可以被组合成更复杂的组合对象；在用户使用的时候，无论是组合对象还基本对象都可以使用统一的接口。（例如过滤器中的过滤方法对任何结点都适用）</p>
<p>决策树本身作为一种树结构，主要包括决策结点和结果结点，因此很适合使用组合模式的思想构建和使用决策树。</p>
<p>规则引擎：</p>
<p><strong>实现的简单表述：</strong></p>
<p><strong>通过组合不同的决策节点和结果结点形成决策树，不同的决策节点向下通过树枝指代了当前决策节点决策规则，使用过滤器为每个决策节点都提供了相同的接口。最终决策树通过规则擎执行决策树，最终找到一个结果结点，返回当前节点活动信息，作为规则引擎执行结果。</strong></p>
<p>如何实现：</p>
<p><strong>实现算法由三个部分组成</strong></p>
<p>第一部分是决策树的构建和持久化</p>
<p>决策树的数据结构是储存在数据库中的，主要包含两种类型，结点和树枝，其中结点包括决策结点和结果结点。决策结点下还会包含子树结构，而结果结点则是叶子节点，这样就形成了树结构。</p>
<p>第二部分是决策树过滤器的实现</p>
<p>过滤器的作用在于根据当前结点树枝中的决策信息找到决策的下一个结点。过滤器相当于组合模式的统一接口。</p>
<p>第三部分是规则引擎的实现</p>
<p>在引擎中构建整个决策树，根据用户的个人信息从树根开始借助过滤器过滤，最后到达某个结果结点结束，在结果结点中就包含该用户的参与活动号。</p>
<h3 id="5-kafka"><a href="#5-kafka" class="headerlink" title="5.kafka*"></a>5.kafka*</h3><p>使用Kafka实现异步奖品发货功能，解耦抽奖流程与发货流程，提高了系统响应时间。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230912181517336.png" alt="image-20230912181517336" style="zoom:80%;" />

<p>业务需求：</p>
<p>实现整个抽奖的流程，依次是领取活动-&gt;执行抽奖-&gt;结果落库-&gt;触发发奖流程-&gt;返回结果。</p>
<p>实际上在抽奖结果落库之后，用户的抽奖流程就结束了，不应该等到发奖流程结束才返回结果，这样会提高系统的响应时间，降低用户的体验。</p>
<p>所以，“触发发奖流程”应该作为异步操作来执行，然后这部分功能由消息队列完成。</p>
<p>消息队列优点：</p>
<p>异步，解耦，削峰。</p>
<p>削峰:相较于异步线程，消息队列可以储存消息慢慢消费，保证消息不丢失。</p>
<p>具体实现：</p>
<p><strong>包括发送MQ和消费MQ（触发发奖流程）</strong></p>
<p>”发送MQ“，调用MQ生产者发送消息，当线程发送消息后，会把结果传给回调函数，并调用回调函数的逻辑。在回调函数中定义MQ 消息发送完成或者失败的处理机制。</p>
<p>MQ 消息发送完成，更新数据库表 的mq状态为发送成功</p>
<p>MQ 消息发送失败，更新数据库表 的mq状态为发送失败，后序通过定时任务补偿</p>
<p>“消费MQ”，调用MQ消费者触发发奖流程。消费者负责监听消息队列中的发奖主题，一旦收到MQ传来的消息就执行对应的发货逻辑，执行成功后为了避免消息丢失需要手动提交offset。</p>
<p>注：<code>ack.acknowledge()</code> 方法的主要目的是确认已经成功消费了特定分区中的消息。这告诉 Spring Kafka 框架，消费者已经处理了消息，并且可以在适当的时候提交位移（offset）。</p>
<p>消息丢失</p>
<p>1.异步发送</p>
<p>2.消费消息后手动提交</p>
<p>3.幂等性</p>
<h3 id="6-线程池"><a href="#6-线程池" class="headerlink" title="6.线程池"></a>6.线程池</h3><p>业务需求：</p>
<p>在发送MQ失败时并没有立即重新给kafka发送消息，因为消费失败时可能会不断重发请求，导致死循环，严重浪费计算资源，所以发送失败时只是把该订单记录中的一个跟mq状态相关的值设置为0，表示订单异常。那么就需要对消息进行补偿。</p>
<p>定时任务：</p>
<p>在线程池中开启一个延迟线程，每隔一段时间就去查询表中所有的异常订单，然后重新发送MQ。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获得当前时间</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="comment">// 获取本周四 18:00:00.000</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">thursday</span> <span class="operator">=</span> </span><br><span class="line">    now.with(DayOfWeek.THURSDAY).withHour(<span class="number">18</span>).withMinute(<span class="number">0</span>).withSecond(<span class="number">0</span>).withNano(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 如果当前时间已经超过 本周四 18:00:00.000， 那么找下周四 18:00:00.000</span></span><br><span class="line"><span class="keyword">if</span>(now.compareTo(thursday) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    thursday = thursday.plusWeeks(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算时间差，即延时执行时间</span></span><br><span class="line"><span class="type">long</span> <span class="variable">initialDelay</span> <span class="operator">=</span> Duration.between(now, thursday).toMillis();</span><br><span class="line"><span class="comment">// 计算间隔时间，即 1 周的毫秒值</span></span><br><span class="line"><span class="type">long</span> <span class="variable">oneWeek</span> <span class="operator">=</span> <span class="number">7</span> * <span class="number">24</span> * <span class="number">3600</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;开始时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">executor.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;, initialDelay, oneWeek, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>

<p>为什么要使用线程池：</p>
<p>降低资源消耗，提高响应速度，提高线程的可管理性；理论上使用一个定时任务线程也能完成，但是当定时任务变多时，就不好管理了。</p>
<p>实现：</p>
<p>使用juc提供的ScheduledThreadPool线程池启动定时任务，使用scheduleAtFixedRate提交定时任务。scheduleAtFixedRate需要2个重要的参数，初始延迟时间和间隔时间，初始延迟时间是指该定时任务第一次执行的延迟时间，时间间隔指每隔多久重复执行任务，计算完这些参数值就可以把任务提交给线程池，由线程池分配线程执行任务了。</p>
<h3 id="7-其他；"><a href="#7-其他；" class="headerlink" title="7.其他；"></a>7.其他；</h3><h4 id="设计滑动库存分布式锁处理活动秒杀，主要是关于秒杀的场景如何实现？"><a href="#设计滑动库存分布式锁处理活动秒杀，主要是关于秒杀的场景如何实现？" class="headerlink" title="设计滑动库存分布式锁处理活动秒杀，主要是关于秒杀的场景如何实现？"></a>设计滑动库存分布式锁处理活动秒杀，主要是关于秒杀的场景如何实现？</h4><p>用户领取活动时，需要保证库存的数量不会发生超卖现象。</p>
<p><strong>数据库-redis</strong></p>
<p>由于秒杀操作会有大量的请求访问和修改库存信息，如果直接操作数据库会把数据库搞崩，因此为了提高性能，就会把库存信息保存到redis中，先对redis中库存进行操作，然后在合适的时候同步数据库。</p>
<p><strong>锁-锁粒度</strong></p>
<p>为了避免超卖问题，需要使用分布式锁来处理库存扣减的问题。</p>
<p>分布式锁一般会使用redis的setnx命令来实现，在加锁的时候设置key值，如果设置成功说明加锁成功并执行秒杀操作，如果设置失败说明该锁被占用，秒杀失败。</p>
<p>为了提高并发量，需要尽可能的降低锁的粒度。</p>
<p>一般来说不会对整个业务进行加锁，因为这样会导致很多操作失败的情况。对于秒杀操作，可以把key值设置为活动id+库存余量作为分布式锁，这样就缩小了锁的颗粒度。每次申请锁时，都会减少对应的库存，这样每次申请到的都是不同的锁，这样就可以实现高并发了。</p>
<p><strong>处理数据一致性</strong></p>
<p>因为秒杀操作只对redis中的库存信息进行修改，因此最终还是要实现数据库数据的一致性。</p>
<p>这里有两种解决方法：</p>
<p>1.每次秒杀成功都往MQ里面发送消息，然后在消费端对数据库中的库存进行处理，起到削峰的作用。</p>
<p>2.开启一个定时任务，定时的去处理缓存和数据库库存同步。</p>
<p>两种方法的区别在于，消息队列对数据库的操作次数会比较多，但是实时性会比定时任务好。</p>
<h3 id="DDD架构分布式"><a href="#DDD架构分布式" class="headerlink" title="DDD架构分布式"></a>DDD架构分布式</h3><p>application</p>
<p>应用层{application}</p>
<p><strong>应用服务位于应用层。可对微服务内的领域服务以及微服务外的应用服务进行组合和编排，负责处理业务用例的执行顺序以及结果的拼装。</strong></p>
<p>doDrawProcess(DrawProcessReq req)  领取活动-&gt;执行抽奖-&gt;结果落库-&gt;发送MQ，触发发奖流程-&gt;返回结果</p>
<p>应用层的服务包括应用服务和领域事件相关服务。<br>应用服务可对微服务内的领域服务以及微服务外的应用服务进行组合和编排，或者对基础层如文件、缓存等数据直接操作形成应用服务，对外提供粗粒度的服务。<br>领域事件服务包括两类：领域事件的发布和订阅。通过事件总线和消息队列实现异步数据传输，实现微服务之间的解耦。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230925132111337.png" alt="image-20230925132111337" style="zoom:80%;" />

<p>common</p>
<p>公用模块 common</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230925132212221.png" alt="image-20230925132212221" style="zoom:67%;" />

<p>domain</p>
<p>领域层{domain}<br>领域服务位于领域层，为完成领域中跨实体或值对象的操作转换而封装的服务，领域服务以与实体和值对象相同的方式参与实施过程。<br>领域服务对同一个实体的一个或多个方法进行组合和封装，或对多个不同实体的操作进行组合或编排，对外暴露成领域服务。领域服务封装了核心的业务逻辑。实体自身的行为在实体类内部实现，向上封装成领域服务暴露。<br>为隐藏领域层的业务逻辑实现，所有领域方法和服务等均须通过领域服务对外暴露。<br>为实现微服务内聚合之间的解耦，原则上禁止跨聚合的领域服务调用和跨聚合的数据相互关联。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230925132237062.png" alt="image-20230925132237062" style="zoom:67%;" />

<p>infrastructure</p>
<p>基础层{infrastructrue}<br>基础服务位于基础层。为各层提供资源服务（如数据库、缓存等），实现各层的解耦，降低外部资源变化对业务逻辑的影响。<br>基础服务主要为仓储服务，通过依赖反转的方式为各层提供基础资源服务，领域服务和应用服务调用仓储服务接口，利用仓储实现持久化数据对象或直接访问基础资源。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230925132322854.png" alt="image-20230925132322854" style="zoom:67%;" />

<p>interface</p>
<p>接口层{interfaces}<br>接口服务位于用户接口层，用于处理用户发送的请求，交给应给，然后将数据封装为符合RPC传输的对象。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230925132348181.png" alt="image-20230925132348181" style="zoom:67%;" />

<p>对于该微服务来说，服务端总的只提供两个接口</p>
<p>1.doDraw（指定活动抽奖）：1.执行抽奖，2.数据转换，3.数据封装</p>
<p>2.doQuantificationDraw（量化人群抽奖）：执行规则引擎，获取用户可以参与的活动号，1.执行抽奖，2.数据转换，3.数据封装</p>
<p>这里的数据转换主要是指把接口的转化为RPC</p>
<p>rpc</p>
<p>对外提供接口描述信息</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230925132448917.png" alt="image-20230925132448917" style="zoom: 80%;" />



<p>实体类</p>
<p>aggregate </p>
<p>req </p>
<p>res </p>
<p>vo</p>
<p>po </p>
<p>dto</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20231030002217252.png" alt="image-20231030002217252"  />

<h2 id="二-手写RPC"><a href="#二-手写RPC" class="headerlink" title="二.手写RPC"></a>二.手写RPC</h2><p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230925115812275.png" alt="image-20230925115812275"></p>
<h3 id="项目介绍："><a href="#项目介绍：" class="headerlink" title="项目介绍："></a>项目介绍：</h3><p>rpc框架可以实现不同微服务之间的调用像本地调用一样简单。</p>
<p>这个手写rpc框架主要实现5个模块</p>
<p>1.注册中心，注册中心负责服务地址的注册与查找。</p>
<p>2.网络传输协议，这部分底层直接使用的tcp协议，然后在上层使用了自定义的传输协议。</p>
<p>3.序列化与反序列化，实现了在网络中快速传输对象。</p>
<p>4.客户端stub，客户端stub是在该微服务作为客户端调用远程方法的角度设计的，它完成的功能主要是屏蔽调用的细节。</p>
<p>5.服务端stub，服务端stub是在该微服务作为服务端提供方法服务的角度设计的，它完成的功能主要是服务的注册和调用。</p>
<p>虽然这个手写RPC跟成熟的RPC框架相比只是完成了最基本的功能，但是通过自己实现rpc框架让我确实是更好的理解了微服务的概念。</p>
<h3 id="什么是RPC，它的原理和作用"><a href="#什么是RPC，它的原理和作用" class="headerlink" title="什么是RPC，它的原理和作用"></a>什么是RPC，它的原理和作用</h3><h4 id="RPC定义"><a href="#RPC定义" class="headerlink" title="RPC定义"></a>RPC定义</h4><p><strong>RPC</strong>(Remote Procedure Call**)即远程过程调用，通过RPC可以像调用本地方法一样调用远程计算机上某个服务的方法。**</p>
<p>使用RPC框架的原因在于，两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数和方法调用的结果。但是，如果我们自己手动网络编程来实现这个调用过程的话工作量是非常大的，因为，我们需要考虑底层传输方式(TCP还是UDP)、序列化方式，服务发现等等方面。</p>
<p>举个例子：两个不同的服务A、B部署在两台不同的机器上，服务A如果想要调用服务B中的某个方法的话就可以通过RPC来做。</p>
<h4 id="RPC原理"><a href="#RPC原理" class="headerlink" title="RPC原理"></a>RPC原理</h4><p><strong>1.客户端（服务消费端）</strong>：调用远程方法的一端。<br><strong>2.客户端Stub（桩）</strong>：这其实就是一代理类。代理类主要做的事情很简单，就是把你调用方法、类、方法参数等信息传递到服务端。代理类：屏蔽很多细节，封装请求体，调用具体的网络传输服务获取响应体。<br><strong>3.网络传输</strong>：网络传输就是你要把你调用的方法的信息比如说参数啊这些东西传输到服务端，然后服务端执行完之后再把返回结果通过网络传输给你传输回来。网络传输的实现方式有很多种比如最基本的Socket或者性能以及封装更加优秀的Netty（推荐）。<br><strong>4.服务端Stub（桩）</strong>：这个桩就不是代理类了。我觉得理解为桩实际不太好，大家注意一下就好。这里的服务端Sub实际指的就是接收到客户端执行方法的请求后，去指定对应的方法然后返回结果给客户端的类。<br><strong>5.服务端（服务提供端）</strong>：提供远程方法的一端。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230817165417137.png" alt="image-20230817165417137" style="zoom:80%;" />

<p>1.服务消费端(client)以本地调用的方式调用远程服务；<br>2.客户端Stub(client stub)接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：RpcRequest;<br>3.客户端Stub(client stub)找到远程服务的地址，并将消息发送到服务提供端；<br>4.服务端Stub（桩）收到消息将消息反序列化为Java对象：RpcRequest;<br>5.服务端Stub（桩）根据RpcRequest中的类、方法、方法参数等信息调用本地的方法；<br>6.服务端Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：RpcResponse（序列化）发送至消费方；<br>7.客户端Stub(client stub)接收到消息并将消息反序列化为Java对象：RpcResponse,这样也就得到了最终结果。over!</p>
<h4 id="有HTTP，为什么还要RPC"><a href="#有HTTP，为什么还要RPC" class="headerlink" title="有HTTP，为什么还要RPC"></a>有HTTP，为什么还要RPC</h4><p><a href="https://mp.weixin.qq.com/s/V7qg5jsYgCwK8D68ZFGyuw">https://mp.weixin.qq.com/s/V7qg5jsYgCwK8D68ZFGyuw</a></p>
<p>HTTP与RPC的区别</p>
<p>1.HTTP是一种协议，而RPC是一种调用方式，没有具体的协议，它的底层可以TCP和HTTP</p>
<p>2.服务发现，HTTP可以通过域名+DNS服务获取ip地址；而 RPC 的话，一般会有专门的中间服务去保存服务名和 IP 信息，比如Redis和ZooKeeper</p>
<p>3.传输的内容，在HTTP中是消息头+消息体的形式；而RPC 可以自定义传输协议，一般需要考虑粘包和序列化问题。</p>
<p>既然有 HTTP 协议为什么要有 RPC ？</p>
<p>1.首先Http大多用于B&#x2F;S架构，为了实现浏览器之间的兼容，需要有个统一的标准也就是http，因此http协议的功能会尽可能的完备，所以http消息头的信息冗余且复杂。</p>
<p>2.而在公司内部微服务则使用 RPC ，主要是因为RPC可以自定义传输协议，不需要像 HTTP 那样考虑各种浏览器行为，因此，一个设计良好的RPC性能会比http好。</p>
<h3 id="常见RPC框架"><a href="#常见RPC框架" class="headerlink" title="常见RPC框架"></a>常见RPC框架</h3><p>Dubbo：Dubbo提供了服务定义，服务发现、流量管控等几乎所有的服务治理能力</p>
<p>gRPC：gRPC是Google开源的一个高性能、通用的开源RPC框架。基于ProtoBuf序列化协议开发，并且支持众多开发语言。</p>
<p><strong>何谓ProtoBuf</strong>?ProtoBuf(Protocol Buffer)是一种更加灵活、高效的数据格式，可用于通讯协议、数据存储等领域，基本支持所有主流编程语言且与平台无关。不过，gRPC的设计导致其几乎没有服务治理能力。</p>
<h3 id="基于Netty-kryo-Zookeeper的RPC框架"><a href="#基于Netty-kryo-Zookeeper的RPC框架" class="headerlink" title="基于Netty+kryo+Zookeeper的RPC框架"></a>基于Netty+kryo+Zookeeper的RPC框架</h3><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230817172445879.png" alt="image-20230817172445879" style="zoom:80%;" />

<p>一般情况下，RPC框架不仅要提供服务发现功能，还要提供负载均衡、序列化等功能，这样的RPC框架才算真正合格的。</p>
<p>服务提供端Server向注册中心注册服务，服务消费者Client通过注册中心拿到服务相关信息，然后再通过网络请求服务提供端Server。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230817172433424.png" alt="image-20230817172433424" style="zoom:80%;" />

<p>Provider:暴露服务的服务提供方<br>Consumer:调用远程服务的服务消费方<br>Registry:服务注册与发现的注册中心<br>Monitor:统计服务的调用次数和调用时间的监控中心<br>Container:服务运行容器</p>
<p>1.服务容器负责启动，加载，运行服务提供者。<br>2.服务提供者在启动时，向注册中心注册自己提供的服务。<br>3.服务消费者在启动时，向注册中心订阅自己所需的服务。<br>4.注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。<br>5.服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>
<h4 id="框架的组成部分："><a href="#框架的组成部分：" class="headerlink" title="框架的组成部分："></a>框架的组成部分：</h4><p><strong>注册中心</strong></p>
<p>Zookeeper或者Nacos</p>
<p><strong>注册中心负责服务地址的注册与查找，相当于目录服务。</strong>服务端启动的时候将服务名称及其对应的地址ip+port注册到注册中心，客户端根据服务名称找到对应的服务地址。有了服务地址之后，服务消费端就可以通过网络请求服务端了。</p>
<p><strong>网络传输</strong></p>
<p>Netty开发框架，本质是TCP协议。</p>
<p>1.Netty是一个基于NIo的client-server（客户端服务器）框架，使用它可以快速简单地开发网络应用程序。<br>2.它极大地简化TCP和UDP套接字服务器等网络编程，并且性能以及安全性等很多方面甚至都要更好。</p>
<p><strong>序列化与反序列化</strong></p>
<p>为什么需要序列化？</p>
<p>要在网络传输数据就要涉及到序列化。因为网络传输的数据必须是二进制的。因此，我们的java对象没办法直接在网络中传输。为了能够让Java对象在网络中传输我们需要将其序列化为二进制的数据。我们最终需要的还是目标java对象，因此我们还要将二进制的数据“解析”为目标Java对象，也就是对二进制数据再进行一次反序列化。</p>
<p>JDK自带的序列化，只需实现java.io.Serializable接口即可，不过这种方式不推荐，因为不支持跨语言调用并且性能比较差。现在比较常用序列化的有json、kryo。</p>
<p><strong>客户端stub</strong><br>使用动态代理。当你调用远程方法的时候，实际会通过代理对象来传输网络请求，调用远程方法像调用本地方法一样简单，我们不需要关心远程方法调用的细节比如网络传输，保证请求和响应消息，获取服务地址等等。</p>
<p><strong>服务端stub</strong></p>
<p>服务端需要一个服务提供者实现将自己的服务注册到注册中心中，并且在接收到客户端执行方法的请求后，去指定对应的方法然后返回结果给客户端的类。</p>
<p>提供服务的方法的对象储存到一个容器中(map)，并根据请求消息从容器中获取对象执行方法得到结果。</p>
<p><strong>负载均衡</strong></p>
<p>避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题。</p>
<h3 id="Netty开发框架（网络传输）"><a href="#Netty开发框架（网络传输）" class="headerlink" title="Netty开发框架（网络传输）"></a>Netty开发框架（网络传输）</h3><h4 id="netty介绍"><a href="#netty介绍" class="headerlink" title="netty介绍"></a>netty介绍</h4><h4 id="传输实体类"><a href="#传输实体类" class="headerlink" title="传输实体类"></a>传输实体类</h4><p>我们首先定义两个对象，这两个对象是客户端与服务端进行交互的实体类。客户端将RpcRequest类型的对象发送到服务端，服务端进行相应的处理之后将得到结果RpcResponse对象返回给客户端。</p>
<p><strong>请求实体类</strong> RpcRequest</p>
<p><strong>响应实体类</strong> RpcResponse</p>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p><strong>NettyClient</strong></p>
<p>客户端中主要有一个用于向服务端发送消息的sendMessage（）方法，通过这个方法你可以将消息也就是RpcRequest对象发送到服务端，并且你可以同步获取到服务端返回的结果也就是RpcResponse对象。</p>
<p><strong>自定义ChannelHandler处理服务端消息</strong></p>
<p>设置channel的读操作，NettyClientHandler用于读取服务端发送过来的RpcResponse消息对象。</p>
<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p><strong>NettyServer</strong><br>主要作用就是开启了一个服务端用于接受客户端的请求并处理。</p>
<p><strong>自定义ChannelHandler处理客户端消息</strong></p>
<p>设置channel的读操作，NettyServerHandler用于接收客户端发送过来的消息，调用本地方法并在channel中返回结果给客户端。</p>
<h4 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h4><p>这里需要调用序列化方法，需要注意编码器跟序列化器的功能是不一样的，编码器包括对协议进行解析。</p>
<p><strong>自定义编码器</strong><br>NettyKryoEncoder是我们自定义的编码器。它负责处理”出站”消息，将消息格式转换为字节数组然后写入到字节数据的容器ByteBuf对象中。除此之外，为了避免粘包问题和校验包的完整性，在ByteBuf对象中添加消息长度的消息头。</p>
<p><strong>自定义解码器</strong><br>NettyKryoDecoder是我们自定义的解码器。它负责处理”入站”消息，它会从ByteBuf中读取到业务对象对应的字节序列，然后再将字节序列转换为我们的业务对象。</p>
<h3 id="手写rpc源码分析（分模块）"><a href="#手写rpc源码分析（分模块）" class="headerlink" title="手写rpc源码分析（分模块）"></a>手写rpc源码分析（分模块）</h3><h4 id="序列化模块（serialize包）"><a href="#序列化模块（serialize包）" class="headerlink" title="序列化模块（serialize包）"></a>序列化模块（serialize包）</h4><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230826235412026.png" alt="image-20230826235412026" style="zoom:80%;" />

<p>Serializer包括序列化方法和反序列化方法</p>
<p>序列化的作用：netty使用ByteBuf传输数据，其内部是一个字节数组，在编码器中设置ByteBuf包括消息头和消息体，其中消息体就是传输的java对象，需要通过序列化方法转化为二进制数组放到ByteBuf中。</p>
<h4 id="负载均衡模块-loadbalance包"><a href="#负载均衡模块-loadbalance包" class="headerlink" title="负载均衡模块(loadbalance包)"></a>负载均衡模块(loadbalance包)</h4><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230826235634027.png" alt="image-20230826235634027" style="zoom:80%;" />

<p>LoadBalance:负载均衡，从服务列表中挑选一个合适服务器地址</p>
<p>RandomLoadBalance:随机挑选</p>
<p>哈希一致性算法</p>
<h4 id="注册中心模块（registry包）"><a href="#注册中心模块（registry包）" class="headerlink" title="注册中心模块（registry包）"></a>注册中心模块（registry包）</h4><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230826233712026.png" alt="image-20230826233712026" style="zoom:80%;" />

<p><strong>util：</strong></p>
<ul>
<li>CuratorUtils：操作zookeeper的工具类</li>
</ul>
<p>ZkServiceDiscovery-&gt;(LoadBalance):在获取服务的套接字的时候，有时对应的服务有多个套接字（分布式），需要通过负载均衡策略选择具体的服务主体。</p>
<p>ZkServiceRegistry:ServiceRegistry的实现类,&#x2F;myrpc&#x2F;interface name + version + group&#x2F;inetSocketAddress</p>
<p>ServiceDiscovery:提供一个根据服务名从注册中心获取套接字的方法</p>
<p>ServiceRegistry:提供一个将服务名和对应套接字放到注册中心的方法</p>
<h4 id="服务提供模块-provider包"><a href="#服务提供模块-provider包" class="headerlink" title="服务提供模块(provider包)"></a>服务提供模块(provider包)</h4><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230826235555115.png" alt="image-20230826235555115" style="zoom:80%;" />

<p>ServiceProvider-&gt;(Map&lt;String, Object&gt; serviceMap,ServiceRegistry)：服务对象的容器类，负责对提供的服务对象进行管理，根据接口名添加，查找和发布服务。注：这里将提供服务的对象储存到serviceMap的方法有两种方式，一种是在NettyServer的构造方法中，即启动服务端时绑定服务（手动不推荐）；另一种是使用注解的方法，在下面解释。</p>
<h4 id="spring容器模块-spring，annotation包"><a href="#spring容器模块-spring，annotation包" class="headerlink" title="spring容器模块(spring，annotation包)"></a>spring容器模块(spring，annotation包)</h4><p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230827000556673.png" alt="image-20230827000556673" style="zoom:80%;" /><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230827000601192.png" alt="image-20230827000601192" style="zoom:80%;" /></p>
<p>SpringBeanPostProcessor-&gt;(serviceProvider):继承Spring容器中的BeanPostProcessor，重写其中的postProcessBeforeInitialization方法，在每个bean被初始化之前判断该bean是否有RpcService注解，如果有则把对应的方法信息注册到zookeeper中，实现自动注册。</p>
<p>RpcService:一个注解类，且该注解类被@component修饰那么被RpcService注解的类也会被spring容器管理。用于标识服务端提供方法的类。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230831230854165.png" alt="image-20230831230854165" style="zoom:80%;" />

<h4 id="网络传输模块-remote包"><a href="#网络传输模块-remote包" class="headerlink" title="网络传输模块(remote包)"></a>网络传输模块(remote包)</h4><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230826233110101.png" alt="image-20230826233110101" style="zoom:80%;" />

<p><strong>dto</strong>：</p>
<ul>
<li><p>RpcMessageChecker：提供校验方法，校验请求参数和响应参数的请求Id是否一致，响应参数的响应码是否成功</p>
</li>
<li><p>RpcRequest：请求体实体，继承序列化接口。属性如下</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230828111812748.png" alt="image-20230828111812748" style="zoom:80%;" />
</li>
<li><p>RpcResponse：响应体参数，继承序列化接口。属性包括：serialVersionUID，requestId，code，message，data(方法返回值)</p>
</li>
</ul>
<p><strong>handler</strong>：（服务端相关）</p>
<ul>
<li>RpcRequestHandler -&gt;（ServiceProvider）：根据请求体中的方法信息，利用反射调用服务端的提供的服务(具体方法)，写在外层（不在transport包）的原因是他跟具体的传输框架无关。</li>
</ul>
<p><strong>transport</strong>：</p>
<ul>
<li><p><strong>netty</strong>：</p>
<ul>
<li><p><strong>client</strong>:</p>
<ul>
<li><p>NettyClient-&gt;(Bootstrap,EventLoopGroup):<strong>netty框架类</strong>，netty的客户端类，负责客户端netty网络传输的启动和配置。提供一个dochannel方法，根据套接字启动连接并返回channel对象。</p>
</li>
<li><p>ChannelProvider-&gt;（Map&lt;String, Channel&gt;，NettyClient）:channel的容器类，负责对开启的channel对象进行管理，根据套接字添加，查找和删除channel。从容器中获取channel时，会查看是否存在相同套接字的channel，如果有就直接复用，如果没有或者channel失效了就调用dochannel方法创建channel。</p>
</li>
<li><p>UnprocessedRequests-&gt;(Map&lt;String, CompletableFuture&lt;RpcResponse<Object>&gt;&gt;):暂存未被处理的请求（线程），根据请求Id添加请求和处理请求（线程）。</p>
</li>
<li><p>NettyClientHandler-&gt;(UnprocessedRequests,ChannelProvider):<strong>netty框架类</strong>，继承ChannelInboundHandlerAdapter，会被添加到channel的执行链中，提供一个channelRead方法，负责处理从channel读取服务端发过来的消息(RpcResponse)的后续操作，实际上在这里将response消息并放到请求线程中。</p>
</li>
<li><p>NettyClientTransport-&gt;（ServiceDiscovery,UnprocessedRequests,ChannelProvider）:ClientTransport的实现类，实现了sendRpcRequest接口。实现的流程包括，创建请求线程-&gt;根据请求体中的信息到注册中心查找对应服务的套接字-&gt;根据套接字获取或添加对应的channel-&gt;将请求线程添加到UnprocessedRequests中，调用channal的write方法写入请求，这个写入过程由异步调用并通过回调函数对失败成功做处理，（这里并没有从channel中读取response消息并放到请求线程中，处理响应消息交给NettyClientHandler）。</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230828122649067.png" alt="image-20230828122649067"></p>
<p>如果在send发送完数据之后对channel进行手动阻塞等待返回Response，这样会导致Event Loop阻塞导致效率下降。优化后使用CompletableFuture包装Response实现线程同步，避免了Event Loop阻塞。</p>
<p>不通过连接关闭事件让 eventloop 设置 rpcResponse 和 proxy 所在的线程获取 rpcResposne 同步。就像文章说的这种做法“不太清晰”，因为本身它们没有必然联系。通过自定义的 CompletableFuture 让线程间同步更加合适</p>
<p><strong>使用CompletableFutrue的好处：</strong></p>
<p>1.不阻塞eventloop，在之前的发送请求操作中需要对channel进行手动阻塞等待返回Response，这样会导致Event Loop阻塞导致效率下降。使用CompletableFuture可以通过异步编程的方式，把阻塞等待返回Response的过程交给异步线程处理，解放Event Loop线程继续执行流程代码，在业务流程中真正需要用到Response再同步等待异步线程执行结果。</p>
<p>2.利用异步编程执行耗时操作，加快程序执行效率，然后利用回调函数或者同步方法获取异步线程的执行结果。</p>
</li>
</ul>
</li>
<li><p>codec.kyro</p>
<ul>
<li>NettyKryoDecoder-&gt;():<strong>netty框架类</strong>，继承ByteToMessageDecoder。解码 ByteBuf 对象,跟设计的协议有关，这里包括消息长度和消息体，消息长度是为了校验包的完整性。</li>
<li>NettyKryoEncoder-&gt;():<strong>netty框架类</strong>,继承MessageToByteEncoder。将对象转换为字节码然后写入到 ByteBuf 对象中，同样根据协议写入消息长度和消息体。</li>
</ul>
</li>
<li><p>server</p>
<ul>
<li>NettyServer-&gt;(KryoSerializer,ServiceProvider)：<strong>netty框架类</strong>，netty的服务端类，负责服务端netty网络传输的启动和配置，并绑定服务端监听端口。</li>
<li>NettyServerHandler-&gt;(RpcRequestHandler):<strong>netty框架类</strong>，ChannelInboundHandlerAdapter，会被添加到channel的执行链中，提供一个channelRead方法，负责处理从channel读取客户端发过来的消息(RpcRequest)，调用RpcRequestHandler调用服务端提供的方法处理消息返回结果(rpcResponse)，然后写入channel中。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>socket</strong>：提供基于socket的传输方式</p>
</li>
<li><p><strong>ClientTransport</strong>：传输接口<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230828123106186.png" alt="image-20230828123106186" style="zoom:80%;" /></p>
</li>
</ul>
<h4 id="客户端动态代理模块-proxy包"><a href="#客户端动态代理模块-proxy包" class="headerlink" title="客户端动态代理模块(proxy包)"></a>客户端动态代理模块(proxy包)</h4><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230827000619257.png" alt="image-20230827000619257" style="zoom:80%;" />

<p>动态代理：</p>
<p>RpcClientProxy-&gt;(ClientTransport)：</p>
<p>1.首先，在客户端中只提供服务端的服务方法的接口，没有其实现类，这也是为什么需要rpc的原因</p>
<p>2.从业务的角度看，该代理类可以代理所有服务端的服务方法的实现类，使得我们在编写代码是可以像存在实现类一样，获取对应的接口实现类对象(代理对象)并调用对应接口方法。</p>
<p>3.从实现的角度看，该代理类使用jdk动态代理技术，代理对象($proxy)实现了接口类，同时在代理方法(invoke)中调用ClientTransport的sendRpcRequest方法进行远程通信。（具体见下）</p>
<p>4.除此之外，代理方法还可以屏蔽很多细节，封装请求体，调用具体的网络传输服务获取响应体。</p>
<h4 id="通用设置模块-config包"><a href="#通用设置模块-config包" class="headerlink" title="通用设置模块(config包)"></a>通用设置模块(config包)</h4><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230827000523416.png" alt="image-20230827000523416" style="zoom:80%;" />

<p>Runtime.getRuntime().addShutdownHook是一个Java的方法，它用于向Java虚拟机添加一个在JVM关闭时执行的线程。当JVM接收到终止信号时，这个钩子线程将被线程调度器调用并执行。</p>
<h4 id="通用模块"><a href="#通用模块" class="headerlink" title="通用模块"></a>通用模块</h4><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230901174319846.png" alt="image-20230901174319846" style="zoom:80%;" />

<p>单例工厂类：</p>
<p>1.使用的是双重检查锁模式</p>
<p>2.它的作用和spring容器（实际上用spring容器好一点，因为可以使用注解）这里为了尽量避免使用框架才使用自己的单例工厂，因此每个单例中的无参构造器中都需要自己手动依赖注入。</p>
<p>3.NettyClient的启动在构造函数中，因此在单例工厂第一次创建NettyClient时就会启动NettyClient，与之相反的是NettyServer，NettyServer的启动需要调用start函数，不在构造函数中。</p>
<h4 id="测试模块"><a href="#测试模块" class="headerlink" title="测试模块"></a>测试模块</h4><p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230827000900469.png" alt="image-20230827000900469" style="zoom: 60%;" /><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230827000907950.png" alt="image-20230827000907950" style="zoom: 60%;" /><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230827001235654.png" alt="image-20230827001235654" style="zoom:60%;" /></p>
<h5 id="service-api"><a href="#service-api" class="headerlink" title="service-api:"></a>service-api:</h5><p>在该层中提供服务端提供的服务类，实体类。例如，服务端提供一个Result hello(Hello hello)，那么api层里需要一个hello接口和一个Hello类和Result类。</p>
<h5 id="client"><a href="#client" class="headerlink" title="client:"></a>client:</h5><h5 id="server"><a href="#server" class="headerlink" title="server:"></a>server:</h5><p>需要调用start函数，启动server</p>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>注：这里无法使用AOP替代动态代理，动态代理不等于AOP。AOP的实现依赖动态代理，但是AOP的作用一般用来增强某个方法，而不是用于生成代理对象。</p>
<p>例如，Controller需要使用到Service的方法，但是客户端没有对应的Service方法（只有接口没有），需要去服务端请求。</p>
<p>1.正常情况下，需要在客户端中为每个接口编写实现类，然后在实现类中完成去服务端请求，造成类冗余。</p>
<p>2.使用JDK动态代理可以减少这部分代码的编写，在Controller中使用不同的接口的代理实现类，这些代理实现类都完成一个功能，就是去服务端请求数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHello</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloController helloController;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHello</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        helloController.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    String <span class="title function_">hello</span><span class="params">(Hello hello)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloServiceImpl被创建&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(Hello hello)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloServiceImpl收到: &quot;</span>+ hello.getMessage());</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;Hello description is &quot;</span> + hello.getDescription();</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloServiceImpl返回: .&quot;</span>+ result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcReference &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service version, default value is empty string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">version</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service group, default value is empty string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">group</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = bean.getClass();</span><br><span class="line">        Field[] declaredFields = targetClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">            <span class="type">RpcReference</span> <span class="variable">rpcReference</span> <span class="operator">=</span> declaredField.getAnnotation(RpcReference.class);</span><br><span class="line">            <span class="keyword">if</span> (rpcReference != <span class="literal">null</span>) &#123;</span><br><span class="line">                Class&lt;?&gt; type = declaredField.getType();<span class="comment">//HelloService</span></span><br><span class="line">                <span class="comment">//RpcClientProxy rpcClientProxy = new RpcClientProxy(rpcClient, rpcServiceConfig);</span></span><br><span class="line">                <span class="comment">//Object clientProxy = rpcClientProxy.getProxy(declaredField.getType());</span></span><br><span class="line">                <span class="comment">//get里面调用了newProxyInstance</span></span><br><span class="line">                declaredField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    declaredField.set(bean, <span class="keyword">new</span> <span class="title class_">HelloServiceImpl</span>());</span><br><span class="line">                    <span class="comment">//declaredField.set(bean, clientProxy);</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RpcReference(version = &quot;version1&quot;, group = &quot;test1&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="built_in">this</span>.helloService.hello(<span class="keyword">new</span> <span class="title class_">Hello</span>(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>));</span><br><span class="line">        <span class="comment">//如需使用 assert 断言，需要在 VM options 添加参数：-ea</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="string">&quot;Hello description is 222&quot;</span>.equals(hello);</span><br><span class="line">        Thread.sleep(<span class="number">12000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(helloService.hello(<span class="keyword">new</span> <span class="title class_">Hello</span>(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 BeanPostProcessor解决jdk动态代理对象无法通过依赖注入(Autowire&#x2F;Resourse)的方式，给spring bean的属性自动注入的问题。</p>
<p>1.BeanPostProcessor的postProcessAfterInitialization会在bean初始化之后执行，因此可以在这个方法中扫描Controller类的成员变量，然后为这些成员变量赋值。</p>
<p>2.在Controller中需要实例化一个service对象，可以对需要代理对象的成员变量加上自定义注解进行标注。然后在postProcessAfterInitialization中为service创建代理对象，完成初始化。</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230902001327015.png" alt="image-20230902001327015" style="zoom:80%;" />

<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230902001334163.png" alt="image-20230902001334163" style="zoom:80%;" />

<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230902004446409.png" alt="image-20230902004446409" style="zoom:80%;" />



<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230902004849183.png" alt="image-20230902004849183" style="zoom:80%;" />



<h4 id="哈希一致性算法"><a href="#哈希一致性算法" class="headerlink" title="哈希一致性算法"></a>哈希一致性算法</h4><p><a href="https://blog.csdn.net/a745233700/article/details/120814088">https://blog.csdn.net/a745233700/article/details/120814088</a></p>
<h5 id="普通hash算法"><a href="#普通hash算法" class="headerlink" title="普通hash算法"></a>普通hash算法</h5><ul>
<li><p>普通hash算法的内容和使用场景</p>
</li>
<li><p>普通哈希算法的缺陷</p>
<p>当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端服务器请求数据；</p>
</li>
</ul>
<h5 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h5><ul>
<li><p>一致性哈希算法的内容</p>
<p>步骤1：一致性哈希算法将整个哈希值空间按照顺时针方向组织成一个虚拟的圆环，称为 Hash 环；</p>
<p>步骤2：接着将各个服务器使用 Hash 函数进行哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，从而确定每台机器在哈希环上的位置</p>
<p>步骤3：最后使用算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针寻找，第一台遇到的服务器就是其应该定位到的服务器</p>
</li>
<li><p>一致性 hash 算法的优点</p>
<p>一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，只有部分缓存会失效，不至于将所有压力都在同一时间集中到后端服务器上，具有较好的容错性和可扩展性。</p>
</li>
<li><p>hash 环的倾斜与虚拟节点</p>
<p>一致性哈希算法在服务节点太少的情况下，容易因为节点分部不均匀而造成数据倾斜问题，也就是被缓存的对象大部分集中缓存在某一台服务器上，从而出现数据分布不均匀的情况，这种情况就称为 hash 环的倾斜。</p>
<p>为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点</p>
</li>
</ul>
<h5 id="项目-Dubbo哈希一致性源码"><a href="#项目-Dubbo哈希一致性源码" class="headerlink" title="项目&#x2F;Dubbo哈希一致性源码"></a>项目&#x2F;Dubbo哈希一致性源码</h5><p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230902200905676.png" alt="image-20230902200905676"></p>
<p>数据结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConsistentHashLoadBalance</span>&#123;</span><br><span class="line">ConcurrentHashMap&lt;String, ConsistentHashSelector&gt; selectors = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConsistentHashSelector</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, String&gt; virtualInvokers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> identityHashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>selectors：键为服务的名称(serviceName)，值为选择器类(CHselector)，选择器类的作用是返回方法匹配的服务器ip地址</p>
<p>virtualInvokers：键为hash值，这个hash值通过对ip+端口+编号进行md5算法得到；值为ip+端口，也就是具体服务的ip地址信息。注：这是一个二叉搜索树，目的就是为了实现一致性 hash 算法中定位最近服务器的功能。</p>
<p>virtualInvokers给每个ip地址都配置了160个虚拟结点，通过编号的形式，作用是为了防止环倾斜。</p>
<p>identityHashCode：每个服务都会对应多个服务器ip地址，使用List储存，identityHashCode则是List的哈希值，如果List的内容发生变化就会得到不同的hashcode，对应一致性 hash 算法中服务器地址发生变化的情况。</p>
<p>输入：服务方法名，服务参数，ip地址List</p>
<p>输出：负载均衡后的ip地址</p>
<p>1.根据服务方法名获取CHselector，对ip地址List进行hash得到identityHashCode，判断selectors中的identityHashCode是否一致，如果不一致就需要重新创建CHselector了</p>
<p>2.对服务方法名+服务参数的内容进行hash得到一个code，然后在virtualInvokers中搜索&gt;code的第一个值返回。</p>
<h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><h4 id="如果你节点直接宕机了或者网络断了，客户端怎么感知呢？"><a href="#如果你节点直接宕机了或者网络断了，客户端怎么感知呢？" class="headerlink" title="如果你节点直接宕机了或者网络断了，客户端怎么感知呢？"></a>如果你节点直接宕机了或者网络断了，客户端怎么感知呢？</h4><p>一.利用zookeeper（回调函数和心跳机制）</p>
<p>1.首先zookeeper是使用这种目录树的结构储存数据的，它的每个结点都可以储存数据，这些节点称为znode。</p>
<p>2.通过zookeeper提供的Watcher（事件监听器）</p>
<p>ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，客户端会执行监听器中的回调方法。</p>
<p>因此，在服务端注册服务的同时，给结点注册一个监听器，监听节点变化的事件，然后在回调函数中重新获取最新的节点信息，这样客户端就能及时获取最新节点了。</p>
<p>curatorutil 在zookeeper注册结点时调用</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230906153708828.png" alt="image-20230906153708828" style="zoom:80%;" />

<p>3.zookeeper数据结点znode有一种叫临时结点的类型，它会与客户端保持一个会话，会话通过心跳机制来检测存活。如果会话死亡则节点消失，而结点消失就会触发zookeeper的Watcher机制，通知客户端更新节点信息。</p>
<p>二.微服务本身</p>
<p>服务端服务下线时通过一个钩子函数（多线程里面的shutdownhook）清除zookeeper中该服务的相关结点</p>
<h4 id="协议是如何设计的"><a href="#协议是如何设计的" class="headerlink" title="协议是如何设计的"></a>协议是如何设计的</h4><p>首先，netty的底层是TCP协议，虽然netty使用channel去传输和处理数据，但是其本身还是基于字节流的。为了解决TCP的粘包问题，使用消息头+消息体的方式。</p>
<p>其中消息头是</p>
<p>然后消息体是使用Kryo序列化的请求对象或者响应对象，请求对象中包含</p>
<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20230929222406133.png" alt="image-20230929222406133" style="zoom:80%;" />

<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20231012232551470.png" alt="image-20231012232551470" style="zoom: 80%;" />

<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20231012232137902.png" alt="image-20231012232137902" style="zoom:80%;" />

<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20231012232416945.png" alt="image-20231012232416945" style="zoom:67%;" />

<img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/image-20231012232436254.png" alt="image-20231012232436254" style="zoom:80%;" />

<h4 id="使用了哪些方法去提高框架的性能"><a href="#使用了哪些方法去提高框架的性能" class="headerlink" title="使用了哪些方法去提高框架的性能"></a>使用了哪些方法去提高框架的性能</h4><p>1.序列化：在序列化，体积小，快速，安全</p>
<p>2.负载均衡：使用了hash一致性协议，来尽可能的让</p>
<p>3.netty：使用多路复用的技术，能够实现一个线程管理多个连接的目的</p>
]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-03-10-博客2.0</title>
    <url>/posts/758e.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-10-01-分布式</title>
    <url>/posts/91c5.html</url>
    <content><![CDATA[<h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><p><a href="https://www.bilibili.com/video/BV1VW4y1o7n5/?spm_id_from=333.337.search-card.all.click&vd_source=3b3520ea5845a2bda781e688011626d9">https://www.bilibili.com/video/BV1VW4y1o7n5/?spm_id_from=333.337.search-card.all.click&amp;vd_source=3b3520ea5845a2bda781e688011626d9</a></p>
<p><a href="http://icyfenix.cn/changelog/">http://icyfenix.cn/changelog/</a></p>
<h2 id="cap和base"><a href="#cap和base" class="headerlink" title="cap和base"></a>cap和base</h2><p><a href="https://baijiahao.baidu.com/s?id=1770092408059967099&wfr=spider&for=pc">https://baijiahao.baidu.com/s?id=1770092408059967099&amp;wfr=spider&amp;for=pc</a></p>
<h3 id="一、CAP定理"><a href="#一、CAP定理" class="headerlink" title="一、CAP定理"></a><strong>一、CAP定理</strong></h3><p>在一个分布式系统中（指互相连接并共享数据的节点集合）中，当涉及到读写操作时，只能保证一致性（Consistence）、可用性(Availability）、分区容错性（Partition Tolerance）三者中的两个，另外一个必须被牺牲。</p>
<p><strong>一致性(Consistence)</strong> , 这个是针对数据来说的，比如数据库MySQL中的数据，一个分布式系统中，某个节点修改了一个数据，那么之后其他所有节点读取这条数据的时候，得到的一定是最新的数据。</p>
<p>**可用性(Availability)**，分布式系统中某些节点挂掉了，但是不会影响整体的业务，比如 C 这个微服务，有10个实例组成一个集群，其中5个挂了，另外5个正常，这种情况下整个系统还是可用的，不会因为挂了那5个，导致系统整体不可用。</p>
<p>**分区容错性(Partition Tolerance)**，分布式系统出现网络分区的时候，仍然能够对外提供服务。</p>
<span id="more"></span>

<p>什么是网络分区？</p>
<p>分布式系统中，多个节点之前的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫网络分区。</p>
<p><strong>1.1只能三选二？</strong></p>
<p>因为在分布式系统中，网络不是100%可靠的，网络分区是必选项，也就是P是必选的，如果我们不选P，选CA，这个时候如果网络发生了分区，那么为了保证C，系统就会禁止写入数据，这样就与A产生了冲突，如果为了保证A，那么正常的分区可以写入数据，有故障的分区就不能写入了，这就与C产生了冲突。</p>
<p>简单来说，就是P是必须要实现的，因为网络不是100%可靠的，在此基础上C 和 A 二选一组成 CP 或者 AP 架构。</p>
<p>比如Zookeer 是CP架构，Eureka是AP架构，Nacos 不仅支持 CP 架构也支持 AP 架构。</p>
<p>对于服务注册来说，针对同一个服务，即使注册中心的不同节点保存的服务注册信息不相同，也并不会造成灾难性的后果，对于服务消费者来说，能消费才是最重要的，就算拿到的数据不是最新的数据，消费者本身也可以进行尝试失败重试。总比为了追求数据的一致性而获取不到实例信息整个服务不可用要好。</p>
<p>所以，对于服务注册来说，可用性比数据一致性更加的重要，选择AP。</p>
<p><strong>1.2 CAP的实际应用：注册中心</strong></p>
<p>Zookeeper 保证的是CP。任何时刻对Zookeeper的读请求都能得到一致的结果，但是zookeeper不&#96;能保证服务的可用性，比如在选举Leader的时候，或者一半以上的机器不可用，那么整个系统就是不可用状态。</p>
<p>Eureka保证的是AP。因为在设计的时候就是优先保证AP，而且Eureka集群中没有Leader节点，每个节点都是一样的，所以Eureka可以做到只要有一个节点可用，那么系统就是可用的，只不过这个节点上的数据不能保证是最新的。</p>
<h3 id="二、BASE理论"><a href="#二、BASE理论" class="headerlink" title="二、BASE理论"></a><strong>二、BASE理论</strong></h3><p><strong>BASE</strong> 是 <strong>Basically Available（基本可用）</strong>、<strong>Soft-state（软状态）</strong> 和 <strong>Eventually Consistent（最终一致性）</strong> BASE理论本质上是对CAP的延伸和补充，是对CAP中的AP方案的一个补充，即在选择AP方案的情况下，如何更好地最终达到C。</p>
<p><strong>基本可用：出现故障的时候，允许损失部分可用性，即，保证核心可用</strong></p>
<p>如，电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。</p>
<p><strong>软状态：允许系统存在中间状态，而该中间状态不会影响系统整体可用性。</strong></p>
<p>软状态本质上是一种弱一致性，允许的软状态不能违背“基本可用”的要求。如，kafka中可以对分区设置副本，允许不同节点间副本同步的延时。</p>
<p><strong>最终一致性：系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。</strong></p>
<p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
<p>分布式中的一致性有三种级别：</p>
<p>①强一致性：系统在某个节点中写入或修改了数据，那么之后在任意节点读取到的数据都是最新的数据。</p>
<p>②弱一致性：不一定能读到最新的值，也不能保证在一定时间后读取到的数据是最新的，只会尽量在某个时刻达到数据一致的状态。</p>
<p>③最终一致性：弱一致性的升级版，可以保证在一定时间内达到数据的最终一致性。</p>
<p>一般常用的是最终一致性，但是也有一些对一致性要求比较高的，比如银行的交易系统，这种要保证强一致性。</p>
<h3 id="补充：zookeeper集群"><a href="#补充：zookeeper集群" class="headerlink" title="补充：zookeeper集群"></a><strong>补充：zookeeper集群</strong></h3><p><strong>最典型集群模式：Master&#x2F;Slave 模式（主备模式）</strong>。在这种模式中，通常 Master 服务器作为主服务器提供写服务，其他的 Slave 服务器从服务器通过异步复制的方式获取 Master 服务器最新的数据提供读服务。</p>
<p><strong>ZooKeeper集群角色</strong></p>
<p>在ZooKeeper中没有选择传统的Master&#x2F;Slave慨念，而是引入了Leader、Follower和Observer三种角色。</p>
<img data-src="E:\study\javawebSys\Algorithms-4th-Edition-master\截图\image-20230906130406634.png" alt="image-20230906130406634" style="zoom:80%;" />

<p>ZooKeeper集群中的所有机器通过一个Leader选举过程来选定一台称为“Leader’”的机器，Leader既可以为客户端提供写服务又能提供读服务。除了Leader外，Follower和Observer都只能提供读服务。Follower和Observer唯一的区别在于Observer机器不参与Leader的选举过程，也不参与写操作的”过半写成功”策略，因此Observer机器可以在不影响写性能的情况下提升集群的读性能。</p>
<h3 id="ZooKeeper-集群-Leader-选举过程"><a href="#ZooKeeper-集群-Leader-选举过程" class="headerlink" title="ZooKeeper 集群 Leader 选举过程"></a>ZooKeeper 集群 Leader 选举过程</h3><p>当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，就会进入 Leader 选举过程，这个过程会选举产生新的 Leader 服务器。</p>
<p>这个过程大致是这样的：</p>
<ol>
<li><strong>Leader election（选举阶段）</strong>：节点一开始处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准 leader。然后followers跟准leader进行通信，同步followers最近接收的事务提议。</li>
<li><strong>Synchronization（同步阶段）</strong> :同步阶段主要是利用 leader 前一阶段获得的事务提议，同步集群中所有的副本。同步完成之后准 leader 才会成为真正的 leader。</li>
</ol>
<h3 id="ZooKeeper-集群为啥最好奇数台？"><a href="#ZooKeeper-集群为啥最好奇数台？" class="headerlink" title="ZooKeeper 集群为啥最好奇数台？"></a>ZooKeeper 集群为啥最好奇数台？</h3><p>ZooKeeper 集群在宕掉几个 ZooKeeper 服务器之后，如果剩下的 ZooKeeper 服务器个数大于宕掉的个数的话整个 ZooKeeper 才依然可用。</p>
<p>比如假如我们有 3 台，那么最大允许宕掉 1 台 ZooKeeper 服务器，如果我们有 4 台的的时候也同样只允许宕掉 1 台。 假如我们有 5 台，那么最大允许宕掉 2 台 ZooKeeper 服务器，如果我们有 6 台的的时候也同样只允许宕掉 2 台。综上，何必增加那一个不必要的 ZooKeeper 呢？</p>
<h3 id="ZooKeeper-选举的过半机制防止脑裂"><a href="#ZooKeeper-选举的过半机制防止脑裂" class="headerlink" title="ZooKeeper 选举的过半机制防止脑裂"></a>ZooKeeper 选举的过半机制防止脑裂</h3><p><strong>何为集群脑裂？</strong></p>
<p>对于一个集群，通常多台机器会部署在不同机房，来提高这个集群的可用性。保证可用性的同时，会发生一种机房间网络线路故障，导致机房间网络不通，而集群被割裂成几个小集群。这时候子集群各自选主导致“脑裂”的情况。</p>
<p>举例说明：比如现在有一个由 6 台服务器所组成的一个集群，部署在了 2 个机房，每个机房 3 台。正常情况下只有 1 个 leader，但是当两个机房中间网络断开的时候，每个机房的 3 台服务器都会认为另一个机房的 3 台服务器下线，而选出自己的 leader 并对外提供服务。若没有过半机制，当网络恢复的时候会发现有 2 个 leader。仿佛是 1 个大脑（leader）分散成了 2 个大脑，这就发生了脑裂现象。脑裂期间 2 个大脑都可能对外提供了服务，这将会带来数据一致性等问题。</p>
<p><strong>过半机制是如何防止脑裂现象产生的？</strong></p>
<p>ZooKeeper 的过半机制导致不可能产生 2 个 leader，因为少于等于一半是不可能产生 leader 的，这就使得不论机房的机器如何分配都不可能发生脑裂。</p>
<h2 id="什么是微服务架构"><a href="#什么是微服务架构" class="headerlink" title="什么是微服务架构"></a>什么是微服务架构</h2><p>微服务是一种通过多个小型服务组合来构建单个应用的架构风格，各个服务相互解耦，运行在不同的进程之中。微服务之间的通信一般会采用调用远程方法RPC实现。</p>
<p>单体架构（Monolithic）</p>
<p>“单体”只是表明系统中主要的过程调用都是进程内调用，不会发生进程间通信，仅此而已。</p>
<p>微服务的优点：</p>
<p>1.模块之间解耦：模块之间的解耦好处包括，技术选型的多样性，横向扩展方便等</p>
<p>2.服务可用性：在“拆分”这方面，单体系统的真正缺陷不在如何拆分，而在拆分之后的隔离与自治能力上的欠缺。由于所有代码都运行在同一个进程空间之内，所有模块、方法的调用都无须考虑网络分区、对象复制这些麻烦的事和性能损失。获得了进程内调用的简单、高效等好处的同时，也意味着如果任何一部分代码出现了缺陷，过度消耗了进程空间内的资源，所造成的影响也是全局性的、难以隔离的。譬如内存泄漏、线程爆炸、阻塞、死循环等问题，都将会影响整个程序，而不仅仅是影响某一个功能、模块本身的正常运作。</p>
<p>微服务的缺点：</p>
<p>1.远程调用的消耗：相比于本地调用，远程调用除了会消耗带宽外，对网络环境的要求会更高</p>
<p>2.分布式带来的编程复杂性：最经典的就是分布式锁的实现。</p>
<p>3.项目部署会跟复杂：</p>
<p>微服务项目的版本：</p>
<p>1.0：仅使用注册发现和远程过程调用来开发。</p>
<p>2.0：使用了熔断，限流，降级等服务治理策略。</p>
<p>3.0：</p>
<h2 id="访问远程服务"><a href="#访问远程服务" class="headerlink" title="访问远程服务"></a>访问远程服务</h2><h3 id="远程服务调用（RPC）"><a href="#远程服务调用（RPC）" class="headerlink" title="远程服务调用（RPC）"></a>远程服务调用（RPC）</h3><p>通过远程服务调用RPC可以使得微服务系统中不同服务之间的调用像本地一样，但是相比调用本地方法，rpc需要考虑很多的问题。</p>
<p>譬如，<strong>外部的服务由谁提供？具体在什么网络位置？（服务发现），如何保证每个远程服务都接收到相对平均的流量，获得尽可能高的服务质量与可靠性（负载均衡）</strong>，网络出现分区、超时或者服务出错了怎么办（熔断、隔离、降级），<strong>方法的参数与返回结果如何表示（序列化协议），信息如何传输（传输协议）</strong>，服务权限如何管理（认证、授权），如何保证通信安全（网络安全层），如何令调用不同机器的服务返回相同的结果（分布式数据一致性）等一系列问题，全部都需要设计者耗费大量心思。</p>
<p>gRPC 和 Thrift 都有自己优秀的专有序列化器。</p>
<p>而传输协议方面，gRPC 是基于 HTTP&#x2F;2 的，支持多路复用和 Header 压缩，Thrift 则直接基于传输层的 TCP 协议来实现，省去了额外应用层协议的开销。Dubbo 表现得更为明显，它默认有自己的传输协议（Dubbo 协议），同时也支持其他协议；</p>
<h3 id="REST设计风格"><a href="#REST设计风格" class="headerlink" title="REST设计风格"></a>REST设计风格</h3><p>首先REST不是一种协议，而是一种风格，面向资源的编程思想</p>
<p><strong>RESTful风格是一种基于HTTP协议设计Web API的软件架构风格，由Roy Fielding在2000年提出。它强调使用HTTP动词来表示对资源的操作（GET、POST、PUT、PATCH、DELETE等），并通过URI表示资源的唯一标识符。</strong></p>
<p><strong>restful API的设计遵循以下几个原则：</strong>：</p>
<ol>
<li><strong>基于资源</strong>：<strong>将数据和功能抽象成资源，并通过URI来唯一标识资源。例如，一个用户资源可以通过URL“&#x2F;users&#x2F;{id}”来访问，其中“{id}”表示该用户的唯一标识符。</strong></li>
<li><strong>无状态</strong>（Stateless）<br><strong>REST 希望服务器不要去负责维护状态，每一次从客户端发送的请求中，应包括所有的必要的上下文信息，会话信息也由客户端负责保存维护，服务端依据客户端传递的状态来执行业务处理逻辑，驱动整个应用的状态变迁。</strong>客户端承担状态维护职责以后，会产生一些新的问题，譬如身份认证、授权等可信问题，它们都应有针对性的解决方案</li>
<li><strong>可缓存</strong>（Cacheability）<br><strong>无状态服务虽然提升了系统的可见性、可靠性和可伸缩性，但降低了系统的网络性。</strong>“降低网络性”的通俗解释是某个功能如果使用有状态的设计只需要一次（或少量）请求就能完成，使用无状态的设计则可能会需要多次请求，或者在请求中带有额外冗余的信息。<strong>为了缓解这个矛盾，REST允许客户端将部分服务端的应答缓存起来。当然，为了缓存能够正确地运作，服务端的应答中必须明确地或者间接地表明本身是否可以进行缓存、可以缓存多长时间，以避免客户端在将来进行请求的时候得到过时的数据。</strong>运作良好的缓存机制可以减少客户端、服务器之间的交互，甚至有些场景中可以完全避免交互，这就进一步提高了性能。</li>
<li><strong>统一接口</strong>（Uniform Interface）<br><strong>使用统一的接口来简化客户端与服务器之间的交互，包括资源标识符、资源操作和响应消息的格式。</strong>比如使用get请求用来获取资源，post增加资源，put修改资源，delete删除资源，使用http状态码作为响应信息头等</li>
</ol>
<h3 id="RESFUL与RPC的关系"><a href="#RESFUL与RPC的关系" class="headerlink" title="RESFUL与RPC的关系"></a>RESFUL与RPC的关系</h3><p>RESTFUL的优点（<strong>RPC的缺点</strong>）</p>
<p><strong>降低服务接口的学习成本。</strong>统一接口（Uniform Interface）是 REST 的重要标志，将对资源的标准操作都映射到了标准的 HTTP 方法上去，这些方法对于每个资源的用法都是一致的</p>
<p>REST 绑定于 HTTP 协议。面向资源编程不是必须构筑在 HTTP 之上，但 REST 是，这是缺点，也是优点。因为 HTTP 本来就是面向资源而设计的网络协议，纯粹只用 HTTP带来的好处是 <strong>RPC 中的 Wire Protocol 问题</strong>就无需再多考虑了，REST 将复用 HTTP 协议中已经定义的概念和相关基础支持来解决问题。</p>
<p><strong>RESTFUL一般是前后端分离的项目，页面中含有请求的地址没有服务发现这些概念；而RPC一般用于服务端之间调用，需要服务发现的手段。</strong></p>
<p>RESTFUL的缺点（<strong>RPC的优点</strong>）</p>
<p>面向资源的编程思想只适合做 CRUD，面向过程、面向对象编程才能处理真正<strong>复杂的业务逻辑</strong></p>
<p>REST 与 HTTP 完全绑定，<strong>不适合应用于要求高性能传输的场景中</strong></p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="客户端缓存"><a href="#客户端缓存" class="headerlink" title="客户端缓存"></a>客户端缓存</h3><p>HTTP 协议的无状态性决定了它必须依靠客户端缓存来解决网络传输效率上的缺陷。</p>
<p>无状态简化了HTTP 服务器的设计但无状态并不只有好的一面，由于每次请求都是独立的，服务端不保存此前请求的状态和资源，所以也不可避免地导致其携带有重复的数据，造成网络性能降低。HTTP使用强制缓存和协商缓存的机制。</p>
<p>强制缓存，协商缓存（具体见计网2）</p>
<h3 id="服务端缓存"><a href="#服务端缓存" class="headerlink" title="服务端缓存"></a>服务端缓存</h3><p>服务端缓存的主要目的是提高系统响应性能，通过把经常被访问的数据放入缓存从而减少磁盘的IO操作，最原始的实现方法就是使用Map容器来实现，如今一般会使用redis来作为缓存中间件使用，主要是因为它支持分布式缓存，更丰富的数据结构，实现缓存淘汰等等。</p>
<p>使用服务端缓存的优点主要是缓解 I&#x2F;O 压力：譬如把原本对网络、磁盘等较慢介质的读写访问变为对内存等较快介质的访问，将原本对数据库的读写访问变为缓存中间件的访问，提升响应性能。</p>
<p>使用缓存需要考虑的问题（缓存的缺点）</p>
<ul>
<li><p>内存的储存容量时有限的：缓存淘汰策略</p>
<p><strong>LRU</strong>（Least Recent Used）：优先淘汰最久未被使用访问过的数据。</p>
<p><strong>LFU</strong>（Least Frequently Used）：优先淘汰最不经常使用的数据。LFU 会给每个数据添加一个访问计数器，每访问一次就加 1，需要淘汰时就清理计数器数值最小的那批数据。</p>
</li>
<li><p>数据一致性问题：强一致性和最终一致性</p>
</li>
<li><p>缓存的风险：穿透，击穿，雪崩</p>
</li>
</ul>
<h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>对消费者来说，外部的服务由谁提供？具体在什么网络位置？</p>
<h3 id="1-服务发现的意义"><a href="#1-服务发现的意义" class="headerlink" title="1.服务发现的意义"></a>1.服务发现的意义</h3><p><strong>在单体架构中，方法之间的调用通过链接器将代码里的符号引用转换为内存地址的直接引用；而在微服务架构中，不同的方法会分布在不同的服务器上，因此方法之间的调用需要服务发现来确定目标方法的确切位置。</strong></p>
<p>占主流地位的服务发现方法类似于 DNS ，只满足从某个代表服务提供者的全限定名到服务实际主机 IP 地址的翻译转换，并不关心服务具体是哪个厂家提供的，也不关心服务有几个方法，各自由什么参数构成，默认这些细节信息是服务消费者本身已完全了解的，此时服务坐标就可以退化为更简单的“全限定名+端口号”。</p>
<p>虽然使用负载均衡器也能完成外部 IP 地址到各个服务内部实际 IP 的转换，但随着微服务的逐渐流行，服务的非正常宕机、重启和正常的上线、下线变得越发频繁，仅靠着 DNS 服务器和负载均衡器就会变得笨重。</p>
<h3 id="2-服务发现的操作"><a href="#2-服务发现的操作" class="headerlink" title="2.服务发现的操作"></a>2.服务发现的操作</h3><ul>
<li>服务的注册：当服务启动的时候将自己的坐标信息通知到服务注册中心，这个过程可能由应用程序本身来完成。</li>
<li>服务的维护：当服务下线，或者宕机、断网导致服务不可以用时，需要维护的服务列表的正确性，避免告知消费者服务的坐标后，得到的服务却不能使用的尴尬情况。可以使用长连接、心跳、探针等去监控服务是否健康存活，将不健康的服务自动从服务注册表中剔除。</li>
<li>服务的发现：消费者获取全限定名的过程。一般会使用接口的全限定名来表示</li>
</ul>
<h3 id="3-作为注册中心的工具"><a href="#3-作为注册中心的工具" class="headerlink" title="3.作为注册中心的工具"></a>3.作为注册中心的工具</h3><ul>
<li><p>在分布式 K&#x2F;V 存储框架上自己开发服务发现功能，这类的代表是 ZooKeeper。</p>
<p>像zookeeper框架只有基本的 CRUD 和 Watch 等少量 API，所以要在上面完成功能齐全的服务发现，很多基础的能力，譬如服务如何注册、如何做健康检查，等等都必须自己去实现。</p>
</li>
<li><p>使用专门用于服务发现的框架和工具，这类的代表是 Eureka 和 Nacos。</p>
<p>像这种框架的优点就是方便使用和配置，缺点就是需要考虑所用的程序语言问题。</p>
</li>
</ul>
<h2 id="网关路由"><a href="#网关路由" class="headerlink" title="网关路由"></a>网关路由</h2><p>对生产者来说，内部哪些服务需要暴露？哪些应当隐藏？应当以何种形式暴露服务？以什么规则在集群中分配请求？</p>
<p>微服务中网关的首要职责就是作为统一的出口对外提供服务，将外部访问网关地址的流量，根据适当的规则路由到内部集群中正确的服务节点之上，因此，微服务中的网关，也常被称为“服务网关”或者“API 网关”，微服务中的网关首先应该是个路由器，在满足此前提的基础上，网关还可以根据需要作为流量过滤器来使用，提供某些额外的可选的功能，譬如安全、认证、授权、限流、监控、缓存，等等</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>对调用过程来说，如何保证每个远程服务都接收到相对平均的流量，获得尽可能高的服务质量与可靠性？</p>
<h3 id="1-负载均衡算法"><a href="#1-负载均衡算法" class="headerlink" title="1.负载均衡算法"></a><strong>1.负载均衡算法</strong></h3><p>负载均衡的两大职责是“选择谁来处理用户请求”和“将用户请求转发过去”。到此我们仅介绍了后者，即请求的转发或代理过程。前者是指均衡器所采取的均衡策略，由于这一块涉及的均衡算法太多，笔者无法逐一展开，所以本节仅从功能和应用的角度去介绍一些常见的均衡策略。</p>
<ul>
<li><strong>轮循均衡</strong>（Round Robin）：每一次来自网络的请求轮流分配给内部中的服务器，从 1 至 N 然后重新开始。此种均衡算法适合于集群中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。</li>
<li><strong>权重轮循均衡</strong>（Weighted Round Robin）：根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请求。譬如：服务器 A 的权值被设计成 1，B 的权值是 3，C 的权值是 6，则服务器 A、B、C 将分别接收到 10%、30％、60％的服务请求。此种均衡算法能确保高性能的服务器得到更多的使用率，避免低性能的服务器负载过重。</li>
<li><strong>随机均衡</strong>（Random）：把来自客户端的请求随机分配给内部中的多个服务器，在数据足够大的场景下能达到相对均衡的分布。</li>
<li><strong>一致性哈希均衡</strong>（Consistency Hash）：根据请求中某一些数据（可以是 MAC、IP 地址，也可以是更上层协议中的某些参数信息）作为特征值来计算需要落在的节点上，算法一般会保证同一个特征值每次都一定落在相同的服务器上。一致性的意思是保证当服务集群某个真实服务器出现故障，只影响该服务器的哈希，而不会导致整个服务集群的哈希键值重新分布。</li>
<li><strong>响应速度均衡</strong>（Response Time）：负载均衡设备对内部各服务器发出一个探测请求（例如 Ping），然后根据内部中各服务器对探测请求的最快响应时间来决定哪一台服务器来响应客户端的服务请求。此种均衡算法能较好的反映服务器的当前运行状态，但这最快响应时间仅仅指的是负载均衡设备与服务器间的最快响应时间，而不是客户端与服务器间的最快响应时间。</li>
<li><strong>最少连接数均衡</strong>（Least Connection）：客户端的每一次请求服务在服务器停留的时间可能会有较大的差异，随着工作时间加长，如果采用简单的轮循或随机均衡算法，每一台服务器上的连接进程可能会产生极大的不平衡，并没有达到真正的负载均衡。最少连接数均衡算法对内部中需负载的每一台服务器都有一个数据记录，记录当前该服务器正在处理的连接数量，当有新的服务连接请求时，将把当前请求分配给连接数最少的服务器，使均衡更加符合实际情况，负载更加均衡。此种均衡策略适合长时处理的请求服务，如 FTP 传输。</li>
</ul>
<h3 id="2-负载均衡器"><a href="#2-负载均衡器" class="headerlink" title="2.负载均衡器"></a><strong>2.负载均衡器</strong></h3><p>硬件均衡器，nginx通过反向代理实现。反向代理指前端请求的地址为代理服务器的地址，代理服务器重写请求的服务地址（根据uri），并发送请求给后端服务器，也就是前端从头到尾都不知道具体服务器的地址。在重写请求的时候使用负载均衡算法。</p>
<p>客户端层负载均衡器，其代表是spring cloud中的LoadBalancer。这里的客户端指调用者，这种负载均衡器的特点是由客户端自己去不断去发现更新维护自己的一套服务列表，自己去定义服务的均衡负载策略，然后获取具体的服务实例。</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/v2-5dd9961f01d21283b622b6ef08270f08_r.jpg" alt="img"></p>
<h2 id="流量治理"><a href="#流量治理" class="headerlink" title="流量治理"></a>流量治理</h2><h3 id="服务容错"><a href="#服务容错" class="headerlink" title="服务容错"></a>服务容错</h3><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><h4 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h4><p>1.计数器算法</p>
<p>在指定周期内累加访问次数，当访问次数达到设定的阈值时，触发限流策略，当进入下一个时间周期时<strong>进行访问次数的清零</strong>。如图所示，我们要求3秒内的请求不要超过150次：</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/0b46f21fbe096b6376e07b1d01be2e48eaf8ac1f.jpeg" alt="img"></p>
<p>但是，貌似看似很“完美”的流量统计方式其实存在一个非常严重的<strong>临界问题</strong>，即：如果第2到3秒内产生了<code>150</code>次请求，而第3到4秒内产生了<code>150</code>次请求，那么其实在第2秒到第4秒这两秒内，就已经发生了<code>300</code>次请求了，远远大于我们要求的<strong>3秒内的请求不要超过150次</strong>这个限制，如下图所示：</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/a1ec08fa513d2697304b25ed5d761bf74216d87b.jpeg" alt="img"></p>
<p>2.滑动窗口算法</p>
<p>滑动窗口为固定窗口的改良版，解决了固定窗口在窗口切换时会受到两倍于阈值数量的请求，滑动窗口在固定窗口的基础上，<strong>将一个窗口分为若干个等份的小窗口</strong>，每个小窗口对应不同的时间点，拥有独立的计数器，当请求的时间点大于当前窗口的最大时间点时，则将窗口向前平移一个小窗口（将第一个小窗口的数据舍弃，第二个小窗口变成第一个小窗口，当前请求放在最后一个小窗口），整个窗口的所有请求数相加不能大于阈值。其中，<strong>Sentinel</strong>就是采用滑动窗口算法来实现限流的。如图所示：</p>
<p><img data-src="https://yeb-1300251269.cos.ap-guangzhou.myqcloud.com/mytypra/aa18972bd40735fafb346f9996dca6bf0e240866-16989466511937.jpeg" alt="img"></p>
<blockquote>
<p><strong>【1】</strong> 把3秒钟划分为3个小窗，每个小窗限制请求不能超过50个。<br><strong>【2】</strong> 比如我们设置，3秒内不能超过150个请求，那么这个窗口就可以容纳3个小窗，并且随着时间推移，往前滑动。每次请求过来后，都要统计滑动窗口内所有小窗的请求总量。</p>
</blockquote>
<p>3.令牌桶限流算法</p>
<p>令牌桶是<strong>网络流量整形</strong>（Traffic Shaping）和<strong>速率限制</strong>（Rate Limiting）中最常使用的一种算法。对于每一个请求，都需要从令牌桶中获得一个令牌；如果没有获得令牌，则需要触发限流策略。系统会以<strong>恒定速度</strong>（r tokens&#x2F;sec）往固定容量的令牌桶中<strong>放入令牌</strong>。<strong>令牌桶有固定的大小</strong>，如果令牌桶被填满，则会<strong>丢弃令牌</strong>。</p>
<p>会存在三种情况：</p>
<blockquote>
<p>【<strong>请求速度 大于 令牌生成速度</strong>】当令牌被取空后，会被限流<br>【<strong>请求速度 等于 令牌生成速度</strong>】流量处于平稳状态<br>【<strong>请求速度 小于 令牌生成速度</strong>】请求可被正常处理，桶满则丢弃令牌</p>
</blockquote>
<p>熔断</p>
<p>当下游服务因访问压力过大而响应变慢或失败，上游服务为了保护系统整体的可用性，可以暂时切断对下游服务的调用。</p>
<p>这种牺牲局部，保全整体的措施就叫做熔断。</p>
<p>降级</p>
<p>服务降级是指 当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心业务正常运作或高效运作。说白了，就是尽可能的把系统资源让给优先级高的服务。</p>
<p>在双 11 时，使用的人比较多，此时如果开放所有功能，可能会导致系统不可用，所以此时可以开启降级功能，优先保证支付功能可用，而其他非核心功能，如评论、物流、商品介绍等功能可以暂时关闭。</p>
]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
      </tags>
  </entry>
</search>
